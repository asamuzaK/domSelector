{"version":3,"sources":["../../src/index.js","../../src/js/parser.js","../../src/js/utility.js","../../src/js/constant.js","../../src/js/matcher.js","../../src/js/finder.js"],"sourcesContent":["/*!\n * DOM Selector - A CSS selector engine.\n * @license MIT\n * @copyright asamuzaK (Kazz)\n * @see {@link https://github.com/asamuzaK/domSelector/blob/main/LICENSE}\n */\n\n/* import */\nimport { Finder } from './js/finder.js';\nimport { filterSelector, getType, initNwsapi } from './js/utility.js';\n\n/* constants */\nimport {\n  COMBO, COMPOUND_I, DESCEND, DOCUMENT_NODE, ELEMENT_NODE, TAG_ID_CLASS,\n  TARGET_ALL, TARGET_FIRST, TARGET_LINEAL, TARGET_SELF\n} from './js/constant.js';\nconst REG_COMPLEX = new RegExp(`${COMPOUND_I}${COMBO}${COMPOUND_I}`, 'i');\nconst REG_DESCEND = new RegExp(`${COMPOUND_I}${DESCEND}${COMPOUND_I}`, 'i');\nconst REG_SIMPLE = new RegExp(`^${TAG_ID_CLASS}$`);\n\n/* DOMSelector */\nexport class DOMSelector {\n  /* private fields */\n  #window;\n  #document;\n  #finder;\n  #nwsapi;\n\n  /**\n   * construct\n   * @param {object} window - window\n   * @param {object} document - document\n   */\n  constructor(window, document) {\n    this.#window = window;\n    this.#document = document ?? window.document;\n    this.#finder = new Finder(window);\n    this.#nwsapi = initNwsapi(window, document);\n  }\n\n  /**\n   * matches\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - `true` if matched `false` otherwise\n   */\n  matches(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    } else if (node.nodeType !== ELEMENT_NODE) {\n      const e = new this.#window.TypeError(`Unexpected node ${node.nodeName}`);\n      this.#finder.onError(e, opt);\n    }\n    const document = node.ownerDocument;\n    if (document === this.#document && document.contentType === 'text/html' &&\n        node.parentNode) {\n      const filterOpt = {\n        complex: REG_COMPLEX.test(selector),\n        compound: false,\n        descend: false,\n        simple: false,\n        target: TARGET_SELF\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.match(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_SELF);\n      res = nodes.size;\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return !!res;\n  }\n\n  /**\n   * closest\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  closest(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    } else if (node.nodeType !== ELEMENT_NODE) {\n      const e = new this.#window.TypeError(`Unexpected node ${node.nodeName}`);\n      this.#finder.onError(e, opt);\n    }\n    const document = node.ownerDocument;\n    if (document === this.#document && document.contentType === 'text/html' &&\n        node.parentNode) {\n      const filterOpt = {\n        complex: REG_COMPLEX.test(selector),\n        compound: false,\n        descend: false,\n        simple: false,\n        target: TARGET_LINEAL\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.closest(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_LINEAL);\n      if (nodes.size) {\n        let refNode = node;\n        while (refNode) {\n          if (nodes.has(refNode)) {\n            res = refNode;\n            break;\n          }\n          refNode = refNode.parentNode;\n        }\n      }\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  querySelector(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    }\n    let document;\n    if (node.nodeType === DOCUMENT_NODE) {\n      document = node;\n    } else {\n      document = node.ownerDocument;\n    }\n    if (document === this.#document && document.contentType === 'text/html') {\n      const filterOpt = {\n        complex: false,\n        compound: !(REG_SIMPLE.test(selector) || REG_COMPLEX.test(selector)),\n        descend: REG_DESCEND.test(selector),\n        simple: REG_SIMPLE.test(selector),\n        target: TARGET_FIRST\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.first(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_FIRST);\n      if (nodes.size) {\n        [res] = nodes;\n      }\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector all\n   * NOTE: returns Array, not NodeList\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {Array.<object|undefined>} - collection of matched nodes\n   */\n  querySelectorAll(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    }\n    let document;\n    if (node.nodeType === DOCUMENT_NODE) {\n      document = node;\n    } else {\n      document = node.ownerDocument;\n    }\n    if (document === this.#document && document.contentType === 'text/html') {\n      const filterOpt = {\n        complex: false,\n        compound: false,\n        descend: REG_DESCEND.test(selector),\n        simple: false,\n        target: TARGET_ALL\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.select(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_ALL);\n      if (nodes.size) {\n        res = [...nodes];\n      }\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return res ?? [];\n  }\n}\n","/**\n * parser.js\n */\n\n/* import */\nimport { findAll, parse, toPlainObject, walk } from 'css-tree';\nimport { getType } from './utility.js';\n\n/* constants */\nimport {\n  ATTR_SELECTOR, BIT_01, BIT_02, BIT_04, BIT_08, BIT_16, BIT_32, BIT_FFFF,\n  CLASS_SELECTOR, DUO, HEX, HYPHEN, ID_SELECTOR, KEY_LOGICAL, KEY_PS_STATE,\n  KEY_SHADOW_HOST, NTH, PS_CLASS_SELECTOR, PS_ELEMENT_SELECTOR, SELECTOR,\n  SYNTAX_ERR, TYPE_SELECTOR\n} from './constant.js';\nconst REG_EMPTY_PS_FUNC = /(?<=:(?:dir|has|host(?:-context)?|is|lang|not|nth-(?:last-)?(?:child|of-type)|where))\\(\\s+\\)/g;\nconst REG_SHADOW_PS_ELEMENT = /^part|slotted$/;\nconst U_FFFD = '\\uFFFD';\n\n/**\n * unescape selector\n * @param {string} selector - CSS selector\n * @returns {?string} - unescaped selector\n */\nexport const unescapeSelector = (selector = '') => {\n  if (typeof selector === 'string' && selector.indexOf('\\\\', 0) >= 0) {\n    const arr = selector.split('\\\\');\n    const l = arr.length;\n    for (let i = 1; i < l; i++) {\n      let item = arr[i];\n      if (item === '' && i === l - 1) {\n        item = U_FFFD;\n      } else {\n        const hexExists = /^([\\da-f]{1,6}\\s?)/i.exec(item);\n        if (hexExists) {\n          const [, hex] = hexExists;\n          let str;\n          try {\n            const low = parseInt('D800', HEX);\n            const high = parseInt('DFFF', HEX);\n            const deci = parseInt(hex, HEX);\n            if (deci === 0 || (deci >= low && deci <= high)) {\n              str = U_FFFD;\n            } else {\n              str = String.fromCodePoint(deci);\n            }\n          } catch (e) {\n            str = U_FFFD;\n          }\n          let postStr = '';\n          if (item.length > hex.length) {\n            postStr = item.substring(hex.length);\n          }\n          item = `${str}${postStr}`;\n        // whitespace\n        } else if (/^[\\n\\r\\f]/.test(item)) {\n          item = '\\\\' + item;\n        }\n      }\n      arr[i] = item;\n    }\n    selector = arr.join('');\n  }\n  return selector;\n};\n\n/**\n * preprocess\n * @see https://drafts.csswg.org/css-syntax-3/#input-preprocessing\n * @param {...*} args - arguments\n * @returns {string} - filtered selector string\n */\nexport const preprocess = (...args) => {\n  if (!args.length) {\n    throw new TypeError('1 argument required, but only 0 present.');\n  }\n  let [selector] = args;\n  if (typeof selector === 'string') {\n    let index = 0;\n    while (index >= 0) {\n      // @see https://drafts.csswg.org/selectors/#id-selectors\n      index = selector.indexOf('#', index);\n      if (index < 0) {\n        break;\n      }\n      const preHash = selector.substring(0, index + 1);\n      let postHash = selector.substring(index + 1);\n      // @see https://drafts.csswg.org/css-syntax-3/#ident-token-diagram\n      if (/^\\d$/.test(postHash.substring(0, 1))) {\n        throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n      }\n      const codePoint = postHash.codePointAt(0);\n      if (codePoint === HYPHEN) {\n        if (/^\\d$/.test(postHash.substring(1, 2))) {\n          throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n        }\n      // escape char above 0xFFFF\n      } else if (codePoint > BIT_FFFF) {\n        const str = `\\\\${codePoint.toString(HEX)} `;\n        if (postHash.length === DUO) {\n          postHash = str;\n        } else {\n          postHash = `${str}${postHash.substring(DUO)}`;\n        }\n      }\n      selector = `${preHash}${postHash}`;\n      index++;\n    }\n    selector = selector.replace(/\\f|\\r\\n?/g, '\\n')\n      .replace(/[\\0\\uD800-\\uDFFF]|\\\\$/g, U_FFFD);\n  } else if (selector === undefined || selector === null) {\n    selector = getType(selector).toLowerCase();\n  } else if (Array.isArray(selector)) {\n    selector = selector.join(',');\n  } else if (Object.prototype.hasOwnProperty.call(selector, 'toString')) {\n    selector = selector.toString();\n  } else {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  return selector.replace(/\\x26/g, ':scope');\n};\n\n/**\n * create AST from CSS selector\n * @param {string} selector - CSS selector\n * @returns {object} - AST\n */\nexport const parseSelector = selector => {\n  selector = preprocess(selector);\n  // invalid selectors\n  if (/^$|^\\s*>|,\\s*$/.test(selector)) {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  let res;\n  try {\n    const ast = parse(selector, {\n      context: 'selectorList',\n      parseCustomProperty: true\n    });\n    res = toPlainObject(ast);\n  } catch (e) {\n    const { message } = e;\n    if (/^(?:\"\\]\"|Attribute selector [()\\s,=~^$*|]+) is expected$/.test(message) &&\n        !selector.endsWith(']')) {\n      const index = selector.lastIndexOf('[');\n      const sel = selector.substring(index);\n      if (sel.includes('\"')) {\n        const quotes = sel.match(/\"/g).length;\n        if (quotes % 2) {\n          res = parseSelector(`${selector}\"]`);\n        } else {\n          res = parseSelector(`${selector}]`);\n        }\n      } else {\n        res = parseSelector(`${selector}]`);\n      }\n    } else if (message === '\")\" is expected') {\n      // workaround for https://github.com/csstree/csstree/issues/283\n      if (REG_EMPTY_PS_FUNC.test(selector)) {\n        res = parseSelector(`${selector.replaceAll(REG_EMPTY_PS_FUNC, '()')}`);\n      } else if (!selector.endsWith(')')) {\n        res = parseSelector(`${selector})`);\n      } else {\n        throw new DOMException(message, SYNTAX_ERR);\n      }\n    } else {\n      throw new DOMException(message, SYNTAX_ERR);\n    }\n  }\n  return res;\n};\n\n/**\n * walk AST\n * @param {object} ast - AST\n * @returns {Array.<object|undefined>} - collection of AST branches\n */\nexport const walkAST = (ast = {}) => {\n  const branches = new Set();\n  const info = new Map();\n  const opt = {\n    enter: node => {\n      switch (node.type) {\n        case SELECTOR: {\n          branches.add(node.children);\n          break;\n        }\n        case PS_CLASS_SELECTOR: {\n          if (KEY_LOGICAL.includes(node.name)) {\n            info.set('hasNestedSelector', true);\n            info.set('hasLogicalPseudoFunc', true);\n            if (node.name === 'has') {\n              info.set('hasHasPseudoFunc', true);\n            }\n          } else if (KEY_PS_STATE.includes(node.name)) {\n            info.set('hasStatePseudoClass', true);\n          } else if (KEY_SHADOW_HOST.includes(node.name) &&\n                     Array.isArray(node.children) && node.children.length) {\n            info.set('hasNestedSelector', true);\n          }\n          break;\n        }\n        case PS_ELEMENT_SELECTOR: {\n          if (REG_SHADOW_PS_ELEMENT.test(node.name)) {\n            info.set('hasNestedSelector', true);\n          }\n          break;\n        }\n        case NTH: {\n          if (node.selector) {\n            info.set('hasNestedSelector', true);\n            info.set('hasNthChildOfSelector', true);\n          }\n          break;\n        }\n        default:\n      }\n    }\n  };\n  walk(ast, opt);\n  if (info.get('hasNestedSelector')) {\n    findAll(ast, (node, item, list) => {\n      if (list) {\n        if (node.type === PS_CLASS_SELECTOR &&\n            KEY_LOGICAL.includes(node.name)) {\n          const itemList = list.filter(i => {\n            const { name, type } = i;\n            return type === PS_CLASS_SELECTOR && KEY_LOGICAL.includes(name);\n          });\n          for (const { children } of itemList) {\n            // SelectorList\n            for (const { children: grandChildren } of children) {\n              // Selector\n              for (const { children: greatGrandChildren } of grandChildren) {\n                if (branches.has(greatGrandChildren)) {\n                  branches.delete(greatGrandChildren);\n                }\n              }\n            }\n          }\n        } else if (node.type === PS_CLASS_SELECTOR &&\n                   KEY_SHADOW_HOST.includes(node.name) &&\n                   Array.isArray(node.children) && node.children.length) {\n          const itemList = list.filter(i => {\n            const { children, name, type } = i;\n            const res =\n              type === PS_CLASS_SELECTOR && KEY_SHADOW_HOST.includes(name) &&\n              Array.isArray(children) && children.length;\n            return res;\n          });\n          for (const { children } of itemList) {\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        } else if (node.type === PS_ELEMENT_SELECTOR &&\n                   REG_SHADOW_PS_ELEMENT.test(node.name)) {\n          const itemList = list.filter(i => {\n            const { name, type } = i;\n            const res =\n              type === PS_ELEMENT_SELECTOR && REG_SHADOW_PS_ELEMENT.test(name);\n            return res;\n          });\n          for (const { children } of itemList) {\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        } else if (node.type === NTH && node.selector) {\n          const itemList = list.filter(i => {\n            const { selector, type } = i;\n            const res = type === NTH && selector;\n            return res;\n          });\n          for (const { selector } of itemList) {\n            const { children } = selector;\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  return {\n    branches: [...branches],\n    info: Object.fromEntries(info)\n  };\n};\n\n/**\n * sort AST\n * @param {Array.<object>} asts - collection of AST\n * @returns {Array.<object>} - collection of sorted AST\n */\nexport const sortAST = asts => {\n  const arr = [...asts];\n  if (arr.length > 1) {\n    const order = new Map([\n      [PS_ELEMENT_SELECTOR, BIT_01],\n      [ID_SELECTOR, BIT_02],\n      [CLASS_SELECTOR, BIT_04],\n      [TYPE_SELECTOR, BIT_08],\n      [ATTR_SELECTOR, BIT_16],\n      [PS_CLASS_SELECTOR, BIT_32]\n    ]);\n    arr.sort((a, b) => {\n      const { type: typeA } = a;\n      const { type: typeB } = b;\n      const bitA = order.get(typeA);\n      const bitB = order.get(typeB);\n      let res;\n      if (bitA === bitB) {\n        res = 0;\n      } else if (bitA > bitB) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * parse AST name - e.g. ns|E -> { prefix: ns, localName: E }\n * @param {string} selector - type selector\n * @returns {object} - node properties\n */\nexport const parseAstName = selector => {\n  let prefix;\n  let localName;\n  if (selector && typeof selector === 'string') {\n    if (selector.indexOf('|') > -1) {\n      [prefix, localName] = selector.split('|');\n    } else {\n      prefix = '*';\n      localName = selector;\n    }\n  } else {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  return {\n    prefix,\n    localName\n  };\n};\n\n/* export */\nexport { find as findAST, generate as generateCSS } from 'css-tree';\n","/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport { generate, parse, walk } from 'css-tree';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  ATRULE, DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, HAS_COMPOUND, KEY_INPUT_BUTTON,\n  KEY_INPUT_EDIT, KEY_INPUT_TEXT, LOGIC_COMPLEX, LOGIC_COMPOUND, N_TH,\n  PSEUDO_CLASS, RULE, SCOPE, SELECTOR_LIST, TARGET_LINEAL, TARGET_SELF,\n  TEXT_NODE, TYPE_FROM, TYPE_TO\n} from './constant.js';\nconst REG_LOGIC_COMPLEX =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPLEX})`);\nconst REG_LOGIC_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPOUND})`);\nconst REG_LOGIC_HAS_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPOUND}|${HAS_COMPOUND})`);\nconst REG_WO_LOGICAL = new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH})`);\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * verify array contents\n * @param {Array} arr - array\n * @param {string} type - expected type, e.g. 'String'\n * @throws\n * @returns {Array} - verified array\n */\nexport const verifyArray = (arr, type) => {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(`Unexpected type ${getType(arr)}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(type)}`);\n  }\n  for (const item of arr) {\n    if (getType(item) !== type) {\n      throw new TypeError(`Unexpected type ${getType(item)}`);\n    }\n  }\n  return arr;\n};\n\n/**\n * resolve content document, root node and tree walker, is in shadow\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object|boolean>}\n *   - array of document, root node , tree walker, node is in shadow\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  let shadow;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      const { host, mode, ownerDocument } = node;\n      document = ownerDocument;\n      root = node;\n      shadow = host && (mode === 'close' || mode === 'open');\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let refNode = node;\n      while (refNode) {\n        const { host, mode, nodeType, parentNode } = refNode;\n        if (nodeType === DOCUMENT_FRAGMENT_NODE) {\n          shadow = host && (mode === 'close' || mode === 'open');\n          break;\n        } else if (parentNode) {\n          refNode = parentNode;\n        } else {\n          break;\n        }\n      }\n      root = refNode;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  return [\n    document,\n    root,\n    !!shadow\n  ];\n};\n\n/**\n * traverse node tree\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @param {boolean} force - traverse only to next node\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker, force = false) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!walker) {\n    return null;\n  }\n  let refNode = walker.currentNode;\n  if (refNode === node) {\n    return refNode;\n  } else if (force || refNode.contains(node)) {\n    refNode = walker.nextNode();\n    while (refNode) {\n      if (refNode === node) {\n        break;\n      }\n      refNode = walker.nextNode();\n    }\n    return refNode;\n  } else {\n    if (refNode !== walker.root) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        } else if (refNode === walker.root || refNode.contains(node)) {\n          break;\n        }\n        refNode = walker.parentNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, ownerDocument } = node;\n  const { formAssociated } = opt;\n  const window = ownerDocument.defaultView;\n  let elmConstructor;\n  const attr = node.getAttribute('is');\n  if (attr) {\n    elmConstructor =\n      isCustomElementName(attr) && window.customElements.get(attr);\n  } else {\n    elmConstructor =\n      isCustomElementName(localName) && window.customElements.get(localName);\n  }\n  if (elmConstructor) {\n    if (formAssociated) {\n      return !!elmConstructor.formAssociated;\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (typeof node.assignedNodes !== 'function') {\n    return null;\n  }\n  const nodes = node.assignedNodes();\n  if (nodes.length) {\n    let text;\n    for (const item of nodes) {\n      text = item.textContent.trim();\n      if (text) {\n        break;\n      }\n    }\n    return text;\n  }\n  return node.textContent.trim();\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { dir: dirAttr, localName, parentNode } = node;\n  const { getEmbeddingLevels } = bidiFactory();\n  if (dirAttr === 'ltr' || dirAttr === 'rtl') {\n    return dirAttr;\n  } else if (dirAttr === 'auto') {\n    let text;\n    switch (localName) {\n      case 'input': {\n        const valueKeys = [...KEY_INPUT_BUTTON, ...KEY_INPUT_TEXT, 'hidden'];\n        if (!node.type || valueKeys.includes(node.type)) {\n          text = node.value;\n        } else {\n          const ltrKeys = [\n            'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio',\n            'time'\n          ];\n          if (ltrKeys.includes(node.type)) {\n            return 'ltr';\n          }\n        }\n        break;\n      }\n      case 'slot': {\n        text = getSlottedTextContent(node);\n        break;\n      }\n      case 'textarea': {\n        text = node.value;\n        break;\n      }\n      default: {\n        const items = [].slice.call(node.childNodes);\n        for (const item of items) {\n          const {\n            dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n            textContent: itemTextContent\n          } = item;\n          if (itemNodeType === TEXT_NODE) {\n            text = itemTextContent.trim();\n          } else if (itemNodeType === ELEMENT_NODE) {\n            const keys = ['bdi', 'script', 'style', 'textarea'];\n            if (!keys.includes(itemLocalName) &&\n                (!itemDir || (itemDir !== 'ltr' && itemDir !== 'rtl'))) {\n              if (itemLocalName === 'slot') {\n                text = getSlottedTextContent(item);\n              } else {\n                text = itemTextContent.trim();\n              }\n            }\n          }\n          if (text) {\n            break;\n          }\n        }\n      }\n    }\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    } else if (parentNode) {\n      const { nodeType: parentNodeType } = parentNode;\n      if (parentNodeType === ELEMENT_NODE) {\n        return getDirectionality(parentNode);\n      }\n    }\n  } else if (localName === 'input' && node.type === 'tel') {\n    return 'ltr';\n  } else if (localName === 'bdi') {\n    const text = node.textContent.trim();\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    }\n  } else if (parentNode) {\n    if (localName === 'slot') {\n      const text = getSlottedTextContent(node);\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n    }\n    const { nodeType: parentNodeType } = parentNode;\n    if (parentNodeType === ELEMENT_NODE) {\n      return getDirectionality(parentNode);\n    }\n  }\n  return 'ltr';\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (typeof node.isContentEditable === 'boolean') {\n    return node.isContentEditable;\n  } else if (node.ownerDocument.designMode === 'on') {\n    return true;\n  } else {\n    let attr;\n    if (node.hasAttribute('contenteditable')) {\n      attr = node.getAttribute('contenteditable');\n    } else {\n      attr = 'inherit';\n    }\n    switch (attr) {\n      case '':\n      case 'true': {\n        return true;\n      }\n      case 'plaintext-only': {\n        // FIXME:\n        // @see https://github.com/w3c/editing/issues/470\n        // @see https://github.com/whatwg/html/issues/10651\n        return true;\n      }\n      case 'false': {\n        return false;\n      }\n      default: {\n        if (node?.parentNode?.nodeType === ELEMENT_NODE) {\n          return isContentEditable(node.parentNode);\n        }\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  const { display, visibility } = window.getComputedStyle(node);\n  if (display !== 'none' && visibility === 'visible') {\n    return true;\n  }\n  return false;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, type } = node;\n  switch (localName) {\n    case 'input': {\n      if (!type || KEY_INPUT_EDIT.includes(type)) {\n        return true;\n      }\n      return false;\n    }\n    case 'textarea': {\n      return true;\n    }\n    default: {\n      return isContentEditable(node);\n    }\n  }\n};\n\n/**\n * is focusable area\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusableArea = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (!node.isConnected) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  if (node instanceof window.HTMLElement) {\n    if (Number.isInteger(parseInt(node.getAttribute('tabindex')))) {\n      return true;\n    }\n    if (isContentEditable(node)) {\n      return true;\n    }\n    const { localName, parentNode } = node;\n    switch (localName) {\n      case 'a': {\n        if (node.href || node.hasAttribute('href')) {\n          return true;\n        }\n        return false;\n      }\n      case 'iframe': {\n        return true;\n      }\n      case 'input': {\n        if (node.disabled || node.hasAttribute('disabled') ||\n            node.hidden || node.hasAttribute('hidden')) {\n          return false;\n        }\n        return true;\n      }\n      case 'summary': {\n        if (parentNode.localName === 'details') {\n          let child = parentNode.firstElementChild;\n          let bool = false;\n          while (child) {\n            if (child.localName === 'summary') {\n              bool = child === node;\n              break;\n            }\n            child = child.nextElementSibling;\n          }\n          return bool;\n        }\n        return false;\n      }\n      default: {\n        const keys = ['button', 'select', 'textarea'];\n        if (keys.includes(localName) &&\n            !(node.disabled || node.hasAttribute('disabled'))) {\n          return true;\n        }\n      }\n    }\n  } else if (node instanceof window.SVGElement) {\n    if (Number.isInteger(parseInt(node.getAttributeNS(null, 'tabindex')))) {\n      const keys = [\n        'clipPath', 'defs', 'desc', 'linearGradient', 'marker', 'mask',\n        'metadata', 'pattern', 'radialGradient', 'script', 'style', 'symbol',\n        'title'\n      ];\n      const ns = 'http://www.w3.org/2000/svg';\n      let bool;\n      let refNode = node;\n      while (refNode.namespaceURI === ns) {\n        bool = keys.includes(refNode.localName);\n        if (bool) {\n          break;\n        }\n        if (refNode?.parentNode?.namespaceURI === ns) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n      if (bool) {\n        return false;\n      }\n      return true;\n    }\n    if (node.localName === 'a' &&\n        (node.href || node.hasAttributeNS(null, 'href'))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * is focusable\n * NOTE: not applied, need fix in jsdom itself\n * @see https://github.com/whatwg/html/pull/8392\n * @see https://phabricator.services.mozilla.com/D156219\n * @see https://github.com/jsdom/jsdom/issues/3029\n * @see https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  let refNode = node;\n  let res = true;\n  while (refNode) {\n    if (refNode.disabled || refNode.hasAttribute('disabled')) {\n      res = false;\n      break;\n    }\n    if (refNode.hidden || refNode.hasAttribute('hidden')) {\n      res = false;\n    }\n    const {\n      contentVisibility, display, visibility\n    } = window.getComputedStyle(refNode);\n    if (display === 'none' || visibility !== 'visible' ||\n        (contentVisibility === 'hidden' && refNode !== node)) {\n      res = false;\n    } else {\n      res = true;\n    }\n    if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n      refNode = refNode.parentNode;\n    } else {\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!ns || node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { attributes } = node;\n  let res;\n  for (const attr of attributes) {\n    const { name, namespaceURI, prefix, value } = attr;\n    if (name === `xmlns:${ns}`) {\n      res = value;\n    } else if (prefix === ns) {\n      res = namespaceURI;\n    }\n    if (res) {\n      break;\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  if (!ns || typeof ns !== 'string' || node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (node.lookupNamespaceURI(ns)) {\n    return true;\n  }\n  const root = node.ownerDocument.documentElement;\n  let parent = node;\n  let res;\n  while (parent) {\n    res = getNamespaceURI(ns, parent);\n    if (res || parent === root) {\n      break;\n    }\n    parent = parent.parentNode;\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  if (nodeA.nodeType !== ELEMENT_NODE || nodeB.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const posBit = nodeB.compareDocumentPosition(nodeA);\n  const res = posBit & DOCUMENT_POSITION_PRECEDING ||\n              posBit & DOCUMENT_POSITION_CONTAINS;\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * concat array of nested selectors into equivalent selector\n * @param {Array.<Array.<string>>} selectors - [parents, children, ...]\n * @returns {string} - selector\n */\nexport const concatNestedSelectors = selectors => {\n  if (!Array.isArray(selectors)) {\n    throw new TypeError(`Unexpected type ${getType(selectors)}`);\n  }\n  let selector = '';\n  if (selectors.length) {\n    selectors = selectors.reverse();\n    let child = verifyArray(selectors.shift(), 'String');\n    if (child.length === 1) {\n      [child] = child;\n    }\n    while (selectors.length) {\n      const parentArr = verifyArray(selectors.shift(), 'String');\n      if (!parentArr.length) {\n        continue;\n      }\n      let parent;\n      if (parentArr.length === 1) {\n        [parent] = parentArr;\n        if (!/^[>~+]/.test(parent) && /[\\s>~+]/.test(parent)) {\n          parent = `:is(${parent})`;\n        }\n      } else {\n        parent = `:is(${parentArr.join(', ')})`;\n      }\n      if (selector.includes('\\x26')) {\n        selector = selector.replace(/\\x26/g, parent);\n      }\n      if (Array.isArray(child)) {\n        const items = [];\n        for (let item of child) {\n          if (item.includes('\\x26')) {\n            if (/^[>~+]/.test(item)) {\n              item = `${parent} ${item.replace(/\\x26/g, parent)} ${selector}`;\n            } else {\n              item = `${item.replace(/\\x26/g, parent)} ${selector}`;\n            }\n          } else {\n            item = `${parent} ${item} ${selector}`;\n          }\n          items.push(item.trim());\n        }\n        selector = items.join(', ');\n      } else if (selectors.length) {\n        selector = `${child} ${selector}`;\n      } else {\n        if (child.includes('\\x26')) {\n          if (/^[>~+]/.test(child)) {\n            selector =\n              `${parent} ${child.replace(/\\x26/g, parent)} ${selector}`;\n          } else {\n            selector = `${child.replace(/\\x26/g, parent)} ${selector}`;\n          }\n        } else {\n          selector = `${parent} ${child} ${selector}`;\n        }\n      }\n      selector = selector.trim();\n      if (selectors.length) {\n        child = parentArr.length > 1 ? parentArr : parent;\n      } else {\n        break;\n      }\n    }\n    selector = selector.replace(/\\x26/g, ':scope').trim();\n  }\n  return selector;\n};\n\n/**\n * extract nested selectors from CSSRule.cssText\n * @param {string} css - CSSRule.cssText\n * @returns {Array.<Array.<string>>} - array of nested selectors\n */\nexport const extractNestedSelectors = css => {\n  const ast = parse(css, {\n    context: 'rule'\n  });\n  const selectors = [];\n  let isScoped = false;\n  walk(ast, {\n    enter: node => {\n      switch (node.type) {\n        case ATRULE: {\n          if (node.name === 'scope') {\n            isScoped = true;\n          }\n          break;\n        }\n        case SCOPE: {\n          const { children, type } = node.root;\n          const arr = [];\n          if (type === SELECTOR_LIST) {\n            for (const child of children) {\n              const selector = generate(child);\n              arr.push(selector);\n            }\n            selectors.push(arr);\n          }\n          break;\n        }\n        case RULE: {\n          const { children, type } = node.prelude;\n          const arr = [];\n          if (type === SELECTOR_LIST) {\n            let hasAmp = false;\n            for (const child of children) {\n              const selector = generate(child);\n              if (isScoped && !hasAmp) {\n                hasAmp = /\\x26/.test(selector);\n              }\n              arr.push(selector);\n            }\n            if (isScoped) {\n              if (hasAmp) {\n                selectors.push(arr);\n              /* FIXME:\n              } else {\n                selectors = arr;\n                isScoped = false;\n              */\n              }\n            } else {\n              selectors.push(arr);\n            }\n          }\n        }\n      }\n    },\n    leave: node => {\n      if (node.type === ATRULE) {\n        if (node.name === 'scope') {\n          isScoped = false;\n        }\n      }\n    }\n  });\n  return selectors;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  const { complex, compound, descend, simple, target } = opt;\n  // exclude simple selector and compound selector\n  if (simple || compound) {\n    return false;\n  }\n  // exclude missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // exclude namespaced selectors, escaped selectors, pseudo-element selectors,\n  // selectors containing non-ASCII or control character other than whitespace,\n  // attribute selectors with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // include pseudo-classes that are known to work correctly\n  if (selector.includes(':')) {\n    if (descend) {\n      return false;\n    } else if ((target === TARGET_SELF || target === TARGET_LINEAL) &&\n               /:has\\(/.test(selector)) {\n      return !REG_LOGIC_HAS_COMPOUND.test(selector);\n    } else if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        return !REG_LOGIC_COMPLEX.test(selector);\n      } else {\n        return !REG_LOGIC_COMPOUND.test(selector);\n      }\n    } else {\n      return !REG_WO_LOGICAL.test(selector);\n    }\n  }\n  return true;\n};\n","/**\n * constant.js\n */\n\n/* string */\nexport const ATRULE = 'Atrule';\nexport const ATTR_SELECTOR = 'AttributeSelector';\nexport const CLASS_SELECTOR = 'ClassSelector';\nexport const COMBINATOR = 'Combinator';\nexport const IDENT = 'Identifier';\nexport const ID_SELECTOR = 'IdSelector';\nexport const NOT_SUPPORTED_ERR = 'NotSupportedError';\nexport const NTH = 'Nth';\nexport const OPERATOR = 'Operator';\nexport const PS_CLASS_SELECTOR = 'PseudoClassSelector';\nexport const PS_ELEMENT_SELECTOR = 'PseudoElementSelector';\nexport const RULE = 'Rule';\nexport const SCOPE = 'Scope';\nexport const SELECTOR = 'Selector';\nexport const SELECTOR_LIST = 'SelectorList';\nexport const STRING = 'String';\nexport const SYNTAX_ERR = 'SyntaxError';\nexport const TARGET_ALL = 'all';\nexport const TARGET_FIRST = 'first';\nexport const TARGET_LINEAL = 'lineal';\nexport const TARGET_SELF = 'self';\nexport const TYPE_SELECTOR = 'TypeSelector';\n\n/* numeric */\nexport const BIT_01 = 1;\nexport const BIT_02 = 2;\nexport const BIT_04 = 4;\nexport const BIT_08 = 8;\nexport const BIT_16 = 0x10;\nexport const BIT_32 = 0x20;\nexport const BIT_FFFF = 0xFFFF;\nexport const DUO = 2;\nexport const HEX = 16;\nexport const HYPHEN = 0x2D;\nexport const TYPE_FROM = 8;\nexport const TYPE_TO = -1;\n\n/* Node */\nexport const ELEMENT_NODE = 1;\nexport const TEXT_NODE = 3;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\nexport const DOCUMENT_POSITION_PRECEDING = 2;\nexport const DOCUMENT_POSITION_CONTAINS = 8;\nexport const DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n\n/* NodeFilter */\nexport const SHOW_ALL = 0xFFFFFFFF;\nexport const SHOW_DOCUMENT = 0x100;\nexport const SHOW_DOCUMENT_FRAGMENT = 0x400;\nexport const SHOW_ELEMENT = 1;\nexport const WALKER_FILTER = 0x501;\n\n/* selectors */\nexport const ALPHA_NUM = '[A-Z\\\\d]+';\nexport const CHILD_IDX = '(?:first|last|only)-(?:child|of-type)';\nexport const DIGIT = '(?:0|[1-9]\\\\d*)';\nexport const LANG_PART = `(?:-${ALPHA_NUM})*`;\nexport const PSEUDO_CLASS = `(?:any-)?link|${CHILD_IDX}|checked|empty|indeterminate|read-(?:only|write)|root|target`;\nexport const ANB =\n  `[+-]?(?:${DIGIT}n?|n)|(?:[+-]?${DIGIT})?n\\\\s*[+-]\\\\s*${DIGIT}`;\n// N_TH: excludes An+B with selector list, e.g. :nth-child(2n+1 of .foo)\nexport const N_TH =\n  `nth-(?:last-)?(?:child|of-type)\\\\(\\\\s*(?:even|odd|${ANB})\\\\s*\\\\)`;\n// SUB_TYPE: attr, id, class, pseudo-class, note that [foo|=bar] is excluded\nexport const SUB_TYPE = '\\\\[[^|\\\\]]+\\\\]|[#.:][\\\\w-]+';\nexport const SUB_TYPE_WO_PSEUDO = '\\\\[[^|\\\\]]+\\\\]|[#.][\\\\w-]+';\n// TAG_TYPE: *, tag\nexport const TAG_ID_CLASS = '(?:[A-Za-z][\\\\w-]*|[#.][\\\\w-]+)';\nexport const TAG_TYPE = '\\\\*|[A-Za-z][\\\\w-]*';\nexport const TAG_TYPE_I = '\\\\*|[A-Z][\\\\w-]*';\nexport const COMPOUND = `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE})+)`;\nexport const COMPOUND_WO_PSEUDO =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE_WO_PSEUDO})+)`;\nexport const COMBO = '\\\\s?[\\\\s>~+]\\\\s?';\nexport const COMPLEX = `${COMPOUND}(?:${COMBO}${COMPOUND})*`;\nexport const DESCEND = '\\\\s?[\\\\s>]\\\\s?';\nexport const NESTED_LOGIC_A =\n  `:is\\\\(\\\\s*${COMPOUND}(?:\\\\s*,\\\\s*${COMPOUND})*\\\\s*\\\\)`;\nexport const NESTED_LOGIC_B =\n  `:is\\\\(\\\\s*${COMPLEX}(?:\\\\s*,\\\\s*${COMPLEX})*\\\\s*\\\\)`;\nexport const COMPOUND_A =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE}|${NESTED_LOGIC_A})+)`;\nexport const COMPOUND_B =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE}|${NESTED_LOGIC_B})+)`;\nexport const COMPOUND_I =\n  `(?:${TAG_TYPE_I}|(?:${TAG_TYPE_I})?(?:${SUB_TYPE})+)`;\nexport const COMPLEX_L = `${COMPOUND_B}(?:${COMBO}${COMPOUND_B})*`;\nexport const LOGIC_COMPLEX =\n  `(?:is|not)\\\\(\\\\s*${COMPLEX_L}(?:\\\\s*,\\\\s*${COMPLEX_L})*\\\\s*\\\\)`;\nexport const LOGIC_COMPOUND =\n  `(?:is|not)\\\\(\\\\s*${COMPOUND_A}(?:\\\\s*,\\\\s*${COMPOUND_A})*\\\\s*\\\\)`;\nexport const HAS_COMPOUND = `has\\\\([\\\\s>~+]?\\\\s*${COMPOUND_WO_PSEUDO}\\\\s*\\\\)`;\n\n/* array */\nexport const KEY_FORM_FOCUS =\n  Object.freeze(['button', 'input', 'select', 'textarea']);\nexport const KEY_INPUT_BUTTON = Object.freeze(['button', 'reset', 'submit']);\nexport const KEY_INPUT_DATE =\n  Object.freeze(['date', 'datetime-local', 'month', 'time', 'week']);\nexport const KEY_INPUT_TEXT =\n  Object.freeze(['email', 'password', 'search', 'tel', 'text', 'url']);\nexport const KEY_INPUT_EDIT =\n  Object.freeze([...KEY_INPUT_DATE, ...KEY_INPUT_TEXT, 'number']);\nexport const KEY_INPUT_LTR = Object.freeze([\n  'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio', 'time'\n]);\nexport const KEY_LOGICAL = Object.freeze(['has', 'is', 'not', 'where']);\nexport const KEY_MODIFIER = Object.freeze([\n  'Alt', 'AltGraph', 'CapsLock', 'Control', 'Fn', 'FnLock', 'Hyper', 'Meta',\n  'NumLock', 'ScrollLock', 'Shift', 'Super', 'Symbol', 'SymbolLock'\n]);\nexport const KEY_PS_STATE = Object.freeze([\n  'enabled', 'disabled', 'valid', 'invalid', 'in-range', 'out-of-range',\n  'checked', 'indeterminate', 'read-only', 'read-write', 'open', 'closed',\n  'placeholder-shown'\n]);\nexport const KEY_SHADOW_HOST = Object.freeze(['host', 'host-context']);\n","/**\n * matcher.js\n */\n\n/* import */\nimport { generateCSS, parseAstName, unescapeSelector } from './parser.js';\nimport { getDirectionality, getType, isNamespaceDeclared } from './utility.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, ELEMENT_NODE, IDENT, LANG_PART, NOT_SUPPORTED_ERR,\n  PS_ELEMENT_SELECTOR, STRING, SYNTAX_ERR\n} from './constant.js';\n\n/**\n * match pseudo-element selector\n * @param {string} astName - AST name\n * @param {string} astType - AST type\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive unknown pseudo-element\n * @param {boolean} [opt.warn] - warn unsupported pseudo-element\n * @throws {DOMException}\n * @returns {void}\n */\nexport const matchPseudoElementSelector = (astName, astType, opt = {}) => {\n  const { forgive, warn } = opt;\n  if (astType === PS_ELEMENT_SELECTOR) {\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'placeholder':\n      case 'selection':\n      case 'target-text': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      case 'part':\n      case 'slotted': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}()`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          throw new DOMException(`Unknown pseudo-element ::${astName}`,\n            SYNTAX_ERR);\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`Unexpected ast type ${getType(astType)}`);\n  }\n};\n\n/**\n * match directionality pseudo-class - :dir()\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchDirectionPseudoClass = (ast, node) => {\n  const { name } = ast;\n  if (!name) {\n    let type;\n    if (name === '') {\n      type = '(empty String)';\n    } else {\n      type = getType(name);\n    }\n    throw new TypeError(`Unexpected ast type ${type}`);\n  }\n  const dir = getDirectionality(node);\n  return name === dir;\n};\n\n/**\n * match language pseudo-class - :lang()\n * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchLanguagePseudoClass = (ast, node) => {\n  const { name, type, value } = ast;\n  let astName;\n  if (type === STRING && value) {\n    astName = value;\n  } else if (type === IDENT && name) {\n    astName = unescapeSelector(name);\n  }\n  if (astName === '*') {\n    if (node.hasAttribute('lang')) {\n      if (node.getAttribute('lang')) {\n        return true;\n      }\n    } else {\n      let parent = node.parentNode;\n      let res;\n      while (parent) {\n        if (parent.nodeType === ELEMENT_NODE) {\n          if (parent.hasAttribute('lang')) {\n            if (parent.getAttribute('lang')) {\n              res = true;\n            }\n            break;\n          }\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      return !!res;\n    }\n  } else if (astName) {\n    const reg = new RegExp(`^(?:\\\\*-)?${ALPHA_NUM}${LANG_PART}$`, 'i');\n    if (reg.test(astName)) {\n      let regExtendedLang;\n      if (astName.indexOf('-') > -1) {\n        const [langMain, langSub, ...langRest] = astName.split('-');\n        let extendedMain;\n        if (langMain === '*') {\n          extendedMain = `${ALPHA_NUM}${LANG_PART}`;\n        } else {\n          extendedMain = `${langMain}${LANG_PART}`;\n        }\n        const extendedSub = `-${langSub}${LANG_PART}`;\n        const len = langRest.length;\n        let extendedRest = '';\n        if (len) {\n          for (let i = 0; i < len; i++) {\n            extendedRest += `-${langRest[i]}${LANG_PART}`;\n          }\n        }\n        regExtendedLang =\n          new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n      } else {\n        regExtendedLang = new RegExp(`^${astName}${LANG_PART}$`, 'i');\n      }\n      if (node.hasAttribute('lang')) {\n        return regExtendedLang.test(node.getAttribute('lang'));\n      } else {\n        let parent = node.parentNode;\n        let res;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              res = regExtendedLang.test(parent.getAttribute('lang'));\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n        return !!res;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * match attribute selector\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchAttributeSelector = (ast, node) => {\n  const {\n    flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n  } = ast;\n  if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n    const css = generateCSS(ast);\n    throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n  }\n  const { attributes } = node;\n  if (attributes?.length) {\n    const contentType = node.ownerDocument.contentType;\n    let caseInsensitive;\n    if (contentType === 'text/html') {\n      if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n        caseInsensitive = false;\n      } else {\n        caseInsensitive = true;\n      }\n    } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n      caseInsensitive = true;\n    } else {\n      caseInsensitive = false;\n    }\n    let astAttrName = unescapeSelector(astName.name);\n    if (caseInsensitive) {\n      astAttrName = astAttrName.toLowerCase();\n    }\n    const attrValues = new Set();\n    // namespaced\n    if (astAttrName.indexOf('|') > -1) {\n      const {\n        prefix: astPrefix, localName: astLocalName\n      } = parseAstName(astAttrName);\n      for (const item of attributes) {\n        let { name: itemName, value: itemValue } = item;\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        switch (astPrefix) {\n          case '': {\n            if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          case '*': {\n            if (itemName.indexOf(':') > -1) {\n              if (itemName.endsWith(`:${astLocalName}`)) {\n                attrValues.add(itemValue);\n              }\n            } else if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          default: {\n            if (itemName.indexOf(':') > -1) {\n              const [itemPrefix, itemLocalName] = itemName.split(':');\n              // ignore xml:lang\n              if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n                continue;\n              } else if (astPrefix === itemPrefix &&\n                           astLocalName === itemLocalName) {\n                const namespaceDeclared =\n                    isNamespaceDeclared(astPrefix, node);\n                if (namespaceDeclared) {\n                  attrValues.add(itemValue);\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      for (let { name: itemName, value: itemValue } of attributes) {\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        if (itemName.indexOf(':') > -1) {\n          const [itemPrefix, itemLocalName] = itemName.split(':');\n          // ignore xml:lang\n          if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n            continue;\n          } else if (astAttrName === itemLocalName) {\n            attrValues.add(itemValue);\n          }\n        } else if (astAttrName === itemName) {\n          attrValues.add(itemValue);\n        }\n      }\n    }\n    if (attrValues.size) {\n      const { name: astIdentValue, value: astStringValue } = astValue ?? {};\n      let attrValue;\n      if (astIdentValue) {\n        if (caseInsensitive) {\n          attrValue = astIdentValue.toLowerCase();\n        } else {\n          attrValue = astIdentValue;\n        }\n      } else if (astStringValue) {\n        if (caseInsensitive) {\n          attrValue = astStringValue.toLowerCase();\n        } else {\n          attrValue = astStringValue;\n        }\n      } else if (astStringValue === '') {\n        attrValue = astStringValue;\n      }\n      switch (astMatcher) {\n        case '=': {\n          return typeof attrValue === 'string' && attrValues.has(attrValue);\n        }\n        case '~=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let res;\n            for (const value of attrValues) {\n              const item = new Set(value.split(/\\s+/));\n              if (item.has(attrValue)) {\n                res = true;\n                break;\n              }\n            }\n            return !!res;\n          }\n          return false;\n        }\n        case '|=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '^=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.startsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '$=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.endsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '*=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.includes(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case null:\n        default: {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * match type selector\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive undeclared namespace\n * @returns {boolean} - result\n */\nexport const matchTypeSelector = (ast, node, opt = {}) => {\n  const astName = unescapeSelector(ast.name);\n  const { localName, namespaceURI, prefix } = node;\n  const { forgive } = opt;\n  let {\n    prefix: astPrefix, localName: astLocalName\n  } = parseAstName(astName, node);\n  if (node.ownerDocument.contentType === 'text/html' &&\n      /[A-Z][\\\\w-]*/i.test(localName)) {\n    astPrefix = astPrefix.toLowerCase();\n    astLocalName = astLocalName.toLowerCase();\n  }\n  let nodePrefix;\n  let nodeLocalName;\n  // just in case that the namespaced content is parsed as text/html\n  if (localName.indexOf(':') > -1) {\n    [nodePrefix, nodeLocalName] = localName.split(':');\n  } else {\n    nodePrefix = prefix || '';\n    nodeLocalName = localName;\n  }\n  switch (astPrefix) {\n    case '': {\n      if (!nodePrefix && !namespaceURI &&\n          (astLocalName === '*' || astLocalName === nodeLocalName)) {\n        return true;\n      }\n      return false;\n    }\n    case '*': {\n      if (astLocalName === '*' || astLocalName === nodeLocalName) {\n        return true;\n      }\n      return false;\n    }\n    default: {\n      const astNS = node.lookupNamespaceURI(astPrefix);\n      const nodeNS = node.lookupNamespaceURI(nodePrefix);\n      if (astNS === nodeNS && astPrefix === nodePrefix) {\n        if (astLocalName === '*' || astLocalName === nodeLocalName) {\n          return true;\n        }\n        return false;\n      } else if (!forgive && !astNS) {\n        throw new DOMException(`Undeclared namespace ${astPrefix}`, SYNTAX_ERR);\n      }\n      return false;\n    }\n  }\n};\n","/**\n * finder.js\n */\n\n/* import */\nimport {\n  matchAttributeSelector, matchDirectionPseudoClass, matchLanguagePseudoClass,\n  matchPseudoElementSelector, matchTypeSelector\n} from './matcher.js';\nimport {\n  findAST, generateCSS, parseSelector, sortAST, unescapeSelector, walkAST\n} from './parser.js';\nimport {\n  isContentEditable, isCustomElement, isFocusVisible, isFocusableArea,\n  isVisible, resolveContent, sortNodes, traverseNode\n} from './utility.js';\n\n/* constants */\nimport {\n  ATTR_SELECTOR, BIT_01, CLASS_SELECTOR, COMBINATOR, DOCUMENT_FRAGMENT_NODE,\n  ELEMENT_NODE, ID_SELECTOR, KEY_FORM_FOCUS, KEY_INPUT_DATE, KEY_INPUT_EDIT,\n  KEY_INPUT_TEXT, KEY_LOGICAL, KEY_MODIFIER, NOT_SUPPORTED_ERR,\n  PS_CLASS_SELECTOR, PS_ELEMENT_SELECTOR, SHOW_ALL, SYNTAX_ERR, TARGET_ALL,\n  TARGET_FIRST, TARGET_LINEAL, TARGET_SELF, TEXT_NODE, TYPE_SELECTOR,\n  WALKER_FILTER\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\n\n/**\n * Finder\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: Array<Ast | undefined>\n * #nodes: Array<Nodes>\n * Ast: {\n *   branch: Array<Branch | undefined>,\n *   dir: string | null,\n *   filtered: boolean,\n *   find: boolean\n * }\n * Branch: Array<Twig>\n * Twig: {\n *   combo: Leaf | null,\n *   leaves: Array<Leaf>\n * }\n * Leaf: {\n *   children: Array<Leaf | undefined> | null,\n *   loc: null,\n *   type: string\n * }\n * Nodes: Array<HTMLElement | undefined>\n */\nexport class Finder {\n  /* private fields */\n  #ast;\n  #astCache;\n  #descendant;\n  #document;\n  #documentCache;\n  #event;\n  #focus;\n  #invalidate;\n  #invalidateResults;\n  #lastFocusVisible;\n  #node;\n  #nodes;\n  #noexcept;\n  #qswalker;\n  #results;\n  #root;\n  #selector;\n  #shadow;\n  #verifyShadowHost;\n  #walkers;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   * @param {object} window - window\n   */\n  constructor(window) {\n    this.#window = window;\n    this.#astCache = new WeakMap();\n    this.#documentCache = new WeakMap();\n    this.#invalidateResults = new WeakMap();\n    this.#results = new WeakMap();\n    this.#event = null;\n    this.#focus = null;\n    this.#lastFocusVisible = null;\n    this._registerEventListeners();\n  }\n\n  /**\n   * handle error\n   * @param {Error} e - Error\n   * @param {object} opt - options\n   * @throws Error\n   * @returns {void}\n   */\n  onError(e, opt) {\n    const noexcept = opt?.noexcept ?? this.#noexcept;\n    if (!noexcept) {\n      if (e instanceof DOMException ||\n          e instanceof this.#window.DOMException) {\n        if (e.name === NOT_SUPPORTED_ERR) {\n          if (this.#warn) {\n            console.warn(e.message);\n          }\n        } else {\n          throw new this.#window.DOMException(e.message, e.name);\n        }\n      } else if (e.name in this.#window) {\n        throw new this.#window[e.name](e.message);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * setup finder\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {object} [opt.event] - MouseEvent, KeyboardEvent\n   * @param {boolean} [opt.noexcept] - no exception\n   * @param {boolean} [opt.warn] - console warn\n   * @returns {object} - finder\n   */\n  setup(selector, node, opt = {}) {\n    const { noexcept, warn } = opt;\n    this.#noexcept = !!noexcept;\n    this.#warn = !!warn;\n    this.#node = node;\n    [\n      this.#document,\n      this.#root,\n      this.#shadow\n    ] = resolveContent(node);\n    this.#selector = selector;\n    [\n      this.#ast,\n      this.#nodes\n    ] = this._correspond(selector);\n    this.#invalidateResults = new WeakMap();\n    this.#walkers = new WeakMap();\n    this.#verifyShadowHost = null;\n    return this;\n  }\n\n  /**\n   * register event listeners\n   * @private\n   * @returns {Array.<void>} - results\n   */\n  _registerEventListeners() {\n    const opt = {\n      capture: true,\n      passive: true\n    };\n    const func = [];\n    const focusKeys = ['focus', 'focusin'];\n    for (const key of focusKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#focus = evt;\n      }, opt));\n    }\n    const keyboardKeys = ['keydown', 'keyup'];\n    for (const key of keyboardKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        const { key } = evt;\n        if (!KEY_MODIFIER.includes(key)) {\n          this.#event = evt;\n        }\n      }, opt));\n    }\n    const mouseKeys = [\n      'mouseover', 'mousedown', 'mouseup', 'click', 'mouseout'\n    ];\n    for (const key of mouseKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#event = evt;\n      }, opt));\n    }\n    return func;\n  }\n\n  /**\n   * correspond ast and nodes\n   * @private\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of ast and nodes\n   */\n  _correspond(selector) {\n    const nodes = [];\n    this.#descendant = false;\n    this.#invalidate = false;\n    let ast;\n    if (this.#documentCache.has(this.#document)) {\n      const cachedItem = this.#documentCache.get(this.#document);\n      if (cachedItem && cachedItem.has(`${selector}`)) {\n        const item = cachedItem.get(`${selector}`);\n        ast = item.ast;\n        this.#descendant = item.descendant;\n        this.#invalidate = item.invalidate;\n      }\n    }\n    if (ast) {\n      const l = ast.length;\n      for (let i = 0; i < l; i++) {\n        ast[i].dir = null;\n        ast[i].filtered = false;\n        ast[i].find = false;\n        nodes[i] = [];\n      }\n    } else {\n      let cssAst;\n      try {\n        cssAst = parseSelector(selector);\n      } catch (e) {\n        this.onError(e);\n      }\n      const { branches, info } = walkAST(cssAst);\n      const {\n        hasHasPseudoFunc, hasLogicalPseudoFunc, hasNthChildOfSelector,\n        hasStatePseudoClass\n      } = info;\n      let invalidate = hasHasPseudoFunc || hasStatePseudoClass ||\n        !!(hasLogicalPseudoFunc && hasNthChildOfSelector);\n      let descendant = false;\n      let i = 0;\n      ast = [];\n      for (const [...items] of branches) {\n        const branch = [];\n        let item = items.shift();\n        if (item && item.type !== COMBINATOR) {\n          const leaves = new Set();\n          while (item) {\n            let itemName = item.name;\n            if (item.type === COMBINATOR) {\n              const [nextItem] = items;\n              if (nextItem.type === COMBINATOR) {\n                throw new DOMException(`Invalid selector ${selector}`,\n                  SYNTAX_ERR);\n              }\n              if (itemName === '+' || itemName === '~') {\n                invalidate = true;\n              } else {\n                descendant = true;\n              }\n              branch.push({\n                combo: item,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n            } else if (item) {\n              if (itemName && typeof itemName === 'string') {\n                itemName = unescapeSelector(itemName);\n                if (typeof itemName === 'string' && itemName !== item.name) {\n                  item.name = itemName;\n                }\n                if (/[|:]/.test(itemName)) {\n                  item.namespace = true;\n                }\n              }\n              leaves.add(item);\n            }\n            if (items.length) {\n              item = items.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n              break;\n            }\n          }\n        }\n        ast.push({\n          branch,\n          dir: null,\n          filtered: false,\n          find: false\n        });\n        nodes[i] = [];\n        i++;\n      }\n      let cachedItem;\n      if (this.#documentCache.has(this.#document)) {\n        cachedItem = this.#documentCache.get(this.#document);\n      } else {\n        cachedItem = new Map();\n      }\n      cachedItem.set(`${selector}`, {\n        ast,\n        descendant,\n        invalidate\n      });\n      this.#documentCache.set(this.#document, cachedItem);\n      this.#descendant = descendant;\n      this.#invalidate = invalidate;\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * create tree walker\n   * @private\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.force] - force new tree walker\n   * @param {number} [opt.whatToShow] - NodeFilter whatToShow\n   * @returns {object} - tree walker\n   */\n  _createTreeWalker(node, opt = {}) {\n    const { force = false, whatToShow = WALKER_FILTER } = opt;\n    let walker;\n    if (force) {\n      walker = this.#document.createTreeWalker(node, whatToShow);\n    } else if (this.#walkers.has(node)) {\n      walker = this.#walkers.get(node);\n    } else {\n      walker = this.#document.createTreeWalker(node, whatToShow);\n      this.#walkers.set(node, walker);\n    }\n    return walker;\n  }\n\n  /**\n   * prepare querySelector walker\n   * @private\n   * @returns {object} - tree walker\n   */\n  _prepareQuerySelectorWalker() {\n    this.#qswalker = this._createTreeWalker(this.#node);\n    return this.#qswalker;\n  }\n\n  /**\n   * collect nth child\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node, opt) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    const matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#astCache.has(selector)) {\n        selectorBranches = this.#astCache.get(selector);\n      } else {\n        const { branches } = walkAST(selector);\n        selectorBranches = branches;\n        if (!this.#invalidate) {\n          this.#astCache.set(selector, selectorBranches);\n        }\n      }\n      const { branches } = walkAST(selector);\n      selectorBranches = branches;\n    }\n    if (parentNode) {\n      const walker = this._createTreeWalker(parentNode, {\n        force: true\n      });\n      let refNode = walker.firstChild();\n      const selectorNodes = new Set();\n      let l = 0;\n      if (selectorBranches) {\n        while (refNode) {\n          if (isVisible(refNode)) {\n            let bool;\n            for (const leaves of selectorBranches) {\n              bool = this._matchLeaves(leaves, refNode, opt);\n              if (!bool) {\n                break;\n              }\n            }\n            if (bool) {\n              selectorNodes.add(refNode);\n            }\n          }\n          l++;\n          refNode = walker.nextSibling();\n        }\n      } else {\n        while (refNode) {\n          l++;\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, namespaceURI, parentNode, prefix } = node;\n    const matched = new Set();\n    if (parentNode) {\n      const walker = this._createTreeWalker(parentNode);\n      let refNode = traverseNode(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = 0;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName, opt) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const anbMap = new Map();\n    if (nthIdentName) {\n      if (nthIdentName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (nthIdentName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    if (nthName === 'nth-child' || nthName === 'nth-last-child') {\n      if (selector) {\n        anbMap.set('selector', selector);\n      }\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthChild(anb, node, opt);\n      return nodes;\n    } else if (nthName === 'nth-of-type' || nthName === 'nth-last-of-type') {\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthOfType(anb, node);\n      return nodes;\n    }\n    return new Set();\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @private\n   * @param {Array.<object>} astLeaves - AST leaves\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(astLeaves, node, opt) {\n    if (Array.isArray(astLeaves) && astLeaves.length) {\n      const leaves = [...astLeaves];\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      opt.dir = DIR_NEXT;\n      const nodes = this._matchCombinator(twig, node, opt);\n      if (nodes.size) {\n        if (leaves.length) {\n          let bool = false;\n          for (const nextNode of nodes) {\n            bool = this._matchHasPseudoFunc(leaves, nextNode, opt);\n            if (bool) {\n              break;\n            }\n          }\n          return bool;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @private\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node, opt) {\n    const { astName, branches, twigBranches } = astData;\n    const isShadowRoot = (opt.isShadowRoot || this.#shadow) &&\n      node.nodeType === DOCUMENT_FRAGMENT_NODE;\n    if (astName === 'has') {\n      let bool;\n      for (const leaves of branches) {\n        bool = this._matchHasPseudoFunc(leaves, node, opt);\n        if (bool) {\n          break;\n        }\n      }\n      if (bool) {\n        if (isShadowRoot) {\n          if (this.#verifyShadowHost) {\n            return node;\n          }\n        } else {\n          return node;\n        }\n      }\n    } else {\n      // check for invalid shadow root\n      if (isShadowRoot) {\n        let invalid;\n        for (const branch of branches) {\n          if (branch.length > 1) {\n            invalid = true;\n            break;\n          } else if (astName === 'not') {\n            const [{ type: childAstType }] = branch;\n            if (childAstType !== PS_CLASS_SELECTOR) {\n              invalid = true;\n              break;\n            }\n          }\n        }\n        if (invalid) {\n          return null;\n        }\n      }\n      opt.forgive = astName === 'is' || astName === 'where';\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, opt);\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            opt.dir = DIR_PREV;\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, opt);\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (bool) {\n          return null;\n        }\n        return node;\n      } else if (bool) {\n        return node;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @private\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt) {\n    const { children: astChildren, name: astName } = ast;\n    const { localName, parentNode } = node;\n    const {\n      forgive,\n      warn = this.#warn\n    } = opt;\n    const matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (Array.isArray(astChildren) && KEY_LOGICAL.includes(astName)) {\n      if (!astChildren.length && astName !== 'is' && astName !== 'where') {\n        const css = generateCSS(ast);\n        throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n      }\n      let astData;\n      if (this.#astCache.has(ast)) {\n        astData = this.#astCache.get(ast);\n      } else {\n        const { branches } = walkAST(ast);\n        if (astName === 'has') {\n          // check for nested :has()\n          let forgiven;\n          for (const child of astChildren) {\n            const item = findAST(child, leaf => {\n              if (KEY_LOGICAL.includes(leaf.name) &&\n                  findAST(leaf, nestedLeaf => nestedLeaf.name === 'has')) {\n                return leaf;\n              }\n              return null;\n            });\n            if (item) {\n              const itemName = item.name;\n              if (itemName === 'is' || itemName === 'where') {\n                forgiven = true;\n                break;\n              } else {\n                const css = generateCSS(ast);\n                throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n              }\n            }\n          }\n          if (forgiven) {\n            return matched;\n          }\n          astData = {\n            astName,\n            branches\n          };\n        } else {\n          const twigBranches = [];\n          for (const [...leaves] of branches) {\n            const branch = [];\n            const leavesSet = new Set();\n            let item = leaves.shift();\n            while (item) {\n              if (item.type === COMBINATOR) {\n                branch.push({\n                  combo: item,\n                  leaves: [...leavesSet]\n                });\n                leavesSet.clear();\n              } else if (item) {\n                leavesSet.add(item);\n              }\n              if (leaves.length) {\n                item = leaves.shift();\n              } else {\n                branch.push({\n                  combo: null,\n                  leaves: [...leavesSet]\n                });\n                leavesSet.clear();\n                break;\n              }\n            }\n            twigBranches.push(branch);\n          }\n          astData = {\n            astName,\n            branches,\n            twigBranches\n          };\n          if (!this.#invalidate) {\n            this.#astCache.set(ast, astData);\n          }\n        }\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node, opt);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        if (astChildren.length !== 1) {\n          const css = generateCSS(ast);\n          throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n        }\n        const [branch] = astChildren;\n        const nodes = this._matchAnPlusB(branch, node, astName, opt);\n        return nodes;\n      } else {\n        switch (astName) {\n          // :dir()\n          case 'dir': {\n            if (astChildren.length !== 1) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            const [astChild] = astChildren;\n            const res = matchDirectionPseudoClass(astChild, node);\n            if (res) {\n              matched.add(node);\n            }\n            break;\n          }\n          // :lang()\n          case 'lang': {\n            if (!astChildren.length) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            let bool;\n            for (const astChild of astChildren) {\n              bool = matchLanguagePseudoClass(astChild, node);\n              if (bool) {\n                break;\n              }\n            }\n            if (bool) {\n              matched.add(node);\n            }\n            break;\n          }\n          // :state()\n          case 'state': {\n            if (isCustomElement(node)) {\n              const [{ value: stateValue }] = astChildren;\n              if (stateValue) {\n                if (node[stateValue]) {\n                  matched.add(node);\n                } else {\n                  for (const i in node) {\n                    const prop = node[i];\n                    if (prop instanceof this.#window.ElementInternals) {\n                      if (prop?.states?.has(stateValue)) {\n                        matched.add(node);\n                      }\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            break;\n          }\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          // dropped from CSS Selectors 3\n          case 'contains': {\n            if (warn) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          default: {\n            if (!forgive) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if ((localName === 'a' || localName === 'area') &&\n              node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if ((localName === 'a' || localName === 'area') &&\n              node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#document.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'hover': {\n          const { target, type } = this.#event ?? {};\n          if (/^(?:click|mouse(?:down|over|up))$/.test(type) &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'active': {\n          const { buttons, target, type } = this.#event ?? {};\n          if (type === 'mousedown' && buttons & BIT_01 &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#document.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#document.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#document.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#document.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (!this.#shadow && node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === this.#document.activeElement && isFocusableArea(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-visible': {\n          if (node === this.#document.activeElement && isFocusableArea(node)) {\n            let bool;\n            if (isFocusVisible(node)) {\n              bool = true;\n            } else if (this.#focus) {\n              const { relatedTarget, target: focusTarget } = this.#focus;\n              if (focusTarget === node) {\n                if (isFocusVisible(relatedTarget)) {\n                  bool = true;\n                } else if (this.#event) {\n                  const {\n                    key: eventKey, target: eventTarget, type: eventType\n                  } = this.#event;\n                  // this.#event is irrelevant if eventTarget === relatedTarget\n                  if (eventTarget === relatedTarget) {\n                    if (this.#lastFocusVisible === null) {\n                      bool = true;\n                    } else if (focusTarget === this.#lastFocusVisible) {\n                      bool = true;\n                    }\n                  } else if (eventKey === 'Tab') {\n                    if ((eventType === 'keydown' && eventTarget !== node) ||\n                        (eventType === 'keyup' && eventTarget === node)) {\n                      if (eventTarget === focusTarget) {\n                        if (this.#lastFocusVisible === null) {\n                          bool = true;\n                        } else if (eventTarget === this.#lastFocusVisible &&\n                                   relatedTarget === null) {\n                          bool = true;\n                        }\n                      } else {\n                        bool = true;\n                      }\n                    }\n                  } else if (eventKey) {\n                    if ((eventType === 'keydown' || eventType === 'keyup') &&\n                        eventTarget === node) {\n                      bool = true;\n                    }\n                  }\n                } else if (relatedTarget === null ||\n                           relatedTarget === this.#lastFocusVisible) {\n                  bool = true;\n                }\n              }\n            }\n            if (bool) {\n              this.#lastFocusVisible = node;\n              matched.add(node);\n            } else if (this.#lastFocusVisible === node) {\n              this.#lastFocusVisible = null;\n            }\n          }\n          break;\n        }\n        case 'focus-within': {\n          let bool;\n          let current = this.#document.activeElement;\n          if (isFocusableArea(current)) {\n            while (current) {\n              if (current === node) {\n                bool = true;\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          if (bool) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'open':\n        case 'closed': {\n          if (localName === 'details' || localName === 'dialog') {\n            if (node.hasAttribute('open')) {\n              if (astName === 'open') {\n                matched.add(node);\n              }\n            } else if (astName === 'closed') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'disabled':\n        case 'enabled': {\n          const keys = [...KEY_FORM_FOCUS, 'fieldset', 'optgroup', 'option'];\n          if (keys.includes(localName) ||\n              isCustomElement(node, { formAssociated: true })) {\n            let disabled;\n            if (node.disabled || node.hasAttribute('disabled')) {\n              disabled = true;\n            } else if (node.localName === 'option') {\n              if (parentNode.localName === 'optgroup' &&\n                  (parentNode.disabled ||\n                   parentNode.hasAttribute('disabled'))) {\n                disabled = true;\n              }\n            } else if (node.localName !== 'optgroup') {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset' &&\n                    (parent.disabled || parent.hasAttribute('disabled'))) {\n                  let refNode = parent.firstElementChild;\n                  while (refNode) {\n                    if (refNode.localName === 'legend') {\n                      break;\n                    }\n                    refNode = refNode.nextElementSibling;\n                  }\n                  if (refNode) {\n                    if (!refNode.contains(node)) {\n                      disabled = true;\n                    }\n                  } else {\n                    disabled = true;\n                  }\n                  break;\n                } else if (parent.localName === 'form') {\n                  break;\n                } else if (parent.parentNode?.nodeType === ELEMENT_NODE) {\n                  if (parent.parentNode.localName === 'form') {\n                    break;\n                  } else {\n                    parent = parent.parentNode;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n            if (disabled) {\n              if (astName === 'disabled') {\n                matched.add(node);\n              }\n            } else if (astName === 'enabled') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'read-only':\n        case 'read-write': {\n          let readonly;\n          let writable;\n          switch (localName) {\n            case 'textarea': {\n              if (node.readOnly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                readonly = true;\n              } else {\n                writable = true;\n              }\n              break;\n            }\n            case 'input': {\n              if (!node.type || KEY_INPUT_EDIT.includes(node.type)) {\n                if (node.readOnly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled')) {\n                  readonly = true;\n                } else {\n                  writable = true;\n                }\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                writable = true;\n              } else {\n                readonly = true;\n              }\n            }\n          }\n          if (readonly) {\n            if (astName === 'read-only') {\n              matched.add(node);\n            }\n          } else if (astName === 'read-write' && writable) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let placeholder;\n          if (node.placeholder) {\n            placeholder = node.placeholder;\n          } else if (node.hasAttribute('placeholder')) {\n            placeholder = node.getAttribute('placeholder');\n          }\n          if (typeof placeholder === 'string' && !/[\\r\\n]/.test(placeholder)) {\n            let targetNode;\n            if (localName === 'textarea') {\n              targetNode = node;\n            } else if (localName === 'input') {\n              if (node.hasAttribute('type')) {\n                const keys = [...KEY_INPUT_TEXT, 'number'];\n                if (keys.includes(node.getAttribute('type'))) {\n                  targetNode = node;\n                }\n              } else {\n                targetNode = node;\n              }\n            }\n            if (targetNode && node.value === '') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'checked': {\n          const attrType = node.getAttribute('type');\n          if ((node.checked && localName === 'input' &&\n               (attrType === 'checkbox' || attrType === 'radio')) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#document.documentElement;\n            }\n            const walker = this._createTreeWalker(parent);\n            let refNode = traverseNode(parent, walker);\n            refNode = walker.firstChild();\n            let checked;\n            while (refNode) {\n              if (refNode.localName === 'input' &&\n                  refNode.getAttribute('type') === 'radio') {\n                if (refNode.hasAttribute('name')) {\n                  if (refNode.getAttribute('name') === nodeName) {\n                    checked = !!refNode.checked;\n                  }\n                } else {\n                  checked = !!refNode.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          const chekcKeys = ['checkbox', 'radio'];\n          const resetKeys = ['button', 'reset'];\n          const submitKeys = ['image', 'submit'];\n          const attrType = node.getAttribute('type');\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') && resetKeys.includes(attrType))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               submitKeys.includes(attrType))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker = this._createTreeWalker(form);\n              let refNode = traverseNode(form, walker);\n              refNode = walker.firstChild();\n              while (refNode) {\n                const nodeName = refNode.localName;\n                const nodeAttrType = refNode.getAttribute('type');\n                let m;\n                if (nodeName === 'button') {\n                  m = !(refNode.hasAttribute('type') &&\n                    resetKeys.includes(nodeAttrType));\n                } else if (nodeName === 'input') {\n                  m = refNode.hasAttribute('type') &&\n                    submitKeys.includes(nodeAttrType);\n                }\n                if (m) {\n                  if (refNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                refNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     chekcKeys.includes(attrType) &&\n                     node.hasAttribute('checked')) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option' && node.hasAttribute('selected')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'valid':\n        case 'invalid': {\n          const keys = [...KEY_FORM_FOCUS, 'form'];\n          if (keys.includes(localName)) {\n            let valid;\n            if (node.checkValidity()) {\n              if (node.maxLength >= 0) {\n                if (node.maxLength >= node.value.length) {\n                  valid = true;\n                }\n              } else {\n                valid = true;\n              }\n            }\n            if (valid) {\n              if (astName === 'valid') {\n                matched.add(node);\n              }\n            } else if (astName === 'invalid') {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this._createTreeWalker(node);\n            let refNode = traverseNode(node, walker);\n            refNode = walker.firstChild();\n            let valid;\n            if (!refNode) {\n              valid = true;\n            } else {\n              while (refNode) {\n                if (keys.includes(refNode.localName)) {\n                  if (refNode.checkValidity()) {\n                    if (refNode.maxLength >= 0) {\n                      valid = refNode.maxLength >= refNode.value.length;\n                    } else {\n                      valid = true;\n                    }\n                  } else {\n                    valid = false;\n                  }\n                  if (!valid) {\n                    break;\n                  }\n                }\n                refNode = walker.nextNode();\n              }\n            }\n            if (valid) {\n              if (astName === 'valid') {\n                matched.add(node);\n              }\n            } else if (astName === 'invalid') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range':\n        case 'out-of-range': {\n          const keys = [...KEY_INPUT_DATE, 'number', 'range'];\n          const attrType = node.getAttribute('type');\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              keys.includes(attrType)) {\n            const flowed =\n              node.validity.rangeUnderflow || node.validity.rangeOverflow;\n            if (astName === 'out-of-range' && flowed) {\n              matched.add(node);\n            } else if (astName === 'in-range' && !flowed &&\n                       (node.hasAttribute('min') || node.hasAttribute('max') ||\n                       attrType === 'range')) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'required':\n        case 'optional': {\n          let targetNode;\n          if (localName === 'select' || localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const keys = [...KEY_INPUT_EDIT, 'checkbox', 'file', 'radio'];\n              const attrType = node.getAttribute('type');\n              if (keys.includes(attrType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode) {\n            if (node.required || node.hasAttribute('required')) {\n              if (astName === 'required') {\n                matched.add(node);\n              }\n            } else if (astName === 'optional') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            const walker = this._createTreeWalker(node, {\n              force: true,\n              whatToShow: SHOW_ALL\n            });\n            let refNode = walker.firstChild();\n            let bool;\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode && node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) || node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'defined': {\n          if (node.hasAttribute('is') || localName.includes('-')) {\n            if (isCustomElement(node)) {\n              matched.add(node);\n            }\n          // NOTE: MathMLElement not implemented in jsdom\n          } else if (node instanceof this.#window.HTMLElement ||\n                     node instanceof this.#window.SVGElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'popover-open': {\n          if (node.popover && isVisible(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        // not supported\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'fullscreen':\n        case 'future':\n        case 'has-slotted':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-class :${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}`,\n                NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            throw new DOMException(`Unknown pseudo-class :${astName}`,\n              SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match shadow host pseudo class\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren, name: astName } = ast;\n    if (Array.isArray(astChildren)) {\n      if (astChildren.length !== 1) {\n        const css = generateCSS(ast);\n        throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n      }\n      const { branches } = walkAST(astChildren[0]);\n      const [branch] = branches;\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          return node;\n        }\n        return null;\n      } else if (astName === 'host-context') {\n        let parent = host;\n        let bool;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          return node;\n        }\n        return null;\n      }\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    } else if (astName === 'host') {\n      return node;\n    } else {\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    }\n  }\n\n  /**\n   * match selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt = {}) {\n    const { type: astType } = ast;\n    const astName = unescapeSelector(ast.name);\n    const matched = new Set();\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case ATTR_SELECTOR: {\n          const res = matchAttributeSelector(ast, node);\n          if (res) {\n            matched.add(node);\n          }\n          break;\n        }\n        case ID_SELECTOR: {\n          if (node.id === astName) {\n            matched.add(node);\n          }\n          break;\n        }\n        case CLASS_SELECTOR: {\n          if (node.classList.contains(astName)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_CLASS_SELECTOR: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          return nodes;\n        }\n        case TYPE_SELECTOR: {\n          const res = matchTypeSelector(ast, node, opt);\n          if (res) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_ELEMENT_SELECTOR:\n        default: {\n          matchPseudoElementSelector(astName, astType, opt);\n        }\n      }\n    } else if (this.#shadow && astType === PS_CLASS_SELECTOR &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (KEY_LOGICAL.includes(astName)) {\n        opt.isShadowRoot = true;\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        return nodes;\n      } else if (astName === 'host' || astName === 'host-context') {\n        const res = this._matchShadowHostPseudoClass(ast, node, opt);\n        if (res) {\n          this.#verifyShadowHost = true;\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let result;\n    if (this.#invalidate) {\n      result = this.#invalidateResults.get(leaves);\n    } else {\n      result = this.#results.get(leaves);\n    }\n    if (result && result.has(node)) {\n      const { matched } = result.get(node);\n      return matched;\n    } else {\n      let cacheable = true;\n      const formKeys = [...KEY_FORM_FOCUS, 'fieldset', 'form'];\n      const pseudoKeys = ['any-link', 'defined', 'dir', 'link'];\n      if (node.nodeType === ELEMENT_NODE && formKeys.includes(node.localName)) {\n        cacheable = false;\n      }\n      let bool;\n      for (const leaf of leaves) {\n        switch (leaf.type) {\n          case ATTR_SELECTOR:\n          case ID_SELECTOR: {\n            cacheable = false;\n            break;\n          }\n          case PS_CLASS_SELECTOR: {\n            if (pseudoKeys.includes(leaf.name)) {\n              cacheable = false;\n            }\n            break;\n          }\n          default:\n        }\n        bool = this._matchSelector(leaf, node, opt).has(node);\n        if (!bool) {\n          break;\n        }\n      }\n      if (cacheable) {\n        if (!result) {\n          result = new WeakMap();\n        }\n        result.set(node, {\n          matched: bool\n        });\n        if (this.#invalidate) {\n          this.#invalidateResults.set(leaves, result);\n        } else {\n          this.#results.set(leaves, result);\n        }\n      }\n      return bool;\n    }\n  }\n\n  /**\n   * find descendant nodes\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node or Element.shadowRoot\n   * @param {object} opt - options\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode, opt) {\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const nodes = new Set();\n    let pending = false;\n    if (this.#shadow || baseNode.nodeType !== ELEMENT_NODE) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case PS_ELEMENT_SELECTOR: {\n          matchPseudoElementSelector(leafName, leafType, opt);\n          break;\n        }\n        case ID_SELECTOR: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node, opt);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    if (pending) {\n      const walker = this._createTreeWalker(baseNode);\n      let refNode = traverseNode(baseNode, walker);\n      refNode = walker.firstChild();\n      while (refNode) {\n        const bool = this._matchLeaves(leaves, refNode, opt);\n        if (bool) {\n          nodes.add(refNode);\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * match combinator\n   * @private\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { parentNode } = node;\n    const { dir } = opt;\n    const matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            let refNode = node.nextElementSibling;\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = refNode.nextElementSibling;\n            }\n          }\n          break;\n        }\n        case '>': {\n          let refNode = node.firstElementChild;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = refNode.nextElementSibling;\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const nodes = this._findDescendantNodes(leaves, node, opt);\n          if (nodes.size) {\n            return nodes;\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            let refNode = parentNode.firstElementChild;\n            while (refNode) {\n              if (refNode === node) {\n                break;\n              } else {\n                const bool = this._matchLeaves(leaves, refNode, opt);\n                if (bool) {\n                  matched.add(refNode);\n                }\n              }\n              refNode = refNode.nextElementSibling;\n            }\n          }\n          break;\n        }\n        case '>': {\n          if (parentNode) {\n            const bool = this._matchLeaves(leaves, parentNode, opt);\n            if (bool) {\n              matched.add(parentNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            return new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node(s) from #qswalker\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node to start from\n   * @param {object} opt - options\n   * @param {boolean} [opt.force] - traverse only to next node\n   * @param {string} [opt.targetType] - target type\n   * @returns {?object|Array.<object>} - matched node / collection of nodes\n   */\n  _findWalker(leaves, node, opt = {}) {\n    const { force, targetType } = opt;\n    const walker = this.#qswalker;\n    const nodes = [];\n    let refNode = traverseNode(node, walker, !!force);\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = walker.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = walker.nextNode();\n        }\n      }\n      while (refNode) {\n        const matched = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (matched) {\n          nodes.push(refNode);\n          if (targetType !== TARGET_ALL) {\n            break;\n          }\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * match self\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _matchSelf(leaves) {\n    const nodes = [];\n    let filtered = false;\n    const bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find lineal\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @param {object} opt - options\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findLineal(leaves, opt) {\n    const { complex } = opt;\n    const nodes = [];\n    let filtered = false;\n    let bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    if (!bool || complex) {\n      let refNode = this.#node.parentNode;\n      while (refNode) {\n        bool = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (bool) {\n          nodes.push(refNode);\n          filtered = true;\n        }\n        if (refNode.parentNode) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find entry nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @param {boolean} complex - complex selector\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType, complex) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { name: leafName, type: leafType } = leaf;\n    let nodes = [];\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case PS_ELEMENT_SELECTOR: {\n        matchPseudoElementSelector(leafName, leafType, {\n          warn: this.#warn\n        });\n        break;\n      }\n      case ID_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST &&\n                   this.#root.nodeType !== ELEMENT_NODE) {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType,\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case CLASS_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case TYPE_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL &&\n            (leafName === 'host' || leafName === 'host-context')) {\n          let shadowRoot;\n          if (this.#shadow &&\n              this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            shadowRoot = this._matchShadowHostPseudoClass(leaf, this.#node);\n          } else if (compound && this.#node.nodeType === ELEMENT_NODE) {\n            shadowRoot =\n              this._matchShadowHostPseudoClass(leaf, this.#node.shadowRoot);\n          }\n          if (shadowRoot) {\n            let bool;\n            if (compound) {\n              for (const item of filterLeaves) {\n                if (/^host(?:-context)?$/.test(item.name)) {\n                  const node =\n                    this._matchShadowHostPseudoClass(item, shadowRoot);\n                  bool = node === shadowRoot;\n                } else if (item.name === 'has') {\n                  bool = this._matchPseudoClassSelector(item, shadowRoot, {})\n                    .has(shadowRoot);\n                } else {\n                  bool = false;\n                }\n                if (!bool) {\n                  break;\n                }\n              }\n            } else {\n              bool = true;\n            }\n            if (bool) {\n              nodes.push(shadowRoot);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST) {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * collect nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const branchLen = branch.length;\n        const complex = branchLen > 1;\n        const firstTwig = branch[0];\n        let dir;\n        let twig;\n        if (complex) {\n          const {\n            combo: firstCombo,\n            leaves: [{\n              name: firstName,\n              type: firstType\n            }]\n          } = firstTwig;\n          const lastTwig = branch[branchLen - 1];\n          const {\n            leaves: [{\n              name: lastName,\n              type: lastType\n            }]\n          } = lastTwig;\n          dir = DIR_NEXT;\n          twig = firstTwig;\n          if (this.#selector.includes(':scope') ||\n              lastType === PS_ELEMENT_SELECTOR || lastType === ID_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (firstName === '*' && firstType === TYPE_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (lastName === '*' && lastType === TYPE_SELECTOR) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (branchLen === 2) {\n            const { name: comboName } = firstCombo;\n            if (comboName === '+' || comboName === '~') {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            }\n          }\n        } else {\n          dir = DIR_PREV;\n          twig = firstTwig;\n        }\n        const {\n          compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#qswalker;\n        } else {\n          node = this.#root;\n          walker = this._createTreeWalker(node);\n        }\n        let nextNode = traverseNode(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode, {\n                warn: this.#warn\n              });\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].push(nextNode);\n              }\n            }\n          }\n          if (nextNode !== walker.currentNode) {\n            nextNode = traverseNode(nextNode, walker);\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const complex = branch.length > 1;\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * get combined nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {object} nodes - collection of nodes\n   * @param {string} dir - direction\n   * @returns {Array.<object>} - collection of matched nodes\n   */\n  _getCombinedNodes(twig, nodes, dir) {\n    const arr = [];\n    for (const node of nodes) {\n      const matched = this._matchCombinator(twig, node, {\n        dir,\n        warn: this.#warn\n      });\n      if (matched.size) {\n        arr.push(...matched);\n      }\n    }\n    if (arr.length) {\n      return new Set(arr);\n    }\n    return new Set();\n  }\n\n  /**\n   * match node to next direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {Set.<object>} nodes - collection of Element node\n   * @param {object} opt - option\n   * @param {object} opt.combo - combo\n   * @returns {?object} - matched node\n   */\n  _matchNodeNext(branch, nodes, opt) {\n    const { combo, index } = opt;\n    const { combo: nextCombo, leaves } = branch[index];\n    const twig = {\n      combo,\n      leaves\n    };\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_NEXT);\n    if (nextNodes.size) {\n      if (index === branch.length - 1) {\n        const [nextNode] = sortNodes(nextNodes);\n        return nextNode;\n      } else {\n        return this._matchNodeNext(branch, nextNodes, {\n          combo: nextCombo,\n          index: index + 1\n        });\n      }\n    }\n    return null;\n  }\n\n  /**\n   * match node to previous direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @param {number} opt.index - index\n   * @returns {?object} - node\n   */\n  _matchNodePrev(branch, node, opt) {\n    const { index } = opt;\n    const twig = branch[index];\n    const nodes = new Set([node]);\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_PREV);\n    if (nextNodes.size) {\n      if (index === 0) {\n        return node;\n      } else {\n        let matched;\n        for (const nextNode of nextNodes) {\n          matched = this._matchNodePrev(branch, nextNode, {\n            index: index - 1\n          });\n          if (matched) {\n            break;\n          }\n        }\n        if (matched) {\n          return node;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * find matched nodes\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  find(targetType) {\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      this._prepareQuerySelectorWalker();\n    }\n    const [[...branches], collectedNodes] = this._collectNodes(targetType);\n    const l = branches.length;\n    let sort;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, dir, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = collectedNodes[i];\n        const entryNodesLen = entryNodes.length;\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              if (node !== this.#node && this.#node.contains(node)) {\n                nodes.add(node);\n                if (targetType === TARGET_FIRST) {\n                  break;\n                }\n              }\n            }\n          } else if (targetType === TARGET_ALL) {\n            if (nodes.size) {\n              const n = [...nodes];\n              nodes = new Set([...n, ...entryNodes]);\n              sort = true;\n            } else {\n              nodes = new Set(entryNodes);\n            }\n          } else {\n            const [node] = entryNodes;\n            nodes.add(node);\n          }\n        } else if (targetType === TARGET_ALL) {\n          if (dir === DIR_NEXT) {\n            const { combo: firstCombo } = branch[0];\n            let combo = firstCombo;\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const twig = {\n                  combo,\n                  leaves\n                };\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === lastIndex) {\n                    if (nodes.size) {\n                      const n = [...nodes];\n                      nodes = new Set([...n, ...nextNodes]);\n                      sort = true;\n                      combo = firstCombo;\n                    } else {\n                      nodes = nextNodes;\n                      combo = firstCombo;\n                    }\n                  } else {\n                    combo = nextCombo;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          } else {\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === 0) {\n                    nodes.add(node);\n                    if (branchLen > 1 && nodes.size > 1) {\n                      sort = true;\n                    }\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        } else if (targetType === TARGET_FIRST && dir === DIR_NEXT) {\n          const { combo: entryCombo } = branch[0];\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodeNext(branch, new Set([node]), {\n              combo: entryCombo,\n              index: 1\n            });\n            if (matched) {\n              nodes.add(matched);\n              break;\n            }\n          }\n          if (!matched) {\n            const { leaves: entryLeaves } = branch[0];\n            const [entryNode] = entryNodes;\n            let [refNode] =\n              this._findWalker(entryLeaves, entryNode, {\n                targetType\n              });\n            while (refNode) {\n              matched = this._matchNodeNext(branch, new Set([refNode]), {\n                combo: entryCombo,\n                index: 1\n              });\n              if (matched) {\n                nodes.add(matched);\n                break;\n              }\n              [refNode] = this._findWalker(entryLeaves, refNode, {\n                targetType,\n                force: true\n              });\n            }\n          }\n        } else {\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodePrev(branch, node, {\n              index: lastIndex - 1\n            });\n            if (matched) {\n              nodes.add(node);\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const { leaves: entryLeaves } = branch[lastIndex];\n            const [entryNode] = entryNodes;\n            let [refNode] = this._findWalker(entryLeaves, entryNode, {\n              targetType\n            });\n            while (refNode) {\n              matched = this._matchNodePrev(branch, refNode, {\n                index: lastIndex - 1\n              });\n              if (matched) {\n                nodes.add(refNode);\n                break;\n              }\n              [refNode] = this._findWalker(entryLeaves, refNode, {\n                targetType,\n                force: true\n              });\n            }\n          }\n        }\n      }\n    }\n    if (targetType === TARGET_FIRST) {\n      nodes.delete(this.#node);\n      if (nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    } else if (targetType === TARGET_ALL) {\n      nodes.delete(this.#node);\n      if (sort && nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    }\n    return nodes;\n  }\n}\n"],"mappings":"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","names":["index_exports","__export","DOMSelector","__toCommonJS","import_css_tree","import_nwsapi","import_bidi_js","import_css_tree","import_is_potential_custom_element_name","ATTR_SELECTOR","CLASS_SELECTOR","COMBINATOR","IDENT","ID_SELECTOR","NOT_SUPPORTED_ERR","NTH","PS_CLASS_SELECTOR","PS_ELEMENT_SELECTOR","SELECTOR","STRING","SYNTAX_ERR","TARGET_ALL","TARGET_FIRST","TARGET_LINEAL","TARGET_SELF","TYPE_SELECTOR","ALPHA_NUM","CHILD_IDX","DIGIT","LANG_PART","PSEUDO_CLASS","ANB","N_TH","SUB_TYPE","SUB_TYPE_WO_PSEUDO","TAG_ID_CLASS","TAG_TYPE","TAG_TYPE_I","COMPOUND","COMPOUND_WO_PSEUDO","COMBO","COMPLEX","DESCEND","NESTED_LOGIC_A","NESTED_LOGIC_B","COMPOUND_A","COMPOUND_B","COMPOUND_I","COMPLEX_L","LOGIC_COMPLEX","LOGIC_COMPOUND","HAS_COMPOUND","KEY_FORM_FOCUS","KEY_INPUT_BUTTON","KEY_INPUT_DATE","KEY_INPUT_TEXT","KEY_INPUT_EDIT","KEY_INPUT_LTR","KEY_LOGICAL","KEY_MODIFIER","KEY_PS_STATE","KEY_SHADOW_HOST","REG_LOGIC_COMPLEX","PSEUDO_CLASS","N_TH","LOGIC_COMPLEX","REG_LOGIC_COMPOUND","LOGIC_COMPOUND","REG_LOGIC_HAS_COMPOUND","HAS_COMPOUND","REG_WO_LOGICAL","getType","o","resolveContent","node","getType","document","root","shadow","host","mode","ownerDocument","refNode","nodeType","parentNode","traverseNode","walker","force","bool","isCustomElement","opt","localName","formAssociated","window","elmConstructor","attr","isCustomElementName","getSlottedTextContent","nodes","text","item","getDirectionality","dirAttr","getEmbeddingLevels","bidiFactory","valueKeys","KEY_INPUT_BUTTON","KEY_INPUT_TEXT","items","itemDir","itemLocalName","itemNodeType","itemTextContent","level","parentNodeType","isContentEditable","isVisible","display","visibility","isFocusVisible","type","KEY_INPUT_EDIT","isFocusableArea","child","keys","ns","getNamespaceURI","ns","node","getType","attributes","res","attr","name","namespaceURI","prefix","value","isNamespaceDeclared","root","parent","isPreceding","nodeA","nodeB","posBit","sortNodes","nodes","arr","a","b","initNwsapi","window","document","getType","nw","nwsapi","filterSelector","selector","opt","complex","compound","descend","simple","target","index","TARGET_SELF","TARGET_LINEAL","REG_LOGIC_HAS_COMPOUND","REG_LOGIC_COMPLEX","REG_LOGIC_COMPOUND","REG_WO_LOGICAL","import_css_tree","REG_EMPTY_PS_FUNC","REG_SHADOW_PS_ELEMENT","U_FFFD","unescapeSelector","selector","arr","l","i","item","hexExists","hex","str","low","high","deci","postStr","preprocess","args","index","preHash","postHash","SYNTAX_ERR","codePoint","getType","parseSelector","res","ast","message","sel","walkAST","branches","info","node","SELECTOR","PS_CLASS_SELECTOR","KEY_LOGICAL","KEY_PS_STATE","KEY_SHADOW_HOST","PS_ELEMENT_SELECTOR","NTH","list","itemList","name","type","children","grandChildren","greatGrandChildren","sortAST","asts","order","ID_SELECTOR","CLASS_SELECTOR","TYPE_SELECTOR","ATTR_SELECTOR","a","b","typeA","typeB","bitA","bitB","parseAstName","prefix","localName","matchPseudoElementSelector","astName","astType","opt","forgive","warn","PS_ELEMENT_SELECTOR","NOT_SUPPORTED_ERR","SYNTAX_ERR","getType","matchDirectionPseudoClass","ast","node","name","type","dir","getDirectionality","matchLanguagePseudoClass","value","STRING","IDENT","unescapeSelector","parent","res","ALPHA_NUM","LANG_PART","regExtendedLang","langMain","langSub","langRest","extendedMain","extendedSub","len","extendedRest","i","matchAttributeSelector","astFlags","astMatcher","astValue","css","attributes","contentType","caseInsensitive","astAttrName","attrValues","astPrefix","astLocalName","parseAstName","item","itemName","itemValue","itemPrefix","itemLocalName","isNamespaceDeclared","astIdentValue","astStringValue","attrValue","matchTypeSelector","localName","namespaceURI","prefix","nodePrefix","nodeLocalName","astNS","nodeNS","DIR_NEXT","DIR_PREV","Finder","#ast","#astCache","#descendant","#document","#documentCache","#event","#focus","#invalidate","#invalidateResults","#lastFocusVisible","#node","#nodes","#noexcept","#qswalker","#results","#root","#selector","#shadow","#verifyShadowHost","#walkers","#warn","#window","window","e","opt","NOT_SUPPORTED_ERR","selector","node","noexcept","warn","resolveContent","func","focusKeys","key","evt","keyboardKeys","KEY_MODIFIER","mouseKeys","nodes","ast","cachedItem","item","l","i","cssAst","parseSelector","branches","info","walkAST","hasHasPseudoFunc","hasLogicalPseudoFunc","hasNthChildOfSelector","hasStatePseudoClass","invalidate","descendant","items","branch","COMBINATOR","leaves","itemName","nextItem","SYNTAX_ERR","sortAST","unescapeSelector","force","whatToShow","walker","anb","a","b","reverse","parentNode","matched","selectorBranches","refNode","selectorNodes","isVisible","bool","traverseNode","nth","j","m","localName","namespaceURI","prefix","itemLocalName","itemNamespaceURI","itemPrefix","nthName","nthIdentName","anbMap","astLeaves","leaf","leafType","combo","twigLeaves","itemType","twig","nextNode","astData","astName","twigBranches","isShadowRoot","invalid","childAstType","PS_CLASS_SELECTOR","lastIndex","nextNodes","arr","astChildren","forgive","KEY_LOGICAL","css","forgiven","child","nestedLeaf","leavesSet","res","astChild","matchDirectionPseudoClass","matchLanguagePseudoClass","isCustomElement","stateValue","prop","href","origin","pathname","attrURL","target","type","buttons","hash","id","current","isFocusableArea","isFocusVisible","relatedTarget","focusTarget","eventKey","eventTarget","eventType","KEY_FORM_FOCUS","disabled","parent","readonly","writable","KEY_INPUT_EDIT","isContentEditable","placeholder","targetNode","KEY_INPUT_TEXT","attrType","nodeName","checked","chekcKeys","resetKeys","submitKeys","form","nodeAttrType","keys","valid","KEY_INPUT_DATE","flowed","node1","node2","host","astType","ATTR_SELECTOR","matchAttributeSelector","ID_SELECTOR","CLASS_SELECTOR","TYPE_SELECTOR","matchTypeSelector","PS_ELEMENT_SELECTOR","matchPseudoElementSelector","result","cacheable","formKeys","pseudoKeys","baseNode","filterLeaves","compound","leafName","pending","comboName","dir","targetType","TARGET_ALL","filtered","complex","TARGET_SELF","TARGET_LINEAL","TARGET_FIRST","shadowRoot","pendingItems","branchLen","firstTwig","firstCombo","firstName","firstType","lastTwig","lastName","lastType","pendingItem","index","nextCombo","sortNodes","collectedNodes","sort","find","entryNodes","entryNodesLen","n","entryCombo","entryLeaves","entryNode","REG_COMPLEX","COMPOUND_I","COMBO","REG_DESCEND","DESCEND","REG_SIMPLE","TAG_ID_CLASS","DOMSelector","#window","#document","#finder","#nwsapi","window","document","Finder","initNwsapi","selector","node","opt","e","getType","filterOpt","TARGET_SELF","filterSelector","res","TARGET_LINEAL","nodes","refNode","TARGET_FIRST","TARGET_ALL"]}