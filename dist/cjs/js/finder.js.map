{
  "version": 3,
  "sources": ["../../../src/js/finder.js"],
  "sourcesContent": ["/**\n * finder.js\n */\n\n/* import */\nimport {\n  matchAttributeSelector, matchDirectionPseudoClass, matchLanguagePseudoClass,\n  matchPseudoElementSelector, matchTypeSelector\n} from './matcher.js';\nimport {\n  findAST, generateCSS, parseSelector, sortAST, unescapeSelector, walkAST\n} from './parser.js';\nimport {\n  isContentEditable, isCustomElement, isFocusVisible, isFocusableArea,\n  isVisible, resolveContent, sortNodes, traverseNode\n} from './utility.js';\n\n/* constants */\nimport {\n  ATTR_SELECTOR, BIT_01, CLASS_SELECTOR, COMBINATOR, DOCUMENT_FRAGMENT_NODE,\n  ELEMENT_NODE, ID_SELECTOR, KEY_FORM_FOCUS, KEY_INPUT_DATE, KEY_INPUT_EDIT,\n  KEY_INPUT_TEXT, KEY_LOGICAL, KEY_MODIFIER, NOT_SUPPORTED_ERR,\n  PS_CLASS_SELECTOR, PS_ELEMENT_SELECTOR, SHOW_ALL, SYNTAX_ERR, TARGET_ALL,\n  TARGET_FIRST, TARGET_LINEAL, TARGET_SELF, TEXT_NODE, TYPE_SELECTOR,\n  WALKER_FILTER\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\n\n/**\n * Finder\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: Array<Ast | undefined>\n * #nodes: Array<Nodes>\n * Ast: {\n *   branch: Array<Branch | undefined>,\n *   dir: string | null,\n *   filtered: boolean,\n *   find: boolean\n * }\n * Branch: Array<Twig>\n * Twig: {\n *   combo: Leaf | null,\n *   leaves: Array<Leaf>\n * }\n * Leaf: {\n *   children: Array<Leaf | undefined> | null,\n *   loc: null,\n *   type: string\n * }\n * Nodes: Array<HTMLElement | undefined>\n */\nexport class Finder {\n  /* private fields */\n  #ast;\n  #astCache;\n  #descendant;\n  #document;\n  #documentCache;\n  #event;\n  #focus;\n  #invalidate;\n  #invalidateResults;\n  #lastFocusVisible;\n  #node;\n  #nodes;\n  #noexcept;\n  #qswalker;\n  #results;\n  #root;\n  #selector;\n  #shadow;\n  #verifyShadowHost;\n  #walkers;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   * @param {object} window - window\n   */\n  constructor(window) {\n    this.#window = window;\n    this.#astCache = new WeakMap();\n    this.#documentCache = new WeakMap();\n    this.#invalidateResults = new WeakMap();\n    this.#results = new WeakMap();\n    this.#event = null;\n    this.#focus = null;\n    this.#lastFocusVisible = null;\n    this._registerEventListeners();\n  }\n\n  /**\n   * handle error\n   * @param {Error} e - Error\n   * @param {object} opt - options\n   * @throws Error\n   * @returns {void}\n   */\n  onError(e, opt) {\n    const noexcept = opt?.noexcept ?? this.#noexcept;\n    if (!noexcept) {\n      if (e instanceof DOMException ||\n          e instanceof this.#window.DOMException) {\n        if (e.name === NOT_SUPPORTED_ERR) {\n          if (this.#warn) {\n            console.warn(e.message);\n          }\n        } else {\n          throw new this.#window.DOMException(e.message, e.name);\n        }\n      } else if (e.name in this.#window) {\n        throw new this.#window[e.name](e.message);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * setup finder\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {object} [opt.event] - MouseEvent, KeyboardEvent\n   * @param {boolean} [opt.noexcept] - no exception\n   * @param {boolean} [opt.warn] - console warn\n   * @returns {object} - finder\n   */\n  setup(selector, node, opt = {}) {\n    const { noexcept, warn } = opt;\n    this.#noexcept = !!noexcept;\n    this.#warn = !!warn;\n    this.#node = node;\n    [\n      this.#document,\n      this.#root,\n      this.#shadow\n    ] = resolveContent(node);\n    this.#selector = selector;\n    [\n      this.#ast,\n      this.#nodes\n    ] = this._correspond(selector);\n    this.#invalidateResults = new WeakMap();\n    this.#walkers = new WeakMap();\n    this.#verifyShadowHost = null;\n    return this;\n  }\n\n  /**\n   * register event listeners\n   * @private\n   * @returns {Array.<void>} - results\n   */\n  _registerEventListeners() {\n    const opt = {\n      capture: true,\n      passive: true\n    };\n    const func = [];\n    const focusKeys = ['focus', 'focusin'];\n    for (const key of focusKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#focus = evt;\n      }, opt));\n    }\n    const keyboardKeys = ['keydown', 'keyup'];\n    for (const key of keyboardKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        const { key } = evt;\n        if (!KEY_MODIFIER.includes(key)) {\n          this.#event = evt;\n        }\n      }, opt));\n    }\n    const mouseKeys = [\n      'mouseover', 'mousedown', 'mouseup', 'click', 'mouseout'\n    ];\n    for (const key of mouseKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#event = evt;\n      }, opt));\n    }\n    return func;\n  }\n\n  /**\n   * correspond ast and nodes\n   * @private\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of ast and nodes\n   */\n  _correspond(selector) {\n    const nodes = [];\n    this.#descendant = false;\n    this.#invalidate = false;\n    let ast;\n    if (this.#documentCache.has(this.#document)) {\n      const cachedItem = this.#documentCache.get(this.#document);\n      if (cachedItem && cachedItem.has(`${selector}`)) {\n        const item = cachedItem.get(`${selector}`);\n        ast = item.ast;\n        this.#descendant = item.descendant;\n        this.#invalidate = item.invalidate;\n      }\n    }\n    if (ast) {\n      const l = ast.length;\n      for (let i = 0; i < l; i++) {\n        ast[i].dir = null;\n        ast[i].filtered = false;\n        ast[i].find = false;\n        nodes[i] = [];\n      }\n    } else {\n      let cssAst;\n      try {\n        cssAst = parseSelector(selector);\n      } catch (e) {\n        this.onError(e);\n      }\n      const { branches, info } = walkAST(cssAst);\n      const {\n        hasHasPseudoFunc, hasLogicalPseudoFunc, hasNthChildOfSelector,\n        hasStatePseudoClass\n      } = info;\n      let invalidate = hasHasPseudoFunc || hasStatePseudoClass ||\n        !!(hasLogicalPseudoFunc && hasNthChildOfSelector);\n      let descendant = false;\n      let i = 0;\n      ast = [];\n      for (const [...items] of branches) {\n        const branch = [];\n        let item = items.shift();\n        if (item && item.type !== COMBINATOR) {\n          const leaves = new Set();\n          while (item) {\n            let itemName = item.name;\n            if (item.type === COMBINATOR) {\n              const [nextItem] = items;\n              if (nextItem.type === COMBINATOR) {\n                throw new DOMException(`Invalid selector ${selector}`,\n                  SYNTAX_ERR);\n              }\n              if (itemName === '+' || itemName === '~') {\n                invalidate = true;\n              } else {\n                descendant = true;\n              }\n              branch.push({\n                combo: item,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n            } else if (item) {\n              if (itemName && typeof itemName === 'string') {\n                itemName = unescapeSelector(itemName);\n                if (typeof itemName === 'string' && itemName !== item.name) {\n                  item.name = itemName;\n                }\n                if (/[|:]/.test(itemName)) {\n                  item.namespace = true;\n                }\n              }\n              leaves.add(item);\n            }\n            if (items.length) {\n              item = items.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n              break;\n            }\n          }\n        }\n        ast.push({\n          branch,\n          dir: null,\n          filtered: false,\n          find: false\n        });\n        nodes[i] = [];\n        i++;\n      }\n      let cachedItem;\n      if (this.#documentCache.has(this.#document)) {\n        cachedItem = this.#documentCache.get(this.#document);\n      } else {\n        cachedItem = new Map();\n      }\n      cachedItem.set(`${selector}`, {\n        ast,\n        descendant,\n        invalidate\n      });\n      this.#documentCache.set(this.#document, cachedItem);\n      this.#descendant = descendant;\n      this.#invalidate = invalidate;\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * create tree walker\n   * @private\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.force] - force new tree walker\n   * @param {number} [opt.whatToShow] - NodeFilter whatToShow\n   * @returns {object} - tree walker\n   */\n  _createTreeWalker(node, opt = {}) {\n    const { force = false, whatToShow = WALKER_FILTER } = opt;\n    let walker;\n    if (force) {\n      walker = this.#document.createTreeWalker(node, whatToShow);\n    } else if (this.#walkers.has(node)) {\n      walker = this.#walkers.get(node);\n    } else {\n      walker = this.#document.createTreeWalker(node, whatToShow);\n      this.#walkers.set(node, walker);\n    }\n    return walker;\n  }\n\n  /**\n   * prepare querySelector walker\n   * @private\n   * @returns {object} - tree walker\n   */\n  _prepareQuerySelectorWalker() {\n    this.#qswalker = this._createTreeWalker(this.#node);\n    return this.#qswalker;\n  }\n\n  /**\n   * collect nth child\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node, opt) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    const matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#astCache.has(selector)) {\n        selectorBranches = this.#astCache.get(selector);\n      } else {\n        const { branches } = walkAST(selector);\n        selectorBranches = branches;\n        if (!this.#invalidate) {\n          this.#astCache.set(selector, selectorBranches);\n        }\n      }\n      const { branches } = walkAST(selector);\n      selectorBranches = branches;\n    }\n    if (parentNode) {\n      const walker = this._createTreeWalker(parentNode, {\n        force: true\n      });\n      let refNode = walker.firstChild();\n      const selectorNodes = new Set();\n      let l = 0;\n      if (selectorBranches) {\n        while (refNode) {\n          if (isVisible(refNode)) {\n            let bool;\n            for (const leaves of selectorBranches) {\n              bool = this._matchLeaves(leaves, refNode, opt);\n              if (!bool) {\n                break;\n              }\n            }\n            if (bool) {\n              selectorNodes.add(refNode);\n            }\n          }\n          l++;\n          refNode = walker.nextSibling();\n        }\n      } else {\n        while (refNode) {\n          l++;\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, namespaceURI, parentNode, prefix } = node;\n    const matched = new Set();\n    if (parentNode) {\n      const walker = this._createTreeWalker(parentNode);\n      let refNode = traverseNode(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = 0;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName, opt) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const anbMap = new Map();\n    if (nthIdentName) {\n      if (nthIdentName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (nthIdentName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    if (nthName === 'nth-child' || nthName === 'nth-last-child') {\n      if (selector) {\n        anbMap.set('selector', selector);\n      }\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthChild(anb, node, opt);\n      return nodes;\n    } else if (nthName === 'nth-of-type' || nthName === 'nth-last-of-type') {\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthOfType(anb, node);\n      return nodes;\n    }\n    return new Set();\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @private\n   * @param {Array.<object>} astLeaves - AST leaves\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(astLeaves, node, opt) {\n    if (Array.isArray(astLeaves) && astLeaves.length) {\n      const leaves = [...astLeaves];\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      opt.dir = DIR_NEXT;\n      const nodes = this._matchCombinator(twig, node, opt);\n      if (nodes.size) {\n        if (leaves.length) {\n          let bool = false;\n          for (const nextNode of nodes) {\n            bool = this._matchHasPseudoFunc(leaves, nextNode, opt);\n            if (bool) {\n              break;\n            }\n          }\n          return bool;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @private\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node, opt) {\n    const { astName, branches, twigBranches } = astData;\n    const isShadowRoot = (opt.isShadowRoot || this.#shadow) &&\n      node.nodeType === DOCUMENT_FRAGMENT_NODE;\n    if (astName === 'has') {\n      let bool;\n      for (const leaves of branches) {\n        bool = this._matchHasPseudoFunc(leaves, node, opt);\n        if (bool) {\n          break;\n        }\n      }\n      if (bool) {\n        if (isShadowRoot) {\n          if (this.#verifyShadowHost) {\n            return node;\n          }\n        } else {\n          return node;\n        }\n      }\n    } else {\n      // check for invalid shadow root\n      if (isShadowRoot) {\n        let invalid;\n        for (const branch of branches) {\n          if (branch.length > 1) {\n            invalid = true;\n            break;\n          } else if (astName === 'not') {\n            const [{ type: childAstType }] = branch;\n            if (childAstType !== PS_CLASS_SELECTOR) {\n              invalid = true;\n              break;\n            }\n          }\n        }\n        if (invalid) {\n          return null;\n        }\n      }\n      opt.forgive = astName === 'is' || astName === 'where';\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, opt);\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            opt.dir = DIR_PREV;\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, opt);\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (bool) {\n          return null;\n        }\n        return node;\n      } else if (bool) {\n        return node;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @private\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt) {\n    const { children: astChildren, name: astName } = ast;\n    const { localName, parentNode } = node;\n    const {\n      forgive,\n      warn = this.#warn\n    } = opt;\n    const matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (Array.isArray(astChildren) && KEY_LOGICAL.includes(astName)) {\n      if (!astChildren.length && astName !== 'is' && astName !== 'where') {\n        const css = generateCSS(ast);\n        throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n      }\n      let astData;\n      if (this.#astCache.has(ast)) {\n        astData = this.#astCache.get(ast);\n      } else {\n        const { branches } = walkAST(ast);\n        if (astName === 'has') {\n          // check for nested :has()\n          let forgiven;\n          for (const child of astChildren) {\n            const item = findAST(child, leaf => {\n              if (KEY_LOGICAL.includes(leaf.name) &&\n                  findAST(leaf, nestedLeaf => nestedLeaf.name === 'has')) {\n                return leaf;\n              }\n              return null;\n            });\n            if (item) {\n              const itemName = item.name;\n              if (itemName === 'is' || itemName === 'where') {\n                forgiven = true;\n                break;\n              } else {\n                const css = generateCSS(ast);\n                throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n              }\n            }\n          }\n          if (forgiven) {\n            return matched;\n          }\n          astData = {\n            astName,\n            branches\n          };\n        } else {\n          const twigBranches = [];\n          for (const [...leaves] of branches) {\n            const branch = [];\n            const leavesSet = new Set();\n            let item = leaves.shift();\n            while (item) {\n              if (item.type === COMBINATOR) {\n                branch.push({\n                  combo: item,\n                  leaves: [...leavesSet]\n                });\n                leavesSet.clear();\n              } else if (item) {\n                leavesSet.add(item);\n              }\n              if (leaves.length) {\n                item = leaves.shift();\n              } else {\n                branch.push({\n                  combo: null,\n                  leaves: [...leavesSet]\n                });\n                leavesSet.clear();\n                break;\n              }\n            }\n            twigBranches.push(branch);\n          }\n          astData = {\n            astName,\n            branches,\n            twigBranches\n          };\n          if (!this.#invalidate) {\n            this.#astCache.set(ast, astData);\n          }\n        }\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node, opt);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        if (astChildren.length !== 1) {\n          const css = generateCSS(ast);\n          throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n        }\n        const [branch] = astChildren;\n        const nodes = this._matchAnPlusB(branch, node, astName, opt);\n        return nodes;\n      } else {\n        switch (astName) {\n          // :dir()\n          case 'dir': {\n            if (astChildren.length !== 1) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            const [astChild] = astChildren;\n            const res = matchDirectionPseudoClass(astChild, node);\n            if (res) {\n              matched.add(node);\n            }\n            break;\n          }\n          // :lang()\n          case 'lang': {\n            if (!astChildren.length) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            let bool;\n            for (const astChild of astChildren) {\n              bool = matchLanguagePseudoClass(astChild, node);\n              if (bool) {\n                break;\n              }\n            }\n            if (bool) {\n              matched.add(node);\n            }\n            break;\n          }\n          // :state()\n          case 'state': {\n            if (isCustomElement(node)) {\n              const [{ value: stateValue }] = astChildren;\n              if (stateValue) {\n                if (node[stateValue]) {\n                  matched.add(node);\n                } else {\n                  for (const i in node) {\n                    const prop = node[i];\n                    if (prop instanceof this.#window.ElementInternals) {\n                      if (prop?.states?.has(stateValue)) {\n                        matched.add(node);\n                      }\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            break;\n          }\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          // dropped from CSS Selectors 3\n          case 'contains': {\n            if (warn) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          default: {\n            if (!forgive) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if ((localName === 'a' || localName === 'area') &&\n              node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if ((localName === 'a' || localName === 'area') &&\n              node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#document.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'hover': {\n          const { target, type } = this.#event ?? {};\n          if (/^(?:click|mouse(?:down|over|up))$/.test(type) &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'active': {\n          const { buttons, target, type } = this.#event ?? {};\n          if (type === 'mousedown' && buttons & BIT_01 &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#document.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#document.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#document.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#document.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (!this.#shadow && node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === this.#document.activeElement && isFocusableArea(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-visible': {\n          if (node === this.#document.activeElement && isFocusableArea(node)) {\n            let bool;\n            if (isFocusVisible(node)) {\n              bool = true;\n            } else if (this.#focus) {\n              const { relatedTarget, target: focusTarget } = this.#focus;\n              if (focusTarget === node) {\n                if (isFocusVisible(relatedTarget)) {\n                  bool = true;\n                } else if (this.#event) {\n                  const {\n                    key: eventKey, target: eventTarget, type: eventType\n                  } = this.#event;\n                  // this.#event is irrelevant if eventTarget === relatedTarget\n                  if (eventTarget === relatedTarget) {\n                    if (this.#lastFocusVisible === null) {\n                      bool = true;\n                    } else if (focusTarget === this.#lastFocusVisible) {\n                      bool = true;\n                    }\n                  } else if (eventKey === 'Tab') {\n                    if ((eventType === 'keydown' && eventTarget !== node) ||\n                        (eventType === 'keyup' && eventTarget === node)) {\n                      if (eventTarget === focusTarget) {\n                        if (this.#lastFocusVisible === null) {\n                          bool = true;\n                        } else if (eventTarget === this.#lastFocusVisible &&\n                                   relatedTarget === null) {\n                          bool = true;\n                        }\n                      } else {\n                        bool = true;\n                      }\n                    }\n                  } else if (eventKey) {\n                    if ((eventType === 'keydown' || eventType === 'keyup') &&\n                        eventTarget === node) {\n                      bool = true;\n                    }\n                  }\n                } else if (relatedTarget === null ||\n                           relatedTarget === this.#lastFocusVisible) {\n                  bool = true;\n                }\n              }\n            }\n            if (bool) {\n              this.#lastFocusVisible = node;\n              matched.add(node);\n            } else if (this.#lastFocusVisible === node) {\n              this.#lastFocusVisible = null;\n            }\n          }\n          break;\n        }\n        case 'focus-within': {\n          let bool;\n          let current = this.#document.activeElement;\n          if (isFocusableArea(current)) {\n            while (current) {\n              if (current === node) {\n                bool = true;\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          if (bool) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'open':\n        case 'closed': {\n          if (localName === 'details' || localName === 'dialog') {\n            if (node.hasAttribute('open')) {\n              if (astName === 'open') {\n                matched.add(node);\n              }\n            } else if (astName === 'closed') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'disabled':\n        case 'enabled': {\n          const keys = [...KEY_FORM_FOCUS, 'fieldset', 'optgroup', 'option'];\n          if (keys.includes(localName) ||\n              isCustomElement(node, { formAssociated: true })) {\n            let disabled;\n            if (node.disabled || node.hasAttribute('disabled')) {\n              disabled = true;\n            } else if (node.localName === 'option') {\n              if (parentNode.localName === 'optgroup' &&\n                  (parentNode.disabled ||\n                   parentNode.hasAttribute('disabled'))) {\n                disabled = true;\n              }\n            } else if (node.localName !== 'optgroup') {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset' &&\n                    (parent.disabled || parent.hasAttribute('disabled'))) {\n                  let refNode = parent.firstElementChild;\n                  while (refNode) {\n                    if (refNode.localName === 'legend') {\n                      break;\n                    }\n                    refNode = refNode.nextElementSibling;\n                  }\n                  if (refNode) {\n                    if (!refNode.contains(node)) {\n                      disabled = true;\n                    }\n                  } else {\n                    disabled = true;\n                  }\n                  break;\n                } else if (parent.localName === 'form') {\n                  break;\n                } else if (parent.parentNode?.nodeType === ELEMENT_NODE) {\n                  if (parent.parentNode.localName === 'form') {\n                    break;\n                  } else {\n                    parent = parent.parentNode;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n            if (disabled) {\n              if (astName === 'disabled') {\n                matched.add(node);\n              }\n            } else if (astName === 'enabled') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'read-only':\n        case 'read-write': {\n          let readonly;\n          let writable;\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                readonly = true;\n              } else {\n                writable = true;\n              }\n              break;\n            }\n            case 'input': {\n              if (!node.type || KEY_INPUT_EDIT.includes(node.type)) {\n                if (node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled')) {\n                  readonly = true;\n                } else {\n                  writable = true;\n                }\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                writable = true;\n              } else {\n                readonly = true;\n              }\n            }\n          }\n          if (readonly) {\n            if (astName === 'read-only') {\n              matched.add(node);\n            }\n          } else if (astName === 'read-write' && writable) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let placeholder;\n          if (node.placeholder) {\n            placeholder = node.placeholder;\n          } else if (node.hasAttribute('placeholder')) {\n            placeholder = node.getAttribute('placeholder');\n          }\n          if (typeof placeholder === 'string' && !/[\\r\\n]/.test(placeholder)) {\n            let targetNode;\n            if (localName === 'textarea') {\n              targetNode = node;\n            } else if (localName === 'input') {\n              if (node.hasAttribute('type')) {\n                const keys = [...KEY_INPUT_TEXT, 'number'];\n                if (keys.includes(node.getAttribute('type'))) {\n                  targetNode = node;\n                }\n              } else {\n                targetNode = node;\n              }\n            }\n            if (targetNode && node.value === '') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'checked': {\n          const attrType = node.getAttribute('type');\n          if ((node.checked && localName === 'input' &&\n               (attrType === 'checkbox' || attrType === 'radio')) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#document.documentElement;\n            }\n            const walker = this._createTreeWalker(parent);\n            let refNode = traverseNode(parent, walker);\n            refNode = walker.firstChild();\n            let checked;\n            while (refNode) {\n              if (refNode.localName === 'input' &&\n                  refNode.getAttribute('type') === 'radio') {\n                if (refNode.hasAttribute('name')) {\n                  if (refNode.getAttribute('name') === nodeName) {\n                    checked = !!refNode.checked;\n                  }\n                } else {\n                  checked = !!refNode.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          const chekcKeys = ['checkbox', 'radio'];\n          const resetKeys = ['button', 'reset'];\n          const submitKeys = ['image', 'submit'];\n          const attrType = node.getAttribute('type');\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') && resetKeys.includes(attrType))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               submitKeys.includes(attrType))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker = this._createTreeWalker(form);\n              let refNode = traverseNode(form, walker);\n              refNode = walker.firstChild();\n              while (refNode) {\n                const nodeName = refNode.localName;\n                const nodeAttrType = refNode.getAttribute('type');\n                let m;\n                if (nodeName === 'button') {\n                  m = !(refNode.hasAttribute('type') &&\n                    resetKeys.includes(nodeAttrType));\n                } else if (nodeName === 'input') {\n                  m = refNode.hasAttribute('type') &&\n                    submitKeys.includes(nodeAttrType);\n                }\n                if (m) {\n                  if (refNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                refNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     chekcKeys.includes(attrType) &&\n                     node.hasAttribute('checked')) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option' && node.hasAttribute('selected')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'valid':\n        case 'invalid': {\n          const keys = [...KEY_FORM_FOCUS, 'form'];\n          if (keys.includes(localName)) {\n            let valid;\n            if (node.checkValidity()) {\n              if (node.maxLength >= 0) {\n                if (node.maxLength >= node.value.length) {\n                  valid = true;\n                }\n              } else {\n                valid = true;\n              }\n            }\n            if (valid) {\n              if (astName === 'valid') {\n                matched.add(node);\n              }\n            } else if (astName === 'invalid') {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this._createTreeWalker(node);\n            let refNode = traverseNode(node, walker);\n            refNode = walker.firstChild();\n            let valid;\n            if (!refNode) {\n              valid = true;\n            } else {\n              while (refNode) {\n                if (keys.includes(refNode.localName)) {\n                  if (refNode.checkValidity()) {\n                    if (refNode.maxLength >= 0) {\n                      valid = refNode.maxLength >= refNode.value.length;\n                    } else {\n                      valid = true;\n                    }\n                  } else {\n                    valid = false;\n                  }\n                  if (!valid) {\n                    break;\n                  }\n                }\n                refNode = walker.nextNode();\n              }\n            }\n            if (valid) {\n              if (astName === 'valid') {\n                matched.add(node);\n              }\n            } else if (astName === 'invalid') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range':\n        case 'out-of-range': {\n          const keys = [...KEY_INPUT_DATE, 'number', 'range'];\n          const attrType = node.getAttribute('type');\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              keys.includes(attrType)) {\n            const flowed =\n              node.validity.rangeUnderflow || node.validity.rangeOverflow;\n            if (astName === 'out-of-range' && flowed) {\n              matched.add(node);\n            } else if (astName === 'in-range' && !flowed &&\n                       (node.hasAttribute('min') || node.hasAttribute('max') ||\n                       attrType === 'range')) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'required':\n        case 'optional': {\n          let targetNode;\n          if (localName === 'select' || localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const keys = [...KEY_INPUT_EDIT, 'checkbox', 'file', 'radio'];\n              const attrType = node.getAttribute('type');\n              if (keys.includes(attrType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode) {\n            if (node.required || node.hasAttribute('required')) {\n              if (astName === 'required') {\n                matched.add(node);\n              }\n            } else if (astName === 'optional') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            const walker = this._createTreeWalker(node, {\n              force: true,\n              whatToShow: SHOW_ALL\n            });\n            let refNode = walker.firstChild();\n            let bool;\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode && node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) || node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'defined': {\n          if (node.hasAttribute('is') || localName.includes('-')) {\n            if (isCustomElement(node)) {\n              matched.add(node);\n            }\n          // NOTE: MathMLElement not implemented in jsdom\n          } else if (node instanceof this.#window.HTMLElement ||\n                     node instanceof this.#window.SVGElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'popover-open': {\n          if (node.popover && isVisible(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        // not supported\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'fullscreen':\n        case 'future':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-class :${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}`,\n                NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            throw new DOMException(`Unknown pseudo-class :${astName}`,\n              SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match shadow host pseudo class\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren, name: astName } = ast;\n    if (Array.isArray(astChildren)) {\n      if (astChildren.length !== 1) {\n        const css = generateCSS(ast);\n        throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n      }\n      const { branches } = walkAST(astChildren[0]);\n      const [branch] = branches;\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          return node;\n        }\n        return null;\n      } else if (astName === 'host-context') {\n        let parent = host;\n        let bool;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          return node;\n        }\n        return null;\n      }\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    } else if (astName === 'host') {\n      return node;\n    } else {\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    }\n  }\n\n  /**\n   * match selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt = {}) {\n    const { type: astType } = ast;\n    const astName = unescapeSelector(ast.name);\n    const matched = new Set();\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case ATTR_SELECTOR: {\n          const res = matchAttributeSelector(ast, node);\n          if (res) {\n            matched.add(node);\n          }\n          break;\n        }\n        case ID_SELECTOR: {\n          if (node.id === astName) {\n            matched.add(node);\n          }\n          break;\n        }\n        case CLASS_SELECTOR: {\n          if (node.classList.contains(astName)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_CLASS_SELECTOR: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          return nodes;\n        }\n        case TYPE_SELECTOR: {\n          const res = matchTypeSelector(ast, node, opt);\n          if (res) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_ELEMENT_SELECTOR:\n        default: {\n          matchPseudoElementSelector(astName, astType, opt);\n        }\n      }\n    } else if (this.#shadow && astType === PS_CLASS_SELECTOR &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (KEY_LOGICAL.includes(astName)) {\n        opt.isShadowRoot = true;\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        return nodes;\n      } else if (astName === 'host' || astName === 'host-context') {\n        const res = this._matchShadowHostPseudoClass(ast, node, opt);\n        if (res) {\n          this.#verifyShadowHost = true;\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let result;\n    if (this.#invalidate) {\n      result = this.#invalidateResults.get(leaves);\n    } else {\n      result = this.#results.get(leaves);\n    }\n    if (result && result.has(node)) {\n      const { matched } = result.get(node);\n      return matched;\n    } else {\n      let cacheable = true;\n      const formKeys = [...KEY_FORM_FOCUS, 'fieldset', 'form'];\n      const pseudoKeys = ['any-link', 'defined', 'dir', 'link'];\n      if (node.nodeType === ELEMENT_NODE && formKeys.includes(node.localName)) {\n        cacheable = false;\n      }\n      let bool;\n      for (const leaf of leaves) {\n        switch (leaf.type) {\n          case ATTR_SELECTOR:\n          case ID_SELECTOR: {\n            cacheable = false;\n            break;\n          }\n          case PS_CLASS_SELECTOR: {\n            if (pseudoKeys.includes(leaf.name)) {\n              cacheable = false;\n            }\n            break;\n          }\n          default:\n        }\n        bool = this._matchSelector(leaf, node, opt).has(node);\n        if (!bool) {\n          break;\n        }\n      }\n      if (cacheable) {\n        if (!result) {\n          result = new WeakMap();\n        }\n        result.set(node, {\n          matched: bool\n        });\n        if (this.#invalidate) {\n          this.#invalidateResults.set(leaves, result);\n        } else {\n          this.#results.set(leaves, result);\n        }\n      }\n      return bool;\n    }\n  }\n\n  /**\n   * find descendant nodes\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node or Element.shadowRoot\n   * @param {object} opt - options\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode, opt) {\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const nodes = new Set();\n    let pending = false;\n    if (this.#shadow || baseNode.nodeType !== ELEMENT_NODE) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case PS_ELEMENT_SELECTOR: {\n          matchPseudoElementSelector(leafName, leafType, opt);\n          break;\n        }\n        case ID_SELECTOR: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node, opt);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    if (pending) {\n      const walker = this._createTreeWalker(baseNode);\n      let refNode = traverseNode(baseNode, walker);\n      refNode = walker.firstChild();\n      while (refNode) {\n        const bool = this._matchLeaves(leaves, refNode, opt);\n        if (bool) {\n          nodes.add(refNode);\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * match combinator\n   * @private\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { parentNode } = node;\n    const { dir } = opt;\n    const matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            let refNode = node.nextElementSibling;\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = refNode.nextElementSibling;\n            }\n          }\n          break;\n        }\n        case '>': {\n          let refNode = node.firstElementChild;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = refNode.nextElementSibling;\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const nodes = this._findDescendantNodes(leaves, node, opt);\n          if (nodes.size) {\n            return nodes;\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            let refNode = parentNode.firstElementChild;\n            while (refNode) {\n              if (refNode === node) {\n                break;\n              } else {\n                const bool = this._matchLeaves(leaves, refNode, opt);\n                if (bool) {\n                  matched.add(refNode);\n                }\n              }\n              refNode = refNode.nextElementSibling;\n            }\n          }\n          break;\n        }\n        case '>': {\n          if (parentNode) {\n            const bool = this._matchLeaves(leaves, parentNode, opt);\n            if (bool) {\n              matched.add(parentNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            return new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node(s) from #qswalker\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node to start from\n   * @param {object} opt - options\n   * @param {boolean} [opt.force] - traverse only to next node\n   * @param {string} [opt.targetType] - target type\n   * @returns {?object|Array.<object>} - matched node / collection of nodes\n   */\n  _findWalker(leaves, node, opt = {}) {\n    const { force, targetType } = opt;\n    const walker = this.#qswalker;\n    const nodes = [];\n    let refNode = traverseNode(node, walker, !!force);\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = walker.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = walker.nextNode();\n        }\n      }\n      while (refNode) {\n        const matched = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (matched) {\n          nodes.push(refNode);\n          if (targetType !== TARGET_ALL) {\n            break;\n          }\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * match self\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _matchSelf(leaves) {\n    const nodes = [];\n    let filtered = false;\n    const bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find lineal\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @param {object} opt - options\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findLineal(leaves, opt) {\n    const { complex } = opt;\n    const nodes = [];\n    let filtered = false;\n    let bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    if (!bool || complex) {\n      let refNode = this.#node.parentNode;\n      while (refNode) {\n        bool = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (bool) {\n          nodes.push(refNode);\n          filtered = true;\n        }\n        if (refNode.parentNode) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find entry nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @param {boolean} complex - complex selector\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType, complex) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { name: leafName, type: leafType } = leaf;\n    let nodes = [];\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case PS_ELEMENT_SELECTOR: {\n        matchPseudoElementSelector(leafName, leafType, {\n          warn: this.#warn\n        });\n        break;\n      }\n      case ID_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST &&\n                   this.#root.nodeType !== ELEMENT_NODE) {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType,\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case CLASS_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case TYPE_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL &&\n            (leafName === 'host' || leafName === 'host-context')) {\n          let shadowRoot;\n          if (this.#shadow &&\n              this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            shadowRoot = this._matchShadowHostPseudoClass(leaf, this.#node);\n          } else if (compound && this.#node.nodeType === ELEMENT_NODE) {\n            shadowRoot =\n              this._matchShadowHostPseudoClass(leaf, this.#node.shadowRoot);\n          }\n          if (shadowRoot) {\n            let bool;\n            if (compound) {\n              for (const item of filterLeaves) {\n                if (/^host(?:-context)?$/.test(item.name)) {\n                  const node =\n                    this._matchShadowHostPseudoClass(item, shadowRoot);\n                  bool = node === shadowRoot;\n                } else if (item.name === 'has') {\n                  bool = this._matchPseudoClassSelector(item, shadowRoot, {})\n                    .has(shadowRoot);\n                } else {\n                  bool = false;\n                }\n                if (!bool) {\n                  break;\n                }\n              }\n            } else {\n              bool = true;\n            }\n            if (bool) {\n              nodes.push(shadowRoot);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST) {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * collect nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const branchLen = branch.length;\n        const complex = branchLen > 1;\n        const firstTwig = branch[0];\n        let dir;\n        let twig;\n        if (complex) {\n          const {\n            combo: firstCombo,\n            leaves: [{\n              name: firstName,\n              type: firstType\n            }]\n          } = firstTwig;\n          const lastTwig = branch[branchLen - 1];\n          const {\n            leaves: [{\n              name: lastName,\n              type: lastType\n            }]\n          } = lastTwig;\n          dir = DIR_NEXT;\n          twig = firstTwig;\n          if (this.#selector.includes(':scope') ||\n              lastType === PS_ELEMENT_SELECTOR || lastType === ID_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (firstName === '*' && firstType === TYPE_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (lastName === '*' && lastType === TYPE_SELECTOR) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (branchLen === 2) {\n            const { name: comboName } = firstCombo;\n            if (comboName === '+' || comboName === '~') {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            }\n          }\n        } else {\n          dir = DIR_PREV;\n          twig = firstTwig;\n        }\n        const {\n          compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#qswalker;\n        } else {\n          node = this.#root;\n          walker = this._createTreeWalker(node);\n        }\n        let nextNode = traverseNode(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode, {\n                warn: this.#warn\n              });\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].push(nextNode);\n              }\n            }\n          }\n          if (nextNode !== walker.currentNode) {\n            nextNode = traverseNode(nextNode, walker);\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const complex = branch.length > 1;\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * get combined nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {object} nodes - collection of nodes\n   * @param {string} dir - direction\n   * @returns {Array.<object>} - collection of matched nodes\n   */\n  _getCombinedNodes(twig, nodes, dir) {\n    const arr = [];\n    for (const node of nodes) {\n      const matched = this._matchCombinator(twig, node, {\n        dir,\n        warn: this.#warn\n      });\n      if (matched.size) {\n        arr.push(...matched);\n      }\n    }\n    if (arr.length) {\n      return new Set(arr);\n    }\n    return new Set();\n  }\n\n  /**\n   * match node to next direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {Set.<object>} nodes - collection of Element node\n   * @param {object} opt - option\n   * @param {object} opt.combo - combo\n   * @returns {?object} - matched node\n   */\n  _matchNodeNext(branch, nodes, opt) {\n    const { combo, index } = opt;\n    const { combo: nextCombo, leaves } = branch[index];\n    const twig = {\n      combo,\n      leaves\n    };\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_NEXT);\n    if (nextNodes.size) {\n      if (index === branch.length - 1) {\n        const [nextNode] = sortNodes(nextNodes);\n        return nextNode;\n      } else {\n        return this._matchNodeNext(branch, nextNodes, {\n          combo: nextCombo,\n          index: index + 1\n        });\n      }\n    }\n    return null;\n  }\n\n  /**\n   * match node to previous direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @param {number} opt.index - index\n   * @returns {?object} - node\n   */\n  _matchNodePrev(branch, node, opt) {\n    const { index } = opt;\n    const twig = branch[index];\n    const nodes = new Set([node]);\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_PREV);\n    if (nextNodes.size) {\n      if (index === 0) {\n        return node;\n      } else {\n        let matched;\n        for (const nextNode of nextNodes) {\n          matched = this._matchNodePrev(branch, nextNode, {\n            index: index - 1\n          });\n          if (matched) {\n            break;\n          }\n        }\n        if (matched) {\n          return node;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * find matched nodes\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  find(targetType) {\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      this._prepareQuerySelectorWalker();\n    }\n    const [[...branches], collectedNodes] = this._collectNodes(targetType);\n    const l = branches.length;\n    let sort;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, dir, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = collectedNodes[i];\n        const entryNodesLen = entryNodes.length;\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              if (node !== this.#node && this.#node.contains(node)) {\n                nodes.add(node);\n                if (targetType === TARGET_FIRST) {\n                  break;\n                }\n              }\n            }\n          } else if (targetType === TARGET_ALL) {\n            if (nodes.size) {\n              const n = [...nodes];\n              nodes = new Set([...n, ...entryNodes]);\n              sort = true;\n            } else {\n              nodes = new Set(entryNodes);\n            }\n          } else {\n            const [node] = entryNodes;\n            nodes.add(node);\n          }\n        } else if (targetType === TARGET_ALL) {\n          if (dir === DIR_NEXT) {\n            const { combo: firstCombo } = branch[0];\n            let combo = firstCombo;\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const twig = {\n                  combo,\n                  leaves\n                };\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === lastIndex) {\n                    if (nodes.size) {\n                      const n = [...nodes];\n                      nodes = new Set([...n, ...nextNodes]);\n                      sort = true;\n                      combo = firstCombo;\n                    } else {\n                      nodes = nextNodes;\n                      combo = firstCombo;\n                    }\n                  } else {\n                    combo = nextCombo;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          } else {\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === 0) {\n                    nodes.add(node);\n                    if (branchLen > 1 && nodes.size > 1) {\n                      sort = true;\n                    }\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        } else if (targetType === TARGET_FIRST && dir === DIR_NEXT) {\n          const { combo: entryCombo } = branch[0];\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodeNext(branch, new Set([node]), {\n              combo: entryCombo,\n              index: 1\n            });\n            if (matched) {\n              nodes.add(matched);\n              break;\n            }\n          }\n          if (!matched) {\n            const { leaves: entryLeaves } = branch[0];\n            const [entryNode] = entryNodes;\n            let [refNode] =\n              this._findWalker(entryLeaves, entryNode, {\n                targetType\n              });\n            while (refNode) {\n              matched = this._matchNodeNext(branch, new Set([refNode]), {\n                combo: entryCombo,\n                index: 1\n              });\n              if (matched) {\n                nodes.add(matched);\n                break;\n              }\n              [refNode] = this._findWalker(entryLeaves, refNode, {\n                targetType,\n                force: true\n              });\n            }\n          }\n        } else {\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodePrev(branch, node, {\n              index: lastIndex - 1\n            });\n            if (matched) {\n              nodes.add(node);\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const { leaves: entryLeaves } = branch[lastIndex];\n            const [entryNode] = entryNodes;\n            let [refNode] = this._findWalker(entryLeaves, entryNode, {\n              targetType\n            });\n            while (refNode) {\n              matched = this._matchNodePrev(branch, refNode, {\n                index: lastIndex - 1\n              });\n              if (matched) {\n                nodes.add(refNode);\n                break;\n              }\n              [refNode] = this._findWalker(entryLeaves, refNode, {\n                targetType,\n                force: true\n              });\n            }\n          }\n        }\n      }\n    }\n    if (targetType === TARGET_FIRST) {\n      nodes.delete(this.#node);\n      if (nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    } else if (targetType === TARGET_ALL) {\n      nodes.delete(this.#node);\n      if (sort && nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    }\n    return nodes;\n  }\n}\n"],
  "mappings": "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",
  "names": ["finder_exports", "__export", "Finder", "__toCommonJS", "import_matcher", "import_parser", "import_utility", "import_constant", "DIR_NEXT", "DIR_PREV", "#ast", "#astCache", "#descendant", "#document", "#documentCache", "#event", "#focus", "#invalidate", "#invalidateResults", "#lastFocusVisible", "#node", "#nodes", "#noexcept", "#qswalker", "#results", "#root", "#selector", "#shadow", "#verifyShadowHost", "#walkers", "#warn", "#window", "window", "e", "opt", "selector", "node", "noexcept", "warn", "func", "focusKeys", "key", "evt", "keyboardKeys", "mouseKeys", "nodes", "ast", "cachedItem", "item", "i", "cssAst", "branches", "info", "hasHasPseudoFunc", "hasLogicalPseudoFunc", "hasNthChildOfSelector", "hasStatePseudoClass", "invalidate", "descendant", "items", "branch", "leaves", "itemName", "nextItem", "force", "whatToShow", "walker", "anb", "a", "b", "reverse", "parentNode", "matched", "selectorBranches", "refNode", "selectorNodes", "l", "bool", "nth", "j", "m", "localName", "namespaceURI", "prefix", "itemLocalName", "itemNamespaceURI", "itemPrefix", "nthName", "nthIdentName", "anbMap", "astLeaves", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "astName", "twigBranches", "isShadowRoot", "invalid", "childAstType", "lastIndex", "nextNodes", "arr", "astChildren", "forgive", "css", "forgiven", "child", "nestedLeaf", "leavesSet", "res", "astChild", "stateValue", "prop", "href", "origin", "pathname", "attrURL", "target", "type", "buttons", "hash", "id", "current", "relatedTarget", "focusTarget", "eventKey", "eventTarget", "eventType", "disabled", "parent", "readonly", "writable", "placeholder", "targetNode", "attrType", "nodeName", "checked", "chekcKeys", "resetKeys", "submitKeys", "form", "nodeAttrType", "keys", "valid", "flowed", "node1", "node2", "host", "astType", "result", "cacheable", "formKeys", "pseudoKeys", "baseNode", "filterLeaves", "compound", "leafName", "pending", "comboName", "dir", "targetType", "filtered", "complex", "shadowRoot", "pendingItems", "branchLen", "firstTwig", "firstCombo", "firstName", "firstType", "lastTwig", "lastName", "lastType", "pendingItem", "index", "nextCombo", "collectedNodes", "sort", "find", "entryNodes", "entryNodesLen", "n", "entryCombo", "entryLeaves", "entryNode"]
}
