{
  "version": 3,
  "sources": ["../../../src/js/finder.js"],
  "sourcesContent": ["/**\n * finder.js\n */\n\n/* import */\nimport { Matcher } from './matcher.js';\nimport {\n  generateCSS, parseSelector, sortAST, unescapeSelector, walkAST\n} from './parser.js';\nimport {\n  isContentEditable, isCustomElement, isFocusVisible, isFocusable,\n  isInShadowTree, isVisible, resolveContent, sortNodes, traverseNode\n} from './utility.js';\n\n/* constants */\nimport {\n  ATTR_SELECTOR, BIT_01, CLASS_SELECTOR, COMBINATOR, DOCUMENT_FRAGMENT_NODE,\n  DOCUMENT_NODE, ELEMENT_NODE, EMPTY, ID_SELECTOR, NOT_SUPPORTED_ERR,\n  PS_CLASS_SELECTOR, PS_ELEMENT_SELECTOR, REG_INPUT_TYPE, REG_LOGICAL,\n  SHOW_ALL, SYNTAX_ERR, TARGET_ALL, TARGET_FIRST, TARGET_LINEAL, TARGET_SELF,\n  TEXT_NODE, TYPE_SELECTOR, WALKER_FILTER\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\nconst KEY_TAB = 'Tab';\nconst REG_ANCHOR = /^a(?:rea)?$/;\nconst REG_FORM_CTRL =\n  /^(?:button|fieldset|input|optgroup|option|select|textarea)$/;\nconst REG_FORM_VALID = /^(?:button|form|input|select|textarea)$/;\nconst REG_INTERACT = /^(?:details|dialog)$/;\nconst REG_SHADOW_HOST = /^host(?:-context)?$/;\nconst REG_TYPE_CHECK = /^(?:checkbox|radio)$/;\nconst REG_TYPE_RANGE = /^(?:date(?:time-local)?|month|number|range|time|week)$/;\nconst REG_TYPE_RESET = /^(?:button|reset)$/;\nconst REG_TYPE_SUBMIT = /^(?:image|submit)$/;\nconst REG_TYPE_TEXT = /^(?:email|number|password|search|tel|text|url)$/;\n\n/**\n * Finder\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: Array<Ast | undefined>\n * #nodes: Array<Nodes>\n * Ast: {\n *   branch: Array<Branch | undefined>,\n *   collected: boolean,\n *   dir: string | null,\n *   filtered: boolean,\n *   find: boolean\n * }\n * Branch: Array<Twig>\n * Twig: {\n *   combo: Leaf | null,\n *   leaves: Array<Leaf>\n * }\n * Leaf: {\n *   children: Array<Leaf | undefined> | null,\n *   loc: null,\n *   type: string\n * }\n * Nodes: Array<HTMLElement | undefined>\n */\nexport class Finder {\n  /* private fields */\n  #ast;\n  #astCache;\n  #descendant;\n  #document;\n  #documentCache;\n  #event;\n  #focus;\n  #invalidate;\n  #invalidateResults;\n  #matcher;\n  #node;\n  #nodes;\n  #noexcept;\n  #qswalker;\n  #results;\n  #root;\n  #shadow;\n  #walker;\n  #walkers;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   * @param {object} window - window\n   */\n  constructor(window) {\n    this.#window = window;\n    this.#matcher = new Matcher();\n    this.#astCache = new WeakMap();\n    this.#documentCache = new WeakMap();\n    this.#invalidateResults = new WeakMap();\n    this.#results = new WeakMap();\n    this.#event = null;\n    this.#focus = null;\n    this._registerEventListeners();\n  }\n\n  /**\n   * handle error\n   * @param {Error} e - Error\n   * @param {object} opt - options\n   * @throws Error\n   * @returns {void}\n   */\n  onError(e, opt = {}) {\n    const noexcept = opt.noexcept ?? this.#noexcept;\n    if (!noexcept) {\n      if (e instanceof DOMException ||\n          e instanceof this.#window.DOMException) {\n        if (e.name === NOT_SUPPORTED_ERR) {\n          if (this.#warn) {\n            console.warn(e.message);\n          }\n        } else {\n          throw new this.#window.DOMException(e.message, e.name);\n        }\n      } else if (e.name in this.#window) {\n        throw new this.#window[e.name](e.message);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * setup finder\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {object} [opt.event] - MouseEvent, KeyboardEvent\n   * @param {boolean} [opt.noexcept] - no exception\n   * @param {boolean} [opt.warn] - console warn\n   * @returns {object} - node\n   */\n  setup(selector, node, opt = {}) {\n    const { event, noexcept, warn } = opt;\n    this.#noexcept = !!noexcept;\n    this.#warn = !!warn;\n    this.#node = node;\n    [this.#document, this.#root, this.#walker] = resolveContent(node);\n    this.#shadow = isInShadowTree(node);\n    [this.#ast, this.#nodes] = this._correspond(selector);\n    this.#invalidateResults = new WeakMap();\n    this.#walkers = new WeakMap();\n    this._setEvent(event);\n    return node;\n  }\n\n  /**\n   * register event listeners\n   * @private\n   * @returns {Array.<void>} - results\n   */\n  _registerEventListeners() {\n    const opt = {\n      capture: true,\n      passive: true\n    };\n    const func = [];\n    const mouseKeys = ['mouseover', 'mousedown', 'mouseup', 'mouseout'];\n    for (const key of mouseKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#event = evt;\n      }, opt));\n    }\n    const keyboardKeys = ['keydown', 'keyup'];\n    for (const key of keyboardKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        if (evt.key === KEY_TAB) {\n          this.#event = evt;\n        }\n      }, opt));\n    }\n    func.push(this.#window.addEventListener('focusin', evt => {\n      this.#focus = evt;\n    }, opt));\n    return func;\n  }\n\n  /**\n   * set event\n   * @private\n   * @param {object} event - instance of KeyboardEvent, MouseEvent\n   * @returns {object} - event\n   */\n  _setEvent(event) {\n    // NOTE: PointerEvent not implemented in jsdom\n    if (event instanceof this.#window.KeyboardEvent ||\n        event instanceof this.#window.MouseEvent) {\n      this.#event = event;\n    }\n    return this.#event;\n  }\n\n  /**\n   * correspond ast and nodes\n   * @private\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of ast and nodes\n   */\n  _correspond(selector) {\n    const nodes = [];\n    this.#descendant = false;\n    this.#invalidate = false;\n    let ast;\n    if (this.#documentCache.has(this.#document)) {\n      const cachedItem = this.#documentCache.get(this.#document);\n      if (cachedItem && cachedItem.has(`${selector}`)) {\n        const item = cachedItem.get(`${selector}`);\n        ast = item.ast;\n        this.#descendant = item.descendant;\n        this.#invalidate = item.invalidate;\n      }\n    }\n    if (ast) {\n      const l = ast.length;\n      for (let i = 0; i < l; i++) {\n        ast[i].collected = false;\n        ast[i].dir = null;\n        ast[i].filtered = false;\n        ast[i].find = false;\n        nodes[i] = [];\n      }\n    } else {\n      let cssAst;\n      try {\n        cssAst = parseSelector(selector);\n      } catch (e) {\n        this.onError(e);\n      }\n      const { branches, info } = walkAST(cssAst);\n      const {\n        hasHasPseudoFunc, hasLogicalPseudoFunc, hasNthChildOfSelector\n      } = info;\n      let invalidate =\n        hasHasPseudoFunc || !!(hasLogicalPseudoFunc && hasNthChildOfSelector);\n      let descendant = false;\n      let i = 0;\n      ast = [];\n      for (const [...items] of branches) {\n        const branch = [];\n        let item = items.shift();\n        if (item && item.type !== COMBINATOR) {\n          const leaves = new Set();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              const [nextItem] = items;\n              if (nextItem.type === COMBINATOR) {\n                throw new DOMException(`Invalid selector ${selector}`,\n                  SYNTAX_ERR);\n              }\n              const itemName = item.name;\n              if (/^[\\s>]$/.test(itemName)) {\n                descendant = true;\n              } else {\n                invalidate = true;\n              }\n              branch.push({\n                combo: item,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n            } else if (item) {\n              let { name: itemName } = item;\n              if (itemName && typeof itemName === 'string') {\n                itemName = unescapeSelector(itemName);\n                if (typeof itemName === 'string' && itemName !== item.name) {\n                  item.name = itemName;\n                }\n                if (/[|:]/.test(itemName)) {\n                  item.namespace = true;\n                }\n              }\n              leaves.add(item);\n            }\n            if (items.length) {\n              item = items.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n              break;\n            }\n          }\n        }\n        ast.push({\n          branch,\n          collected: false,\n          dir: null,\n          filtered: false,\n          find: false\n        });\n        nodes[i] = [];\n        i++;\n      }\n      let cachedItem;\n      if (this.#documentCache.has(this.#document)) {\n        cachedItem = this.#documentCache.get(this.#document);\n      } else {\n        cachedItem = new Map();\n      }\n      cachedItem.set(`${selector}`, {\n        ast,\n        descendant,\n        invalidate\n      });\n      this.#documentCache.set(this.#document, cachedItem);\n      this.#descendant = descendant;\n      this.#invalidate = invalidate;\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * create tree walker\n   * @private\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @returns {object} - tree walker\n   */\n  _createTreeWalker(node) {\n    let walker;\n    if (this.#walkers.has(node)) {\n      walker = this.#walkers.get(node);\n    } else {\n      walker = this.#document.createTreeWalker(node, WALKER_FILTER);\n      this.#walkers.set(node, walker);\n    }\n    return walker;\n  }\n\n  /**\n   * prepare querySelector walker\n   * @private\n   * @returns {object} - tree walker\n   */\n  _prepareQuerySelectorWalker() {\n    this.#qswalker = this._createTreeWalker(this.#node);\n    return this.#qswalker;\n  }\n\n  /**\n   * collect nth child\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node, opt) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    const matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#astCache.has(selector)) {\n        selectorBranches = this.#astCache.get(selector);\n      } else {\n        const { branches } = walkAST(selector);\n        selectorBranches = branches;\n        if (!this.#invalidate) {\n          this.#astCache.set(selector, selectorBranches);\n        }\n      }\n      const { branches } = walkAST(selector);\n      selectorBranches = branches;\n    }\n    if (parentNode) {\n      const walker = this.#walker;\n      let refNode = traverseNode(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      const selectorNodes = new Set();\n      if (selectorBranches) {\n        refNode = traverseNode(parentNode, walker);\n        refNode = walker.firstChild();\n        while (refNode) {\n          if (isVisible(refNode)) {\n            let bool;\n            for (const leaves of selectorBranches) {\n              bool = this._matchLeaves(leaves, refNode, opt);\n              if (!bool) {\n                break;\n              }\n            }\n            if (bool) {\n              selectorNodes.add(refNode);\n            }\n          }\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, namespaceURI, parentNode, prefix } = node;\n    const matched = new Set();\n    if (parentNode) {\n      const walker = this.#walker;\n      let refNode = traverseNode(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = 0;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName, opt) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const anbMap = new Map();\n    if (nthIdentName) {\n      if (nthIdentName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (nthIdentName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    if (/^nth-(?:last-)?child$/.test(nthName)) {\n      if (selector) {\n        anbMap.set('selector', selector);\n      }\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthChild(anb, node, opt);\n      return nodes;\n    } else if (/^nth-(?:last-)?of-type$/.test(nthName)) {\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthOfType(anb, node);\n      return nodes;\n    }\n    return new Set();\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @private\n   * @param {Array.<object>} astLeaves - AST leaves\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(astLeaves, node, opt = {}) {\n    let bool;\n    if (Array.isArray(astLeaves) && astLeaves.length) {\n      const leaves = astLeaves.map(i => i);\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      opt.dir = DIR_NEXT;\n      const nodes = this._matchCombinator(twig, node, opt);\n      if (nodes.size) {\n        if (leaves.length) {\n          for (const nextNode of nodes) {\n            bool = this._matchHasPseudoFunc(leaves, nextNode, opt);\n            if (bool) {\n              break;\n            }\n          }\n        } else {\n          bool = true;\n        }\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @private\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node, opt = {}) {\n    const {\n      astName = '', branches = [], selector = '', twigBranches = []\n    } = astData;\n    let res;\n    if (astName === 'has') {\n      if (selector.includes(':has(')) {\n        res = null;\n      } else {\n        let bool;\n        for (const leaves of branches) {\n          bool = this._matchHasPseudoFunc(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else {\n      const forgive = /^(?:is|where)$/.test(astName);\n      opt.forgive = forgive;\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, opt);\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            opt.dir = DIR_PREV;\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, opt);\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (!bool) {\n          res = node;\n        }\n      } else if (bool) {\n        res = node;\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @private\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive unknown pseudo-class\n   * @param {boolean} [opt.warn] - warn unsupported pseudo-class\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt = {}) {\n    const { children: astChildren, name: astName } = ast;\n    const { localName, parentNode } = node;\n    const {\n      forgive,\n      warn = this.#warn\n    } = opt;\n    const matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (REG_LOGICAL.test(astName)) {\n      let astData;\n      if (this.#astCache.has(ast)) {\n        astData = this.#astCache.get(ast);\n      } else {\n        const { branches } = walkAST(ast);\n        const selectors = [];\n        const twigBranches = [];\n        for (const [...leaves] of branches) {\n          for (const leaf of leaves) {\n            const css = generateCSS(leaf);\n            selectors.push(css);\n          }\n          const branch = [];\n          const leavesSet = new Set();\n          let item = leaves.shift();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              branch.push({\n                combo: item,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n            } else if (item) {\n              leavesSet.add(item);\n            }\n            if (leaves.length) {\n              item = leaves.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n              break;\n            }\n          }\n          twigBranches.push(branch);\n        }\n        astData = {\n          astName,\n          branches,\n          twigBranches,\n          selector: selectors.join(',')\n        };\n        if (!this.#invalidate) {\n          this.#astCache.set(ast, astData);\n        }\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node, opt);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        const [branch] = astChildren;\n        const nodes = this._matchAnPlusB(branch, node, astName, opt);\n        return nodes;\n      } else {\n        switch (astName) {\n          // :dir(), :lang()\n          case 'dir':\n          case 'lang': {\n            const res = this.#matcher.matchSelector(ast, node, opt, true);\n            if (res) {\n              matched.add(res);\n            }\n            break;\n          }\n          // :state()\n          case 'state': {\n            if (isCustomElement(node)) {\n              const [{ value: stateValue }] = astChildren;\n              if (stateValue) {\n                if (node[stateValue]) {\n                  matched.add(node);\n                } else {\n                  for (const i in node) {\n                    const prop = node[i];\n                    if (prop instanceof this.#window.ElementInternals) {\n                      if (prop?.states?.has(stateValue)) {\n                        matched.add(node);\n                      }\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            break;\n          }\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          // dropped from CSS Selectors 3\n          case 'contains': {\n            if (warn) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          default: {\n            if (!forgive) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if (REG_ANCHOR.test(localName) && node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if (REG_ANCHOR.test(localName) && node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#document.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'hover': {\n          const { target, type } = this.#event ?? {};\n          if (/^(?:mouse|pointer)(?:down|over|up)$/.test(type) &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'active': {\n          const { buttons, target, type } = this.#event ?? {};\n          if (/(?:mouse|pointer)down/.test(type) && buttons & BIT_01 &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#document.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#document.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#document.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#document.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (!this.#shadow && node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === this.#document.activeElement && node.tabIndex >= 0 &&\n              isFocusable(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-visible': {\n          if (node === this.#document.activeElement && node.tabIndex >= 0) {\n            let bool;\n            if (isFocusVisible(node)) {\n              bool = true;\n            } else {\n              const { target: eventTarget, type } = this.#event ?? {};\n              const { target: focusTarget, relatedTarget } = this.#focus ?? {};\n              if (/^key(?:down|up)$/.test(type) && node.contains(eventTarget)) {\n                bool = true;\n              } else if (relatedTarget && isFocusVisible(relatedTarget) &&\n                         node.contains(focusTarget)) {\n                bool = true;\n              }\n            }\n            if (bool && isFocusable(node)) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'focus-within': {\n          let bool;\n          let current = this.#document.activeElement;\n          if (current.tabIndex >= 0) {\n            while (current) {\n              if (current === node) {\n                bool = true;\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          if (bool && isFocusable(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'open': {\n          if (REG_INTERACT.test(localName) && node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'closed': {\n          if (REG_INTERACT.test(localName) && !node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'disabled': {\n          if (REG_FORM_CTRL.test(localName) ||\n              isCustomElement(node, { formAssociated: true })) {\n            if (node.disabled || node.hasAttribute('disabled')) {\n              matched.add(node);\n            } else if (node.localName === 'option') {\n              if (parentNode.localName === 'optgroup' &&\n                  (parentNode.disabled ||\n                   parentNode.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n            } else if (node.localName !== 'optgroup') {\n              let bool;\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset' &&\n                    (parent.disabled || parent.hasAttribute('disabled'))) {\n                  const walker = this.#walker;\n                  let refNode = traverseNode(parent, walker);\n                  refNode = walker.firstChild();\n                  while (refNode) {\n                    if (refNode.localName === 'legend') {\n                      break;\n                    }\n                    refNode = walker.nextSibling();\n                  }\n                  if (refNode) {\n                    if (!refNode.contains(node)) {\n                      bool = true;\n                    }\n                  } else {\n                    bool = true;\n                  }\n                  break;\n                } else if (parent.localName === 'form') {\n                  break;\n                } else if (parent.parentNode?.nodeType === ELEMENT_NODE) {\n                  if (parent.parentNode.localName === 'form') {\n                    break;\n                  } else {\n                    parent = parent.parentNode;\n                  }\n                } else {\n                  break;\n                }\n              }\n              if (bool) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'enabled': {\n          if ((REG_FORM_CTRL.test(localName) ||\n               isCustomElement(node, { formAssociated: true })) &&\n              !(node.disabled && node.hasAttribute('disabled'))) {\n            if (node.localName === 'optgroup') {\n              matched.add(node);\n            } else if (node.localName === 'option') {\n              if (parentNode.localName !== 'optgroup' ||\n                  !(parentNode.disabled ||\n                    parentNode.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n            } else {\n              let bool;\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset' &&\n                    (parent.disabled || parent.hasAttribute('disabled'))) {\n                  const walker = this.#walker;\n                  let refNode = traverseNode(parent, walker);\n                  refNode = walker.firstChild();\n                  while (refNode) {\n                    if (refNode.localName === 'legend') {\n                      break;\n                    }\n                    refNode = walker.nextSibling();\n                  }\n                  if (refNode) {\n                    if (!refNode.contains(node)) {\n                      bool = true;\n                    }\n                  } else {\n                    bool = true;\n                  }\n                  break;\n                } else if (parent.localName === 'form') {\n                  break;\n                } else if (parent.parentNode?.nodeType === ELEMENT_NODE) {\n                  if (parent.parentNode.localName === 'form') {\n                    break;\n                  } else {\n                    parent = parent.parentNode;\n                  }\n                } else {\n                  break;\n                }\n              }\n              if (!bool) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'read-only': {\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || REG_INPUT_TYPE.test(node.type)) &&\n                  (node.readonly || node.hasAttribute('readonly') ||\n                   node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (!isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'read-write': {\n          switch (localName) {\n            case 'textarea': {\n              if (!(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || REG_INPUT_TYPE.test(node.type)) &&\n                  !(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let placeholder;\n          if (node.placeholder) {\n            placeholder = node.placeholder;\n          } else if (node.hasAttribute('placeholder')) {\n            placeholder = node.getAttribute('placeholder');\n          }\n          if (typeof placeholder === 'string' && !/[\\r\\n]/.test(placeholder)) {\n            let targetNode;\n            if (localName === 'textarea') {\n              targetNode = node;\n            } else if (localName === 'input') {\n              if (node.hasAttribute('type')) {\n                if (REG_TYPE_TEXT.test(node.getAttribute('type'))) {\n                  targetNode = node;\n                }\n              } else {\n                targetNode = node;\n              }\n            }\n            if (targetNode && node.value === '') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'checked': {\n          if ((node.checked && localName === 'input' &&\n               node.hasAttribute('type') &&\n               REG_TYPE_CHECK.test(node.getAttribute('type'))) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#document.documentElement;\n            }\n            const items = parent.getElementsByTagName('input');\n            const l = items.length;\n            let checked;\n            for (let i = 0; i < l; i++) {\n              const item = items[i];\n              if (item.getAttribute('type') === 'radio') {\n                if (nodeName) {\n                  if (item.getAttribute('name') === nodeName) {\n                    checked = !!item.checked;\n                  }\n                } else if (!item.hasAttribute('name')) {\n                  checked = !!item.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') &&\n                 REG_TYPE_RESET.test(node.getAttribute('type')))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               REG_TYPE_SUBMIT.test(node.getAttribute('type')))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker = this.#walker;\n              let nextNode = traverseNode(form, walker);\n              nextNode = walker.firstChild();\n              while (nextNode && form.contains(nextNode)) {\n                const nodeName = nextNode.localName;\n                let m;\n                if (nodeName === 'button') {\n                  m = !(nextNode.hasAttribute('type') &&\n                    REG_TYPE_RESET.test(nextNode.getAttribute('type')));\n                } else if (nodeName === 'input') {\n                  m = nextNode.hasAttribute('type') &&\n                    REG_TYPE_SUBMIT.test(nextNode.getAttribute('type'));\n                }\n                if (m) {\n                  if (nextNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                nextNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     REG_TYPE_CHECK.test(node.getAttribute('type')) &&\n                     node.hasAttribute('checked')) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option' && node.hasAttribute('selected')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'valid': {\n          if (REG_FORM_VALID.test(localName)) {\n            if (node.checkValidity()) {\n              if (node.maxLength >= 0) {\n                if (node.maxLength >= node.value.length) {\n                  matched.add(node);\n                }\n              } else {\n                matched.add(node);\n              }\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this.#walker;\n            let refNode = traverseNode(node, walker);\n            refNode = walker.firstChild();\n            let bool;\n            if (!refNode) {\n              bool = true;\n            } else {\n              while (refNode && node.contains(refNode)) {\n                if (REG_FORM_VALID.test(refNode.localName)) {\n                  if (refNode.checkValidity()) {\n                    if (refNode.maxLength >= 0) {\n                      bool = refNode.maxLength >= refNode.value.length;\n                    } else {\n                      bool = true;\n                    }\n                  } else {\n                    bool = false;\n                  }\n                  if (!bool) {\n                    break;\n                  }\n                }\n                refNode = walker.nextNode();\n              }\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'invalid': {\n          if (REG_FORM_VALID.test(localName)) {\n            if (node.checkValidity()) {\n              if (node.maxLength >= 0 && node.maxLength < node.value.length) {\n                matched.add(node);\n              }\n            } else {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this.#walker;\n            let refNode = traverseNode(node, walker);\n            refNode = walker.firstChild();\n            let bool;\n            if (!refNode) {\n              bool = true;\n            } else {\n              while (refNode && node.contains(refNode)) {\n                if (REG_FORM_VALID.test(refNode.localName)) {\n                  if (refNode.checkValidity()) {\n                    if (refNode.maxLength >= 0) {\n                      bool = refNode.maxLength >= refNode.value.length;\n                    } else {\n                      bool = true;\n                    }\n                  } else {\n                    bool = false;\n                  }\n                  if (!bool) {\n                    break;\n                  }\n                }\n                refNode = walker.nextNode();\n              }\n            }\n            if (!bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              REG_TYPE_RANGE.test(node.getAttribute('type')) &&\n              !(node.validity.rangeUnderflow ||\n                node.validity.rangeOverflow) &&\n              (node.hasAttribute('min') || node.hasAttribute('max') ||\n               node.getAttribute('type') === 'range')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'out-of-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              REG_TYPE_RANGE.test(node.getAttribute('type')) &&\n              (node.validity.rangeUnderflow || node.validity.rangeOverflow)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'required': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || REG_TYPE_CHECK.test(inputType) ||\n                  REG_INPUT_TYPE.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              (node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'optional': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || REG_TYPE_CHECK.test(inputType) ||\n                  REG_INPUT_TYPE.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              !(node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            const walker = this.#document.createTreeWalker(node, SHOW_ALL);\n            let refNode = walker.firstChild();\n            let bool;\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode && node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) || node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'defined': {\n          if (node.hasAttribute('is') || localName.includes('-')) {\n            if (isCustomElement(node)) {\n              matched.add(node);\n            }\n          // NOTE: MathMLElement not implemented in jsdom\n          } else if (node instanceof this.#window.HTMLElement ||\n                     node instanceof this.#window.SVGElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'popover-open': {\n          if (node.popover && isVisible(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        // not supported\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'fullscreen':\n        case 'future':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-class :${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}`,\n                NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            throw new DOMException(`Unknown pseudo-class :${astName}`,\n              SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match shadow host pseudo class\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren, name: astName } = ast;\n    let res;\n    if (Array.isArray(astChildren)) {\n      const { branches } = walkAST(astChildren[0]);\n      const [branch] = branches;\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      } else if (astName === 'host-context') {\n        let parent = host;\n        let bool;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else if (astName === 'host') {\n      res = node;\n    } else {\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt) {\n    const { type: astType } = ast;\n    const matched = new Set();\n    if (ast.name === EMPTY) {\n      return matched;\n    }\n    const astName = unescapeSelector(ast.name);\n    if (typeof astName === 'string' && astName !== ast.name) {\n      ast.name = astName;\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case PS_ELEMENT_SELECTOR: {\n          this.#matcher.matchPseudoElementSelector(astName, opt);\n          break;\n        }\n        case ID_SELECTOR: {\n          if (node.id === astName) {\n            matched.add(node);\n          }\n          break;\n        }\n        case CLASS_SELECTOR: {\n          if (node.classList.contains(astName)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_CLASS_SELECTOR: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          return nodes;\n        }\n        default: {\n          const res = this.#matcher.matchSelector(ast, node, opt, true);\n          if (res) {\n            matched.add(res);\n          }\n        }\n      }\n    } else if (this.#shadow && astType === PS_CLASS_SELECTOR &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (astName !== 'has' && REG_LOGICAL.test(astName)) {\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        return nodes;\n      } else if (REG_SHADOW_HOST.test(astName)) {\n        const res = this._matchShadowHostPseudoClass(ast, node, opt);\n        if (res) {\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let bool;\n    let result;\n    if (this.#invalidate) {\n      result = this.#invalidateResults.get(leaves);\n    } else {\n      result = this.#results.get(leaves);\n    }\n    if (result && result.has(node)) {\n      const { matched } = result.get(node);\n      bool = matched;\n    }\n    if (typeof bool !== 'boolean') {\n      let cacheable = true;\n      if (node.nodeType === ELEMENT_NODE &&\n          /^(?:button|fieldset|form|input|select|textarea)$/.test(node.localName)) {\n        cacheable = false;\n      }\n      for (const leaf of leaves) {\n        switch (leaf.type) {\n          case ATTR_SELECTOR:\n          case ID_SELECTOR: {\n            cacheable = false;\n            break;\n          }\n          case PS_CLASS_SELECTOR: {\n            if (/^(?:(?:any-)?link|defined|dir)$/.test(leaf.name)) {\n              cacheable = false;\n            }\n            break;\n          }\n          default:\n        }\n        bool = this._matchSelector(leaf, node, opt).has(node);\n        if (!bool) {\n          break;\n        }\n      }\n      if (cacheable) {\n        if (!result) {\n          result = new WeakMap();\n        }\n        result.set(node, {\n          matched: bool\n        });\n        if (this.#invalidate) {\n          this.#invalidateResults.set(leaves, result);\n        } else {\n          this.#results.set(leaves, result);\n        }\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match HTML collection\n   * @private\n   * @param {object} items - HTML collection\n   * @param {object} opt - options\n   * @returns {Set.<object>} - matched nodes\n   */\n  _matchHTMLCollection(items, opt = {}) {\n    const { compound, filterLeaves } = opt;\n    const nodes = new Set();\n    const l = items.length;\n    if (l) {\n      if (compound) {\n        for (let i = 0; i < l; i++) {\n          const item = items[i];\n          const bool = this._matchLeaves(filterLeaves, item, opt);\n          if (bool) {\n            nodes.add(item);\n          }\n        }\n      } else {\n        const arr = [].slice.call(items);\n        return new Set(arr);\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * find descendant nodes\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node\n   * @param {object} opt - options\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode, opt) {\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    if (typeof leafName === 'string' && leafName !== leaf.name) {\n      leaf.name = leafName;\n    }\n    let nodes = new Set();\n    let pending = false;\n    if (this.#shadow) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case PS_ELEMENT_SELECTOR: {\n          this.#matcher.matchPseudoElementSelector(leafName, opt);\n          break;\n        }\n        case ID_SELECTOR: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node, opt);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case CLASS_SELECTOR: {\n          const items = baseNode.getElementsByClassName(leafName);\n          nodes = this._matchHTMLCollection(items, {\n            compound,\n            filterLeaves\n          });\n          break;\n        }\n        case TYPE_SELECTOR: {\n          if (this.#document.contentType === 'text/html' &&\n              !/[*|]/.test(leafName)) {\n            const items = baseNode.getElementsByTagName(leafName);\n            nodes = this._matchHTMLCollection(items, {\n              compound,\n              filterLeaves\n            });\n          } else {\n            pending = true;\n          }\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    return {\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * match combinator\n   * @private\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt = {}) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { parentNode } = node;\n    const { dir } = opt;\n    const matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            const walker = this._createTreeWalker(parentNode);\n            let refNode = traverseNode(node, walker);\n            refNode = walker.nextSibling();\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextSibling();\n            }\n          }\n          break;\n        }\n        case '>': {\n          const walker = this._createTreeWalker(node);\n          let refNode = traverseNode(node, walker);\n          refNode = walker.firstChild();\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = walker.nextSibling();\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const { nodes, pending } = this._findDescendantNodes(leaves, node);\n          if (nodes.size) {\n            return nodes;\n          }\n          if (pending) {\n            const walker = this._createTreeWalker(node);\n            let refNode = traverseNode(node, walker);\n            refNode = walker.nextNode();\n            while (refNode && node.contains(refNode)) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextNode();\n            }\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            const walker = this._createTreeWalker(parentNode);\n            let refNode = traverseNode(parentNode, walker);\n            refNode = walker.firstChild();\n            while (refNode) {\n              if (refNode === node) {\n                break;\n              } else {\n                const bool = this._matchLeaves(leaves, refNode, opt);\n                if (bool) {\n                  matched.add(refNode);\n                }\n              }\n              refNode = walker.nextSibling();\n            }\n          }\n          break;\n        }\n        case '>': {\n          if (parentNode) {\n            const bool = this._matchLeaves(leaves, parentNode, opt);\n            if (bool) {\n              matched.add(parentNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            return new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node from #qswalker\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} [opt] - options\n   * @param {object} [opt.node] - node to start from\n   * @returns {?object} - matched node\n   */\n  _findNode(leaves, opt) {\n    const { node } = opt;\n    const walker = this.#qswalker;\n    let refNode = traverseNode(node, walker);\n    let matchedNode;\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = walker.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = walker.nextNode();\n        }\n      }\n      while (refNode) {\n        const matched = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (matched) {\n          matchedNode = refNode;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return matchedNode ?? null;\n  }\n\n  /**\n   * match self\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _matchSelf(leaves) {\n    const nodes = [];\n    const bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    let filtered = false;\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find lineal\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @param {object} opt - options\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findLineal(leaves, opt = {}) {\n    const { complex } = opt;\n    const nodes = [];\n    let bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    let filtered = false;\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    if (!bool || complex) {\n      let refNode = this.#node.parentNode;\n      while (refNode) {\n        bool = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (bool) {\n          nodes.push(refNode);\n          filtered = true;\n        }\n        if (refNode.parentNode) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find first\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findFirst(leaves) {\n    const nodes = [];\n    const node = this._findNode(leaves, {\n      node: this.#node\n    });\n    let filtered = false;\n    if (node) {\n      nodes.push(node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find from HTML collection\n   * @private\n   * @param {object} items - HTML collection\n   * @param {object} opt - options\n   * @param {boolean} [opt.compound] - compound selector\n   * @param {Array} [opt.filterLeaves] - filter leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findFromHTMLCollection(items, opt = {}) {\n    const { complex, compound, filterLeaves, targetType } = opt;\n    let nodes = [];\n    let filtered = false;\n    let collected = false;\n    const l = items.length;\n    if (l) {\n      if (this.#node.nodeType === ELEMENT_NODE) {\n        for (let i = 0; i < l; i++) {\n          const node = items[i];\n          if (node !== this.#node &&\n              (this.#node.contains(node) || node.contains(this.#node))) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n                if (targetType === TARGET_FIRST) {\n                  break;\n                }\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n              if (targetType === TARGET_FIRST) {\n                break;\n              }\n            }\n          }\n        }\n      } else if (complex) {\n        if (compound) {\n          for (let i = 0; i < l; i++) {\n            const node = items[i];\n            const bool = this._matchLeaves(filterLeaves, node, {\n              warn: this.#warn\n            });\n            if (bool) {\n              nodes.push(node);\n              filtered = true;\n              if (targetType === TARGET_FIRST) {\n                break;\n              }\n            }\n          }\n        } else {\n          nodes = [].slice.call(items);\n          filtered = true;\n          collected = true;\n        }\n      } else if (compound) {\n        for (let i = 0; i < l; i++) {\n          const node = items[i];\n          const bool = this._matchLeaves(filterLeaves, node, {\n            warn: this.#warn\n          });\n          if (bool) {\n            nodes.push(node);\n            filtered = true;\n            if (targetType === TARGET_FIRST) {\n              break;\n            }\n          }\n        }\n      } else {\n        nodes = [].slice.call(items);\n        filtered = true;\n        collected = true;\n      }\n    }\n    return [nodes, filtered, collected];\n  }\n\n  /**\n   * find entry nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @param {boolean} complex - complex selector\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType, complex) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { name: leafName, type: leafType } = leaf;\n    let nodes = [];\n    let collected = false;\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case PS_ELEMENT_SELECTOR: {\n        this.#matcher.matchPseudoElementSelector(leafName, {\n          warn: this.#warn\n        });\n        break;\n      }\n      case ID_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST &&\n                   this.#root.nodeType !== ELEMENT_NODE) {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      case CLASS_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (this.#root.nodeType === DOCUMENT_NODE) {\n          const items = this.#root.getElementsByClassName(leafName);\n          if (items.length) {\n            [nodes, filtered, collected] = this._findFromHTMLCollection(items, {\n              complex,\n              compound,\n              filterLeaves,\n              targetType\n            });\n          }\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      case TYPE_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (this.#document.contentType === 'text/html' &&\n                   this.#root.nodeType === DOCUMENT_NODE &&\n                   !/[*|]/.test(leafName)) {\n          const items = this.#root.getElementsByTagName(leafName);\n          if (items.length) {\n            [nodes, filtered, collected] = this._findFromHTMLCollection(items, {\n              complex,\n              compound,\n              filterLeaves,\n              targetType\n            });\n          }\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL && REG_SHADOW_HOST.test(leafName)) {\n          if (this.#shadow &&\n              this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            const node = this._matchShadowHostPseudoClass(leaf, this.#node);\n            if (node) {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      collected,\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * collect nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const branchLen = branch.length;\n        const complex = branchLen > 1;\n        const firstTwig = branch[0];\n        let dir;\n        let twig;\n        if (complex) {\n          const {\n            combo: firstCombo,\n            leaves: [{\n              name: firstName,\n              type: firstType\n            }]\n          } = firstTwig;\n          const lastTwig = branch[branchLen - 1];\n          const {\n            leaves: [{\n              name: lastName,\n              type: lastType\n            }]\n          } = lastTwig;\n          if (lastType === PS_ELEMENT_SELECTOR ||\n              lastType === ID_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (firstType === PS_ELEMENT_SELECTOR ||\n                     firstType === ID_SELECTOR) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (targetType === TARGET_ALL) {\n            if (firstName === '*' && firstType === TYPE_SELECTOR) {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            } else if (lastName === '*' && lastType === TYPE_SELECTOR) {\n              dir = DIR_NEXT;\n              twig = firstTwig;\n            } else if (branchLen === 2) {\n              const { name: comboName } = firstCombo;\n              if (/^[+~]$/.test(comboName)) {\n                dir = DIR_PREV;\n                twig = lastTwig;\n              } else {\n                dir = DIR_NEXT;\n                twig = firstTwig;\n              }\n            } else {\n              dir = DIR_NEXT;\n              twig = firstTwig;\n            }\n          } else if (lastName === '*' && lastType === TYPE_SELECTOR) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (firstName === '*' && firstType === TYPE_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else {\n            let bool;\n            for (const { combo, leaves: [leaf] } of branch) {\n              const { name: leafName, type: leafType } = leaf;\n              if (leafType === PS_CLASS_SELECTOR && leafName === 'dir') {\n                bool = false;\n                break;\n              }\n              if (!bool && combo) {\n                const { name: comboName } = combo;\n                if (/^[+~]$/.test(comboName)) {\n                  bool = true;\n                }\n              }\n            }\n            if (bool) {\n              dir = DIR_NEXT;\n              twig = firstTwig;\n            } else {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            }\n          }\n        } else {\n          dir = DIR_PREV;\n          twig = firstTwig;\n        }\n        const {\n          collected, compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].collected = collected;\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#qswalker;\n        } else {\n          node = this.#root;\n          walker = this.#walker;\n        }\n        let nextNode = traverseNode(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode, {\n                warn: this.#warn\n              });\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].push(nextNode);\n              }\n            }\n          }\n          if (nextNode !== walker.currentNode) {\n            nextNode = traverseNode(nextNode, walker);\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const complex = branch.length > 1;\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * get combined nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {object} nodes - collection of nodes\n   * @param {string} dir - direction\n   * @returns {Array.<object>} - collection of matched nodes\n   */\n  _getCombinedNodes(twig, nodes, dir) {\n    const arr = [];\n    for (const node of nodes) {\n      const matched = this._matchCombinator(twig, node, {\n        dir,\n        warn: this.#warn\n      });\n      if (matched.size) {\n        arr.push(...matched);\n      }\n    }\n    if (arr.length) {\n      return new Set(arr);\n    }\n    return new Set();\n  }\n\n  /**\n   * match node to next direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {Set.<object>} nodes - collection of Element node\n   * @param {object} opt - option\n   * @param {object} opt.combo - combo\n   * @returns {?object} - matched node\n   */\n  _matchNodeNext(branch, nodes, opt) {\n    const { combo, index } = opt;\n    const { combo: nextCombo, leaves } = branch[index];\n    const twig = {\n      combo,\n      leaves\n    };\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_NEXT);\n    let res;\n    if (nextNodes.size) {\n      if (index === branch.length - 1) {\n        const [nextNode] = sortNodes(nextNodes);\n        res = nextNode;\n      } else {\n        res = this._matchNodeNext(branch, nextNodes, {\n          combo: nextCombo,\n          index: index + 1\n        });\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match node to previous direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @param {number} opt.index - index\n   * @returns {?object} - node\n   */\n  _matchNodePrev(branch, node, opt) {\n    const { index } = opt;\n    const twig = branch[index];\n    const nodes = new Set([node]);\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_PREV);\n    let res;\n    if (nextNodes.size) {\n      if (index === 0) {\n        res = node;\n      } else {\n        for (const nextNode of nextNodes) {\n          const matched = this._matchNodePrev(branch, nextNode, {\n            index: index - 1\n          });\n          if (matched) {\n            return node;\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * find matched nodes\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  find(targetType) {\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      this._prepareQuerySelectorWalker();\n    }\n    const [[...branches], collectedNodes] = this._collectNodes(targetType);\n    const l = branches.length;\n    let sort;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, collected, dir, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = collectedNodes[i];\n        const entryNodesLen = entryNodes.length;\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              if (node !== this.#node && this.#node.contains(node)) {\n                nodes.add(node);\n                if (targetType !== TARGET_ALL) {\n                  break;\n                }\n              }\n            }\n          } else if (targetType === TARGET_ALL) {\n            if (nodes.size) {\n              const n = [...nodes];\n              nodes = new Set([...n, ...entryNodes]);\n              sort = true;\n            } else {\n              nodes = new Set(entryNodes);\n            }\n          } else {\n            const [node] = entryNodes;\n            nodes.add(node);\n          }\n        } else if (targetType === TARGET_ALL) {\n          if (dir === DIR_NEXT) {\n            let { combo } = branch[0];\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const twig = {\n                  combo,\n                  leaves\n                };\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === lastIndex) {\n                    if (nodes.size) {\n                      const n = [...nodes];\n                      nodes = new Set([...n, ...nextNodes]);\n                      sort = true;\n                    } else {\n                      nodes = nextNodes;\n                    }\n                  } else {\n                    combo = nextCombo;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          } else {\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === 0) {\n                    nodes.add(node);\n                    if (branchLen > 1 && nodes.size > 1) {\n                      sort = true;\n                    }\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        } else if (targetType === TARGET_FIRST && dir === DIR_NEXT) {\n          const { combo: entryCombo } = branch[0];\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodeNext(branch, new Set([node]), {\n              combo: entryCombo,\n              index: 1\n            });\n            if (matched) {\n              nodes.add(matched);\n              break;\n            }\n          }\n          if (!matched && !collected) {\n            const { leaves: entryLeaves } = branch[0];\n            const [entryNode] = entryNodes;\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode\n            });\n            while (refNode) {\n              matched = this._matchNodeNext(branch, new Set([refNode]), {\n                combo: entryCombo,\n                index: 1\n              });\n              if (matched) {\n                nodes.add(matched);\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode\n              });\n            }\n          }\n        } else {\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodePrev(branch, node, {\n              index: lastIndex - 1\n            });\n            if (matched) {\n              nodes.add(node);\n              break;\n            }\n          }\n          if (!matched && !collected && targetType === TARGET_FIRST) {\n            const { leaves: entryLeaves } = branch[lastIndex];\n            const [entryNode] = entryNodes;\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode\n            });\n            while (refNode) {\n              matched = this._matchNodePrev(branch, refNode, {\n                index: lastIndex - 1\n              });\n              if (matched) {\n                nodes.add(refNode);\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode\n              });\n            }\n          }\n        }\n      }\n    }\n    if (targetType === TARGET_FIRST) {\n      nodes.delete(this.#node);\n      if (nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    } else if (targetType === TARGET_ALL) {\n      nodes.delete(this.#node);\n      if (sort && nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    }\n    return nodes;\n  }\n};\n"],
  "mappings": "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",
  "names": ["finder_exports", "__export", "Finder", "__toCommonJS", "import_matcher", "import_parser", "import_utility", "import_constant", "DIR_NEXT", "DIR_PREV", "KEY_TAB", "REG_ANCHOR", "REG_FORM_CTRL", "REG_FORM_VALID", "REG_INTERACT", "REG_SHADOW_HOST", "REG_TYPE_CHECK", "REG_TYPE_RANGE", "REG_TYPE_RESET", "REG_TYPE_SUBMIT", "REG_TYPE_TEXT", "#ast", "#astCache", "#descendant", "#document", "#documentCache", "#event", "#focus", "#invalidate", "#invalidateResults", "#matcher", "#node", "#nodes", "#noexcept", "#qswalker", "#results", "#root", "#shadow", "#walker", "#walkers", "#warn", "#window", "window", "e", "opt", "selector", "node", "event", "noexcept", "warn", "func", "mouseKeys", "key", "evt", "keyboardKeys", "nodes", "ast", "cachedItem", "item", "l", "i", "cssAst", "branches", "info", "hasHasPseudoFunc", "hasLogicalPseudoFunc", "hasNthChildOfSelector", "invalidate", "descendant", "items", "branch", "leaves", "nextItem", "itemName", "walker", "anb", "a", "b", "reverse", "parentNode", "matched", "selectorBranches", "refNode", "selectorNodes", "bool", "nth", "j", "localName", "namespaceURI", "prefix", "itemLocalName", "itemNamespaceURI", "itemPrefix", "m", "nthName", "nthIdentName", "anbMap", "astLeaves", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "astName", "twigBranches", "res", "forgive", "lastIndex", "nextNodes", "arr", "astChildren", "selectors", "css", "leavesSet", "stateValue", "prop", "href", "origin", "pathname", "attrURL", "target", "type", "buttons", "hash", "id", "current", "eventTarget", "focusTarget", "relatedTarget", "parent", "placeholder", "targetNode", "nodeName", "checked", "form", "inputType", "node1", "node2", "host", "astType", "result", "cacheable", "compound", "filterLeaves", "baseNode", "leafName", "pending", "comboName", "dir", "matchedNode", "filtered", "complex", "targetType", "collected", "pendingItems", "branchLen", "firstTwig", "firstCombo", "firstName", "firstType", "lastTwig", "lastName", "lastType", "pendingItem", "index", "nextCombo", "collectedNodes", "sort", "find", "entryNodes", "entryNodesLen", "n", "entryCombo", "entryLeaves", "entryNode"]
}
