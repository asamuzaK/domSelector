{
  "version": 3,
  "sources": ["../../../src/js/finder.js"],
  "sourcesContent": ["/**\n * finder.js\n */\n\n/* import */\nimport isCustomElementName from 'is-potential-custom-element-name';\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport {\n  isContentEditable, isInShadowTree, resolveContent, sortNodes\n} from './dom-util.js';\nimport { matcher } from './matcher.js';\nimport {\n  filterSelector, generateCSS, parseSelector, sortAST, unescapeSelector, walkAST\n} from './parser.js';\n\n/* constants */\nimport {\n  BIT_01, COMBINATOR, DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, ELEMENT_NODE,\n  EMPTY, NOT_SUPPORTED_ERR, REG_LOGICAL_PSEUDO, REG_SHADOW_HOST, SELECTOR_CLASS,\n  SELECTOR_ID, SELECTOR_PSEUDO_CLASS, SELECTOR_PSEUDO_ELEMENT, SELECTOR_TYPE,\n  SHOW_ALL, SYNTAX_ERR, TEXT_NODE, WALKER_FILTER\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\nconst TARGET_ALL = 'all';\nconst TARGET_FIRST = 'first';\nconst TARGET_LINEAL = 'lineal';\nconst TARGET_SELF = 'self';\n\n/**\n * Finder\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: Array<Ast | undefined>\n * #nodes: Array<Nodes>\n * Ast: {\n *   branch: Array<Branch | undefined>,\n *   collected: boolean,\n *   dir: string | null,\n *   filtered: boolean,\n *   find: boolean\n * }\n * Branch: Array<Twig>\n * Twig: {\n *   combo: Leaf | null,\n *   leaves: Array<Leaf>\n * }\n * Leaf: {\n *   children: Array<Leaf | undefined> | null,\n *   loc: null,\n *   type: string\n * }\n * Nodes: Array<HTMLElement | undefined>\n */\nexport class Finder {\n  /* private fields */\n  #ast;\n  #cache;\n  #complex;\n  #content;\n  #descendant;\n  #document;\n  #event;\n  #node;\n  #nodes;\n  #noexcept;\n  #nwsapi;\n  #qswalker;\n  #results;\n  #root;\n  #shadow;\n  #sort;\n  #walker;\n  #walkers;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   * @param {object} window - window\n   */\n  constructor(window) {\n    this.#window = window;\n    this.#document = window.document;\n    this.#cache = new WeakMap();\n    this.#results = new WeakMap();\n    this.#nwsapi = nwsapi({\n      document: window.document,\n      DOMException: window.DOMException\n    });\n    this.#nwsapi.configure({\n      LOGERRORS: false\n    });\n  }\n\n  /**\n   * handle error\n   * @private\n   * @param {Error} e - Error\n   * @throws Error\n   * @returns {void}\n   */\n  _onError(e) {\n    if (!this.#noexcept) {\n      if (e instanceof DOMException ||\n          e instanceof this.#window.DOMException) {\n        if (e.name === NOT_SUPPORTED_ERR) {\n          if (this.#warn) {\n            console.warn(e.message);\n          }\n        } else {\n          throw new this.#window.DOMException(e.message, e.name);\n        }\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * setup finder\n   * @private\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {object} [opt.event] - MouseEvent, KeyboardEvent\n   * @param {boolean} [opt.noexcept] - no exception\n   * @param {boolean} [opt.warn] - console warn\n   * @returns {object} - node\n   */\n  _setup(selector, node, opt = {}) {\n    const { event, noexcept, warn } = opt;\n    this.#noexcept = !!noexcept;\n    this.#warn = !!warn;\n    this.#event = this._setEvent(event);\n    this.#node = node;\n    [this.#content, this.#root, this.#walker] = resolveContent(node);\n    this.#shadow = isInShadowTree(node);\n    [this.#ast, this.#nodes] = this._correspond(selector);\n    this.#walkers = new WeakMap();\n    return node;\n  }\n\n  /**\n   * set event\n   * @private\n   * @param {object} event - instance of MouseEvent, KeyboardEvent\n   * @returns {object} - result\n   */\n  _setEvent(event) {\n    return (event instanceof this.#window.MouseEvent ||\n            event instanceof this.#window.KeyboardEvent)\n      ? event\n      : null;\n  }\n\n  /**\n   * correspond ast and nodes\n   * @private\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of ast and nodes\n   */\n  _correspond(selector) {\n    const nodes = [];\n    this.#complex = false;\n    this.#descendant = false;\n    let ast;\n    if (this.#content) {\n      const cachedItem = this.#cache.get(this.#content);\n      if (cachedItem && cachedItem.has(`${selector}`)) {\n        const item = cachedItem.get(`${selector}`);\n        this.#complex = item.complex;\n        this.#descendant = item.descendant;\n        ast = item.ast;\n      }\n    }\n    if (ast) {\n      const l = ast.length;\n      for (let i = 0; i < l; i++) {\n        ast[i].collected = false;\n        ast[i].dir = null;\n        ast[i].filtered = false;\n        ast[i].find = false;\n        nodes[i] = [];\n      }\n    } else {\n      let cssAst;\n      try {\n        cssAst = parseSelector(selector);\n      } catch (e) {\n        this._onError(e);\n      }\n      const { branches, complex } = walkAST(cssAst, true);\n      let descendant = false;\n      let i = 0;\n      ast = [];\n      for (const [...items] of branches) {\n        const branch = [];\n        let item = items.shift();\n        if (item && item.type !== COMBINATOR) {\n          const leaves = new Set();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              const [nextItem] = items;\n              if (nextItem.type === COMBINATOR) {\n                const msg = `Invalid selector ${selector}`;\n                throw new DOMException(msg, SYNTAX_ERR);\n              }\n              const itemName = item.name;\n              if (/^[\\s>]$/.test(itemName)) {\n                descendant = true;\n              }\n              branch.push({\n                combo: item,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n            } else if (item) {\n              let { name: itemName } = item;\n              if (itemName && typeof itemName === 'string') {\n                itemName = unescapeSelector(itemName);\n                if (typeof itemName === 'string' && itemName !== item.name) {\n                  item.name = itemName;\n                }\n                if (/[|:]/.test(itemName)) {\n                  item.namespace = true;\n                }\n              }\n              leaves.add(item);\n            }\n            if (items.length) {\n              item = items.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n              break;\n            }\n          }\n        }\n        ast.push({\n          branch,\n          collected: false,\n          dir: null,\n          filtered: false,\n          find: false\n        });\n        nodes[i] = [];\n        i++;\n      }\n      if (this.#content) {\n        let cachedItem;\n        if (this.#cache.has(this.#content)) {\n          cachedItem = this.#cache.get(this.#content);\n        } else {\n          cachedItem = new Map();\n        }\n        cachedItem.set(`${selector}`, {\n          ast,\n          complex,\n          descendant\n        });\n        this.#cache.set(this.#content, cachedItem);\n      }\n      this.#complex = complex;\n      this.#descendant = descendant;\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * create tree walker\n   * @private\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @returns {object} - tree walker\n   */\n  _createTreeWalker(node) {\n    let walker;\n    if (this.#walkers.has(node)) {\n      walker = this.#walkers.get(node);\n    } else {\n      walker = this.#document.createTreeWalker(node, WALKER_FILTER);\n      this.#walkers.set(node, walker);\n    }\n    return walker;\n  }\n\n  /**\n   * prepare querySelector walker\n   * @private\n   * @returns {object} - tree walker\n   */\n  _prepareQuerySelectorWalker() {\n    this.#qswalker = this._createTreeWalker(this.#node);\n    this.#sort = false;\n    return this.#qswalker;\n  }\n\n  /**\n   * traverse tree walker\n   * @private\n   * @param {object} node - Element node\n   * @param {object} [walker] - tree walker\n   * @returns {?object} - current node\n   */\n  _traverse(node, walker = this.#walker) {\n    let refNode = walker.currentNode;\n    let current;\n    if (refNode === node) {\n      current = refNode;\n    } else if (refNode.contains(node)) {\n      refNode = walker.nextNode();\n      while (refNode) {\n        if (refNode === node) {\n          current = refNode;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n    } else {\n      if (refNode !== walker.root) {\n        while (refNode) {\n          if (refNode === walker.root || refNode === node) {\n            break;\n          }\n          refNode = walker.parentNode();\n        }\n      }\n      if (node?.nodeType === ELEMENT_NODE) {\n        while (refNode) {\n          if (refNode === node) {\n            current = refNode;\n            break;\n          }\n          refNode = walker.nextNode();\n        }\n      } else {\n        current = refNode;\n      }\n    }\n    return current ?? null;\n  }\n\n  /**\n   * collect nth child\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node, opt) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    const matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#cache.has(selector)) {\n        selectorBranches = this.#cache.get(selector);\n      } else {\n        const { branches } = walkAST(selector);\n        selectorBranches = branches;\n        this.#cache.set(selector, selectorBranches);\n      }\n    }\n    if (parentNode) {\n      const walker = this.#walker;\n      let refNode = this._traverse(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      refNode = this._traverse(parentNode, walker);\n      const selectorNodes = new Set();\n      if (selectorBranches) {\n        refNode = walker.firstChild();\n        while (refNode) {\n          let bool;\n          for (const leaves of selectorBranches) {\n            bool = this._matchLeaves(leaves, refNode, opt);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            selectorNodes.add(refNode);\n          }\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            refNode = this._traverse(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            refNode = this._traverse(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, parentNode, prefix } = node;\n    const matched = new Set();\n    if (parentNode) {\n      const walker = this.#walker;\n      let refNode = this._traverse(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = 0;\n          while (refNode) {\n            const { localName: itemLocalName, prefix: itemPrefix } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            const { localName: itemLocalName, prefix: itemPrefix } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName, opt) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const anbMap = new Map();\n    if (nthIdentName) {\n      if (nthIdentName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (nthIdentName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    if (/^nth-(?:last-)?child$/.test(nthName)) {\n      if (selector) {\n        anbMap.set('selector', selector);\n      }\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthChild(anb, node, opt);\n      return nodes;\n    } else if (/^nth-(?:last-)?of-type$/.test(nthName)) {\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthOfType(anb, node);\n      return nodes;\n    }\n    return new Set();\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(leaves, node, opt = {}) {\n    let bool;\n    if (Array.isArray(leaves) && leaves.length) {\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      opt.dir = DIR_NEXT;\n      const nodes = this._matchCombinator(twig, node, opt);\n      if (nodes.size) {\n        if (leaves.length) {\n          for (const nextNode of nodes) {\n            bool = this._matchHasPseudoFunc(Object.assign([], leaves),\n              nextNode, opt);\n            if (bool) {\n              break;\n            }\n          }\n        } else {\n          bool = true;\n        }\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @private\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node, opt = {}) {\n    const {\n      astName = '', branches = [], selector = '', twigBranches = []\n    } = astData;\n    let res;\n    if (astName === 'has') {\n      if (selector.includes(':has(')) {\n        res = null;\n      } else {\n        let bool;\n        for (const leaves of branches) {\n          bool = this._matchHasPseudoFunc(Object.assign([], leaves), node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else {\n      const forgive = /^(?:is|where)$/.test(astName);\n      opt.forgive = forgive;\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, opt);\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            opt.dir = DIR_PREV;\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, opt);\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (!bool) {\n          res = node;\n        }\n      } else if (bool) {\n        res = node;\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @private\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive unknown pseudo-class\n   * @param {boolean} [opt.warn] - warn unsupported pseudo-class\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt = {}) {\n    const { children: astChildren, name: astName } = ast;\n    const { localName, parentNode } = node;\n    const {\n      forgive,\n      warn = this.#warn\n    } = opt;\n    const matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (REG_LOGICAL_PSEUDO.test(astName)) {\n      let astData;\n      if (this.#cache.has(ast)) {\n        astData = this.#cache.get(ast);\n      } else {\n        const { branches } = walkAST(ast);\n        const selectors = [];\n        const twigBranches = [];\n        for (const [...leaves] of branches) {\n          for (const leaf of leaves) {\n            const css = generateCSS(leaf);\n            selectors.push(css);\n          }\n          const branch = [];\n          const leavesSet = new Set();\n          let item = leaves.shift();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              branch.push({\n                combo: item,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n            } else if (item) {\n              leavesSet.add(item);\n            }\n            if (leaves.length) {\n              item = leaves.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n              break;\n            }\n          }\n          twigBranches.push(branch);\n        }\n        astData = {\n          astName,\n          branches,\n          twigBranches,\n          selector: selectors.join(',')\n        };\n        this.#cache.set(ast, astData);\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node, opt);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        const [branch] = astChildren;\n        const nodes = this._matchAnPlusB(branch, node, astName, opt);\n        return nodes;\n      } else {\n        switch (astName) {\n          // :dir(), :lang()\n          case 'dir':\n          case 'lang': {\n            const res = matcher.matchSelector(ast, node);\n            if (res) {\n              matched.add(res);\n            }\n            break;\n          }\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (warn) {\n              const msg = `Unsupported pseudo-class :${astName}()`;\n              throw new DOMException(msg, NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          default: {\n            if (!forgive) {\n              const msg = `Unknown pseudo-class :${astName}()`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      const regAnchor = /^a(?:rea)?$/;\n      const regFormCtrl =\n        /^(?:button|fieldset|input|optgroup|option|select|textarea)$/;\n      const regFormValidity = /^(?:button|form|input|select|textarea)$/;\n      const regInteract = /^(?:details|dialog)$/;\n      const regTypeCheck = /^(?:checkbox|radio)$/;\n      const regTypeDate = /^(?:date(?:time-local)?|month|time|week)$/;\n      const regTypeRange =\n        /(?:date(?:time-local)?|month|number|range|time|week)$/;\n      const regTypeText = /^(?:email|number|password|search|tel|text|url)$/;\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if (regAnchor.test(localName) && node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if (regAnchor.test(localName) && node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#content.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'hover': {\n          const { target, type } = this.#event ?? {};\n          if ((type === 'mouseover' || type === 'pointerover') &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'active': {\n          const { buttons, target, type } = this.#event ?? {};\n          if ((type === 'mousedown' || type === 'pointerdown') &&\n              buttons & BIT_01 && node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#content.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#content.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#content.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#content.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (!this.#shadow && node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#content.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus':\n        case 'focus-visible': {\n          const { target, type } = this.#event ?? {};\n          if (node === this.#content.activeElement && node.tabIndex >= 0 &&\n              (astName === 'focus' ||\n               (type === 'keydown' && node.contains(target)))) {\n            let refNode = node;\n            let focus = true;\n            while (refNode) {\n              if (refNode.disabled || refNode.hasAttribute('disabled') ||\n                  refNode.hidden || refNode.hasAttribute('hidden')) {\n                focus = false;\n                break;\n              } else {\n                const { display, visibility } =\n                  this.#window.getComputedStyle(refNode);\n                focus = !(display === 'none' || visibility === 'hidden');\n                if (!focus) {\n                  break;\n                }\n              }\n              if (refNode.parentNode &&\n                  refNode.parentNode.nodeType === ELEMENT_NODE) {\n                refNode = refNode.parentNode;\n              } else {\n                break;\n              }\n            }\n            if (focus) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'focus-within': {\n          let active;\n          let current = this.#content.activeElement;\n          if (current.tabIndex >= 0) {\n            while (current) {\n              if (current === node) {\n                active = true;\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          if (active) {\n            let refNode = node;\n            let focus = true;\n            while (refNode) {\n              if (refNode.disabled || refNode.hasAttribute('disabled') ||\n                  refNode.hidden || refNode.hasAttribute('hidden')) {\n                focus = false;\n                break;\n              } else {\n                const { display, visibility } =\n                  this.#window.getComputedStyle(refNode);\n                focus = !(display === 'none' || visibility === 'hidden');\n                if (!focus) {\n                  break;\n                }\n              }\n              if (refNode.parentNode &&\n                  refNode.parentNode.nodeType === ELEMENT_NODE) {\n                refNode = refNode.parentNode;\n              } else {\n                break;\n              }\n            }\n            if (focus) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'open': {\n          if (regInteract.test(localName) && node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'closed': {\n          if (regInteract.test(localName) && !node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'disabled': {\n          if (regFormCtrl.test(localName) || isCustomElementName(localName)) {\n            if (node.disabled || node.hasAttribute('disabled')) {\n              matched.add(node);\n            } else {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset') {\n                  break;\n                }\n                parent = parent.parentNode;\n              }\n              if (parent && parentNode.localName !== 'legend' &&\n                  parent.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'enabled': {\n          if ((regFormCtrl.test(localName) || isCustomElementName(localName)) &&\n              !(node.disabled && node.hasAttribute('disabled'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'read-only': {\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || regTypeDate.test(node.type) ||\n                   regTypeText.test(node.type)) &&\n                  (node.readonly || node.hasAttribute('readonly') ||\n                   node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (!isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'read-write': {\n          switch (localName) {\n            case 'textarea': {\n              if (!(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || regTypeDate.test(node.type) ||\n                   regTypeText.test(node.type)) &&\n                  !(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let targetNode;\n          if (localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              if (regTypeText.test(node.getAttribute('type'))) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode && node.value === '' &&\n              node.hasAttribute('placeholder') &&\n              node.getAttribute('placeholder').trim().length) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'checked': {\n          if ((node.checked && localName === 'input' &&\n               node.hasAttribute('type') &&\n               regTypeCheck.test(node.getAttribute('type'))) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#content.documentElement;\n            }\n            const items = parent.getElementsByTagName('input');\n            const l = items.length;\n            let checked;\n            for (let i = 0; i < l; i++) {\n              const item = items[i];\n              if (item.getAttribute('type') === 'radio') {\n                if (nodeName) {\n                  if (item.getAttribute('name') === nodeName) {\n                    checked = !!item.checked;\n                  }\n                } else if (!item.hasAttribute('name')) {\n                  checked = !!item.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          const regTypeReset = /^(?:button|reset)$/;\n          const regTypeSubmit = /^(?:image|submit)$/;\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') &&\n                 regTypeReset.test(node.getAttribute('type')))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               regTypeSubmit.test(node.getAttribute('type')))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker = this.#walker;\n              let nextNode = this._traverse(form, walker);\n              nextNode = walker.firstChild();\n              while (nextNode && form.contains(nextNode)) {\n                const nodeName = nextNode.localName;\n                let m;\n                if (nodeName === 'button') {\n                  m = !(nextNode.hasAttribute('type') &&\n                    regTypeReset.test(nextNode.getAttribute('type')));\n                } else if (nodeName === 'input') {\n                  m = nextNode.hasAttribute('type') &&\n                    regTypeSubmit.test(nextNode.getAttribute('type'));\n                }\n                if (m) {\n                  if (nextNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                nextNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     regTypeCheck.test(node.getAttribute('type')) &&\n                     (node.checked || node.hasAttribute('checked'))) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option') {\n            let parent = parentNode;\n            let isMultiple = false;\n            while (parent) {\n              if (parent.localName === 'datalist') {\n                break;\n              } else if (parent.localName === 'select') {\n                if (parent.multiple || parent.hasAttribute('multiple')) {\n                  isMultiple = true;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (isMultiple) {\n              if (node.selected || node.hasAttribute('selected')) {\n                matched.add(node);\n              }\n            } else {\n              const defaultOpt = new Set();\n              const walker = this.#walker;\n              let refNode = this._traverse(parentNode, walker);\n              refNode = walker.firstChild();\n              while (refNode) {\n                if (refNode.selected || refNode.hasAttribute('selected')) {\n                  defaultOpt.add(refNode);\n                  break;\n                }\n                refNode = walker.nextSibling();\n              }\n              if (defaultOpt.size) {\n                if (defaultOpt.has(node)) {\n                  matched.add(node);\n                }\n              }\n            }\n          }\n          break;\n        }\n        case 'valid': {\n          if (regFormValidity.test(localName)) {\n            if (node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this.#walker;\n            let refNode = this._traverse(node, walker);\n            refNode = walker.firstChild();\n            let bool;\n            while (refNode && node.contains(refNode)) {\n              if (regFormValidity.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'invalid': {\n          if (regFormValidity.test(localName)) {\n            if (!node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this.#walker;\n            let refNode = this._traverse(node, walker);\n            refNode = walker.firstChild();\n            let bool;\n            while (refNode && node.contains(refNode)) {\n              if (regFormValidity.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (!bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              regTypeRange.test(node.getAttribute('type')) &&\n              !(node.validity.rangeUnderflow ||\n                node.validity.rangeOverflow) &&\n              (node.hasAttribute('min') || node.hasAttribute('max') ||\n               node.getAttribute('type') === 'range')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'out-of-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              regTypeRange.test(node.getAttribute('type')) &&\n              (node.validity.rangeUnderflow || node.validity.rangeOverflow)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'required': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || regTypeCheck.test(inputType) ||\n                  regTypeDate.test(inputType) || regTypeText.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              (node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'optional': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || regTypeCheck.test(inputType) ||\n                  regTypeDate.test(inputType) || regTypeText.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              !(node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#content.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            const walker = this.#document.createTreeWalker(node, SHOW_ALL);\n            let refNode = walker.firstChild();\n            let bool;\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode && node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) || node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'defined': {\n          const attr = node.getAttribute('is');\n          if (attr) {\n            if (isCustomElementName(attr) &&\n                this.#window.customElements.get(attr)) {\n              matched.add(node);\n            }\n          } else if (isCustomElementName(localName)) {\n            if (this.#window.customElements.get(localName)) {\n              matched.add(node);\n            }\n          // NOTE: MathMLElement not implemented in jsdom\n          } else if (node instanceof this.#window.HTMLElement ||\n                     node instanceof this.#window.SVGElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'popover-open': {\n          if (node.popover) {\n            const { display } = this.#window.getComputedStyle(node);\n            if (display !== 'none') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (warn) {\n            const msg = `Unsupported pseudo-element ::${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        // not supported\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'fullscreen':\n        case 'future':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (warn) {\n            const msg = `Unsupported pseudo-class :${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (warn) {\n              const msg = `Unsupported pseudo-class :${astName}`;\n              throw new DOMException(msg, NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            const msg = `Unknown pseudo-class :${astName}`;\n            throw new DOMException(msg, SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match shadow host pseudo class\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren, name: astName } = ast;\n    let res;\n    if (Array.isArray(astChildren)) {\n      const { branches } = walkAST(astChildren[0]);\n      const [branch] = branches;\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            const msg = `Invalid selector ${css}`;\n            throw new DOMException(msg, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      } else if (astName === 'host-context') {\n        let parent = host;\n        let bool;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              const msg = `Invalid selector ${css}`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else if (astName === 'host') {\n      res = node;\n    } else {\n      const msg = `Invalid selector :${astName}`;\n      throw new DOMException(msg, SYNTAX_ERR);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt) {\n    const { type: astType } = ast;\n    const matched = new Set();\n    if (ast.name === EMPTY) {\n      return matched;\n    }\n    const astName = unescapeSelector(ast.name);\n    if (typeof astName === 'string' && astName !== ast.name) {\n      ast.name = astName;\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case SELECTOR_PSEUDO_ELEMENT: {\n          matcher.matchPseudoElementSelector(astName, opt);\n          break;\n        }\n        case SELECTOR_ID: {\n          if (node.id === astName) {\n            matched.add(node);\n          }\n          break;\n        }\n        case SELECTOR_CLASS: {\n          if (node.classList.contains(astName)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case SELECTOR_PSEUDO_CLASS: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          return nodes;\n        }\n        default: {\n          const res = matcher.matchSelector(ast, node, opt);\n          if (res) {\n            matched.add(res);\n          }\n        }\n      }\n    } else if (this.#shadow && astType === SELECTOR_PSEUDO_CLASS &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (astName !== 'has' && REG_LOGICAL_PSEUDO.test(astName)) {\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        return nodes;\n      } else if (REG_SHADOW_HOST.test(astName)) {\n        const res = this._matchShadowHostPseudoClass(ast, node, opt);\n        if (res) {\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    const { attributes, localName, nodeType } = node;\n    let result = this.#results.get(leaves);\n    let bool;\n    if (result && result.has(node)) {\n      const { attr, matched } = result.get(node);\n      if (attributes?.length === attr) {\n        bool = matched;\n      }\n    }\n    if (typeof bool !== 'boolean') {\n      const regForm = /^(?:(?:fieldse|inpu|selec)t|button|form|textarea)$/;\n      let save;\n      if (nodeType === ELEMENT_NODE && regForm.test(localName)) {\n        save = false;\n      } else {\n        save = true;\n      }\n      for (const leaf of leaves) {\n        const { name: leafName, type: leafType } = leaf;\n        if (leafType === SELECTOR_PSEUDO_CLASS && leafName === 'dir') {\n          save = false;\n        }\n        bool = this._matchSelector(leaf, node, opt).has(node);\n        if (!bool) {\n          break;\n        }\n      }\n      if (save) {\n        if (!result) {\n          result = new WeakMap();\n        }\n        result.set(node, {\n          attr: attributes?.length,\n          matched: bool\n        });\n        this.#results.set(leaves, result);\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match HTML collection\n   * @private\n   * @param {object} items - HTML collection\n   * @param {object} opt - options\n   * @returns {Set.<object>} - matched nodes\n   */\n  _matchHTMLCollection(items, opt = {}) {\n    const { compound, filterLeaves } = opt;\n    const nodes = new Set();\n    const l = items.length;\n    if (l) {\n      if (compound) {\n        for (let i = 0; i < l; i++) {\n          const item = items[i];\n          const bool = this._matchLeaves(filterLeaves, item, opt);\n          if (bool) {\n            nodes.add(item);\n          }\n        }\n      } else {\n        const arr = [].slice.call(items);\n        return new Set(arr);\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * find descendant nodes\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node\n   * @param {object} opt - options\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode, opt) {\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    if (typeof leafName === 'string' && leafName !== leaf.name) {\n      leaf.name = leafName;\n    }\n    let nodes = new Set();\n    let pending = false;\n    if (this.#shadow) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case SELECTOR_PSEUDO_ELEMENT: {\n          matcher.matchPseudoElementSelector(leafName, opt);\n          break;\n        }\n        case SELECTOR_ID: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node, opt);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case SELECTOR_CLASS: {\n          const items = baseNode.getElementsByClassName(leafName);\n          nodes = this._matchHTMLCollection(items, {\n            compound,\n            filterLeaves\n          });\n          break;\n        }\n        case SELECTOR_TYPE: {\n          if (this.#content.contentType === 'text/html' &&\n              !/[*|]/.test(leafName)) {\n            const items = baseNode.getElementsByTagName(leafName);\n            nodes = this._matchHTMLCollection(items, {\n              compound,\n              filterLeaves\n            });\n          } else {\n            pending = true;\n          }\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    return {\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * match combinator\n   * @private\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt = {}) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { parentNode } = node;\n    const { dir } = opt;\n    const matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            const walker = this._createTreeWalker(parentNode);\n            let refNode = this._traverse(node, walker);\n            refNode = walker.nextSibling();\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextSibling();\n            }\n          }\n          break;\n        }\n        case '>': {\n          const walker = this._createTreeWalker(node);\n          let refNode = this._traverse(node, walker);\n          refNode = walker.firstChild();\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = walker.nextSibling();\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const { nodes, pending } = this._findDescendantNodes(leaves, node);\n          if (nodes.size) {\n            return nodes;\n          }\n          if (pending) {\n            const walker = this._createTreeWalker(node);\n            let refNode = this._traverse(node, walker);\n            refNode = walker.nextNode();\n            while (refNode && node.contains(refNode)) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextNode();\n            }\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            const walker = this._createTreeWalker(parentNode);\n            let refNode = this._traverse(parentNode, walker);\n            refNode = walker.firstChild();\n            while (refNode) {\n              if (refNode === node) {\n                break;\n              } else {\n                const bool = this._matchLeaves(leaves, refNode, opt);\n                if (bool) {\n                  matched.add(refNode);\n                }\n              }\n              refNode = walker.nextSibling();\n            }\n          }\n          break;\n        }\n        case '>': {\n          if (parentNode) {\n            const bool = this._matchLeaves(leaves, parentNode, opt);\n            if (bool) {\n              matched.add(parentNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            return new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node from #qswalker\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} [opt] - options\n   * @param {object} [opt.node] - node to start from\n   * @returns {?object} - matched node\n   */\n  _findNode(leaves, opt) {\n    const { node } = opt;\n    let refNode = this._traverse(node, this.#qswalker);\n    let matchedNode;\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = this.#qswalker.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = this.#qswalker.nextNode();\n        }\n      }\n      while (refNode) {\n        const matched = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (matched) {\n          matchedNode = refNode;\n          break;\n        }\n        refNode = this.#qswalker.nextNode();\n      }\n    }\n    return matchedNode ?? null;\n  }\n\n  /**\n   * match self\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _matchSelf(leaves) {\n    const nodes = [];\n    const bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    let filtered = false;\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find lineal\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @param {object} opt - options\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findLineal(leaves, opt = {}) {\n    const { complex } = opt;\n    const nodes = [];\n    let bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    let filtered = false;\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    if (!bool || complex) {\n      let refNode = this.#node.parentNode;\n      while (refNode) {\n        bool = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (bool) {\n          nodes.push(refNode);\n          filtered = true;\n        }\n        if (refNode.parentNode) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find first\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findFirst(leaves) {\n    const nodes = [];\n    const node = this._findNode(leaves, {\n      node: this.#node\n    });\n    let filtered = false;\n    if (node) {\n      nodes.push(node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find from HTML collection\n   * @private\n   * @param {object} items - HTML collection\n   * @param {object} opt - options\n   * @param {boolean} [opt.compound] - compound selector\n   * @param {Array} [opt.filterLeaves] - filter leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findFromHTMLCollection(items, opt = {}) {\n    const { complex, compound, filterLeaves, targetType } = opt;\n    let nodes = [];\n    let filtered = false;\n    let collected = false;\n    const l = items.length;\n    if (l) {\n      if (this.#node.nodeType === ELEMENT_NODE) {\n        for (let i = 0; i < l; i++) {\n          const node = items[i];\n          if (node !== this.#node &&\n              (this.#node.contains(node) || node.contains(this.#node))) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n                if (targetType === TARGET_FIRST) {\n                  break;\n                }\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n              if (targetType === TARGET_FIRST) {\n                break;\n              }\n            }\n          }\n        }\n      } else if (complex) {\n        if (compound) {\n          for (let i = 0; i < l; i++) {\n            const node = items[i];\n            const bool = this._matchLeaves(filterLeaves, node, {\n              warn: this.#warn\n            });\n            if (bool) {\n              nodes.push(node);\n              filtered = true;\n              if (targetType === TARGET_FIRST) {\n                break;\n              }\n            }\n          }\n        } else {\n          nodes = [].slice.call(items);\n          filtered = true;\n          collected = true;\n        }\n      } else if (compound) {\n        for (let i = 0; i < l; i++) {\n          const node = items[i];\n          const bool = this._matchLeaves(filterLeaves, node, {\n            warn: this.#warn\n          });\n          if (bool) {\n            nodes.push(node);\n            filtered = true;\n            if (targetType === TARGET_FIRST) {\n              break;\n            }\n          }\n        }\n      } else {\n        nodes = [].slice.call(items);\n        filtered = true;\n        collected = true;\n      }\n    }\n    return [nodes, filtered, collected];\n  }\n\n  /**\n   * find entry nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @param {boolean} complex - complex selector\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType, complex) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { name: leafName, type: leafType } = leaf;\n    let nodes = [];\n    let collected = false;\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case SELECTOR_PSEUDO_ELEMENT: {\n        matcher.matchPseudoElementSelector(leafName, {\n          warn: this.#warn\n        });\n        break;\n      }\n      case SELECTOR_ID: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST &&\n                   this.#root.nodeType !== ELEMENT_NODE) {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      case SELECTOR_CLASS: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (this.#root.nodeType === DOCUMENT_NODE) {\n          const items = this.#root.getElementsByClassName(leafName);\n          if (items.length) {\n            [nodes, filtered, collected] = this._findFromHTMLCollection(items, {\n              complex,\n              compound,\n              filterLeaves,\n              targetType\n            });\n          }\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      case SELECTOR_TYPE: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (this.#content.contentType === 'text/html' &&\n                   this.#root.nodeType === DOCUMENT_NODE &&\n                   !/[*|]/.test(leafName)) {\n          const items = this.#root.getElementsByTagName(leafName);\n          if (items.length) {\n            [nodes, filtered, collected] = this._findFromHTMLCollection(items, {\n              complex,\n              compound,\n              filterLeaves,\n              targetType\n            });\n          }\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL && REG_SHADOW_HOST.test(leafName)) {\n          if (this.#shadow &&\n              this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            const node = this._matchShadowHostPseudoClass(leaf, this.#node);\n            if (node) {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      collected,\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * collect nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const branchLen = branch.length;\n        const complex = branchLen > 1;\n        const firstTwig = branch[0];\n        let dir;\n        let twig;\n        if (complex) {\n          const {\n            combo: firstCombo,\n            leaves: [{\n              name: firstName,\n              type: firstType\n            }]\n          } = firstTwig;\n          const lastTwig = branch[branchLen - 1];\n          const {\n            leaves: [{\n              name: lastName,\n              type: lastType\n            }]\n          } = lastTwig;\n          if (lastType === SELECTOR_PSEUDO_ELEMENT ||\n              lastType === SELECTOR_ID) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (firstType === SELECTOR_PSEUDO_ELEMENT ||\n                     firstType === SELECTOR_ID) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (targetType === TARGET_ALL) {\n            if (firstName === '*' && firstType === SELECTOR_TYPE) {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            } else if (lastName === '*' && lastType === SELECTOR_TYPE) {\n              dir = DIR_NEXT;\n              twig = firstTwig;\n            } else if (branchLen === 2) {\n              const { name: comboName } = firstCombo;\n              if (/^[+~]$/.test(comboName)) {\n                dir = DIR_PREV;\n                twig = lastTwig;\n              } else {\n                dir = DIR_NEXT;\n                twig = firstTwig;\n              }\n            } else {\n              dir = DIR_NEXT;\n              twig = firstTwig;\n            }\n          } else if (lastName === '*' && lastType === SELECTOR_TYPE) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (firstName === '*' && firstType === SELECTOR_TYPE) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else {\n            let bool;\n            for (const { combo, leaves: [leaf] } of branch) {\n              const { name: leafName, type: leafType } = leaf;\n              if (leafType === SELECTOR_PSEUDO_CLASS && leafName === 'dir') {\n                bool = false;\n                break;\n              }\n              if (!bool && combo) {\n                const { name: comboName } = combo;\n                if (/^[+~]$/.test(comboName)) {\n                  bool = true;\n                }\n              }\n            }\n            if (bool) {\n              dir = DIR_NEXT;\n              twig = firstTwig;\n            } else {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            }\n          }\n        } else {\n          dir = DIR_PREV;\n          twig = firstTwig;\n        }\n        const {\n          collected, compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].collected = collected;\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#qswalker;\n        } else {\n          node = this.#root;\n          walker = this.#walker;\n        }\n        let nextNode = this._traverse(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode, {\n                warn: this.#warn\n              });\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].push(nextNode);\n              }\n            }\n          }\n          if (nextNode !== walker.currentNode) {\n            nextNode = this._traverse(nextNode, walker);\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const complex = branch.length > 1;\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * get combined nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {object} nodes - collection of nodes\n   * @param {string} dir - direction\n   * @returns {Array.<object>} - collection of matched nodes\n   */\n  _getCombinedNodes(twig, nodes, dir) {\n    const arr = [];\n    for (const node of nodes) {\n      const matched = this._matchCombinator(twig, node, {\n        dir,\n        warn: this.#warn\n      });\n      if (matched.size) {\n        arr.push(...matched);\n      }\n    }\n    if (arr.length) {\n      return new Set(arr);\n    }\n    return new Set();\n  }\n\n  /**\n   * match node to next direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {Set.<object>} nodes - collection of Element node\n   * @param {object} opt - option\n   * @param {object} opt.combo - combo\n   * @returns {?object} - matched node\n   */\n  _matchNodeNext(branch, nodes, opt) {\n    const { combo, index } = opt;\n    const { combo: nextCombo, leaves } = branch[index];\n    const twig = {\n      combo,\n      leaves\n    };\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_NEXT);\n    let res;\n    if (nextNodes.size) {\n      if (index === branch.length - 1) {\n        const [nextNode] = sortNodes(nextNodes);\n        res = nextNode;\n      } else {\n        res = this._matchNodeNext(branch, nextNodes, {\n          combo: nextCombo,\n          index: index + 1\n        });\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match node to previous direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @param {number} opt.index - index\n   * @returns {?object} - node\n   */\n  _matchNodePrev(branch, node, opt) {\n    const { index } = opt;\n    const twig = branch[index];\n    const nodes = new Set([node]);\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_PREV);\n    let res;\n    if (nextNodes.size) {\n      if (index === 0) {\n        res = node;\n      } else {\n        for (const nextNode of nextNodes) {\n          const matched = this._matchNodePrev(branch, nextNode, {\n            index: index - 1\n          });\n          if (matched) {\n            return node;\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * find matched nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _find(targetType) {\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      this._prepareQuerySelectorWalker();\n    }\n    const [[...branches], nodes] = this._collectNodes(targetType);\n    const l = branches.length;\n    let res = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, collected, dir, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = nodes[i];\n        const entryNodesLen = entryNodes.length;\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              if (node !== this.#node && this.#node.contains(node)) {\n                res.add(node);\n                if (targetType !== TARGET_ALL) {\n                  break;\n                }\n              }\n            }\n          } else if (targetType === TARGET_ALL) {\n            if (res.size) {\n              const n = [...res];\n              res = new Set([...n, ...entryNodes]);\n              this.#sort = true;\n            } else {\n              res = new Set(entryNodes);\n            }\n          } else {\n            const [node] = entryNodes;\n            res.add(node);\n          }\n        } else if (targetType === TARGET_ALL) {\n          if (dir === DIR_NEXT) {\n            let { combo } = branch[0];\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const twig = {\n                  combo,\n                  leaves\n                };\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === lastIndex) {\n                    if (res.size) {\n                      const n = [...res];\n                      res = new Set([...n, ...nextNodes]);\n                      this.#sort = true;\n                    } else {\n                      res = nextNodes;\n                    }\n                  } else {\n                    combo = nextCombo;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          } else {\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === 0) {\n                    res.add(node);\n                    if (branchLen > 1 && res.size > 1) {\n                      this.#sort = true;\n                    }\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        } else if (targetType === TARGET_FIRST && dir === DIR_NEXT) {\n          const { combo: entryCombo } = branch[0];\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodeNext(branch, new Set([node]), {\n              combo: entryCombo,\n              index: 1\n            });\n            if (matched) {\n              res.add(matched);\n              break;\n            }\n          }\n          if (!matched && !collected) {\n            const { leaves: entryLeaves } = branch[0];\n            const [entryNode] = entryNodes;\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode\n            });\n            while (refNode) {\n              matched = this._matchNodeNext(branch, new Set([refNode]), {\n                combo: entryCombo,\n                index: 1\n              });\n              if (matched) {\n                res.add(matched);\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode\n              });\n            }\n          }\n        } else {\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodePrev(branch, node, {\n              index: lastIndex - 1\n            });\n            if (matched) {\n              res.add(node);\n              break;\n            }\n          }\n          if (!matched && !collected && targetType === TARGET_FIRST) {\n            const { leaves: entryLeaves } = branch[lastIndex];\n            const [entryNode] = entryNodes;\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode\n            });\n            while (refNode) {\n              matched = this._matchNodePrev(branch, refNode, {\n                index: lastIndex - 1\n              });\n              if (matched) {\n                res.add(refNode);\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode\n              });\n            }\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * matches\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - `true` if matched `false` otherwise\n   */\n  matches(selector, node, opt) {\n    let res;\n    try {\n      if (node?.nodeType !== ELEMENT_NODE) {\n        const msg = `Unexpected node ${node?.nodeName}`;\n        throw new TypeError(msg);\n      }\n      if (filterSelector(selector, {\n        complex: this.#complex,\n        descendant: true\n      })) {\n        res = this.#nwsapi.match(selector, node);\n      } else {\n        this._setup(selector, node, opt);\n        const nodes = this._find(TARGET_SELF);\n        res = nodes.size;\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return !!res;\n  }\n\n  /**\n   * closest\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  closest(selector, node, opt) {\n    let res;\n    try {\n      if (node?.nodeType !== ELEMENT_NODE) {\n        const msg = `Unexpected node ${node?.nodeName}`;\n        throw new TypeError(msg);\n      }\n      if (filterSelector(selector, {\n        complex: this.#complex,\n        descendant: true\n      })) {\n        res = this.#nwsapi.closest(selector, node);\n      } else {\n        this._setup(selector, node, opt);\n        const nodes = this._find(TARGET_LINEAL);\n        if (nodes.size) {\n          let refNode = this.#node;\n          while (refNode) {\n            if (nodes.has(refNode)) {\n              res = refNode;\n              break;\n            }\n            refNode = refNode.parentNode;\n          }\n        }\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  querySelector(selector, node, opt) {\n    let res;\n    try {\n      this._setup(selector, node, opt);\n      if (this.#document === this.#content && !this.#descendant &&\n          filterSelector(selector, {\n            complex: this.#complex,\n            descendant: false\n          })) {\n        res = this.#nwsapi.first(selector, node);\n      } else {\n        const nodes = this._find(TARGET_FIRST);\n        nodes.delete(this.#node);\n        if (nodes.size) {\n          [res] = sortNodes(nodes);\n        }\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector all\n   * NOTE: returns Array, not NodeList\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {Array.<object|undefined>} - collection of matched nodes\n   */\n  querySelectorAll(selector, node, opt) {\n    let res;\n    try {\n      this._setup(selector, node, opt);\n      if (this.#document === this.#content && !this.#descendant &&\n          filterSelector(selector, {\n            complex: this.#complex,\n            descendant: false\n          })) {\n        res = this.#nwsapi.select(selector, node);\n      } else {\n        const nodes = this._find(TARGET_ALL);\n        nodes.delete(this.#node);\n        if (nodes.size) {\n          if (this.#sort) {\n            res = sortNodes(nodes);\n          } else {\n            res = [...nodes];\n          }\n        }\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? [];\n  }\n};\n"],
  "mappings": "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",
  "names": ["finder_exports", "__export", "Finder", "__toCommonJS", "import_is_potential_custom_element_name", "import_nwsapi", "import_dom_util", "import_matcher", "import_parser", "import_constant", "DIR_NEXT", "DIR_PREV", "TARGET_ALL", "TARGET_FIRST", "TARGET_LINEAL", "TARGET_SELF", "#ast", "#cache", "#complex", "#content", "#descendant", "#document", "#event", "#node", "#nodes", "#noexcept", "#nwsapi", "#qswalker", "#results", "#root", "#shadow", "#sort", "#walker", "#walkers", "#warn", "#window", "window", "nwsapi", "e", "selector", "node", "opt", "event", "noexcept", "warn", "nodes", "ast", "cachedItem", "item", "cssAst", "branches", "complex", "descendant", "i", "items", "branch", "leaves", "nextItem", "msg", "itemName", "walker", "refNode", "current", "anb", "a", "b", "reverse", "parentNode", "matched", "selectorBranches", "l", "selectorNodes", "bool", "nth", "j", "m", "localName", "prefix", "itemLocalName", "itemPrefix", "nthName", "nthIdentName", "anbMap", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "astName", "twigBranches", "res", "forgive", "lastIndex", "nextNodes", "arr", "astChildren", "selectors", "css", "leavesSet", "regAnchor", "regFormCtrl", "regFormValidity", "regInteract", "regTypeCheck", "regTypeDate", "regTypeRange", "regTypeText", "href", "origin", "pathname", "attrURL", "target", "type", "buttons", "hash", "id", "focus", "display", "visibility", "active", "isCustomElementName", "parent", "targetNode", "nodeName", "checked", "regTypeReset", "regTypeSubmit", "form", "isMultiple", "defaultOpt", "inputType", "node1", "node2", "attr", "host", "astType", "attributes", "nodeType", "result", "regForm", "save", "leafName", "compound", "filterLeaves", "baseNode", "pending", "comboName", "dir", "matchedNode", "filtered", "targetType", "collected", "pendingItems", "branchLen", "firstTwig", "firstCombo", "firstName", "firstType", "lastTwig", "lastName", "lastType", "pendingItem", "index", "nextCombo", "find", "entryNodes", "entryNodesLen", "n", "entryCombo", "entryLeaves", "entryNode"]
}
