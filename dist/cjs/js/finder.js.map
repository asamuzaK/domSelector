{
  "version": 3,
  "sources": ["../../../src/js/finder.js"],
  "sourcesContent": ["/**\n * finder.js\n */\n\n/* import */\nimport isCustomElementName from 'is-potential-custom-element-name';\nimport {\n  getDirectionality, isContentEditable, isInclusive, isInShadowTree,\n  prepareDOMObjects, sortNodes\n} from './dom-util.js';\nimport { matchSelector, matchPseudoElementSelector } from './matcher.js';\nimport {\n  generateCSS, parseSelector, sortAST, unescapeSelector, walkAST\n} from './parser.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, COMBINATOR, DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, ELEMENT_NODE,\n  NOT_SUPPORTED_ERR, REG_LOGICAL_PSEUDO, REG_SHADOW_HOST, SELECTOR_CLASS,\n  SELECTOR_ID, SELECTOR_PSEUDO_CLASS, SELECTOR_PSEUDO_ELEMENT, SELECTOR_TYPE,\n  SHOW_ALL, SHOW_DOCUMENT, SHOW_DOCUMENT_FRAGMENT, SHOW_ELEMENT, SYNTAX_ERR,\n  TEXT_NODE\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\nconst TARGET_ALL = 'all';\nconst TARGET_FIRST = 'first';\nconst TARGET_LINEAL = 'lineal';\nconst TARGET_SELF = 'self';\nconst WALKER_FILTER = SHOW_DOCUMENT | SHOW_DOCUMENT_FRAGMENT | SHOW_ELEMENT;\n\n/**\n * Finder\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: [\n *   {\n *     branch: branch[],\n *     dir: string|null,\n *     filtered: boolean,\n *     find: boolean\n *   },\n *   {\n *     branch: branch[],\n *     dir: string|null,\n *     filtered: boolean,\n *     find: boolean\n *   }\n * ]\n * #nodes: [\n *   [node{}, node{}],\n *   [node{}, node{}, node{}]\n * ]\n * branch[]: [twig{}, twig{}]\n * twig{}: {\n *   combo: leaf{}|null,\n *   leaves: leaves[]\n * }\n * leaves[]: [leaf{}, leaf{}, leaf{}]\n * leaf{}: CSSTree AST object\n * node{}: Element node\n */\nexport class Finder {\n  /* private fields */\n  #ast;\n  #cache;\n  #document;\n  #finder;\n  #node;\n  #nodes;\n  #noexcept;\n  #results;\n  #root;\n  #shadow;\n  #sort;\n  #tree;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   */\n  constructor() {\n    this.#cache = new WeakMap();\n  }\n\n  /**\n   * handle error\n   * @private\n   * @param {Error} e - Error\n   * @throws Error\n   * @returns {void}\n   */\n  _onError(e) {\n    if (!this.#noexcept) {\n      if (e instanceof DOMException ||\n          (this.#window && e instanceof this.#window.DOMException)) {\n        if (e.name === NOT_SUPPORTED_ERR) {\n          if (this.#warn) {\n            console.warn(e.message);\n          }\n        } else if (this.#window) {\n          throw new this.#window.DOMException(e.message, e.name);\n        } else {\n          throw e;\n        }\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * setup finder\n   * @private\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.noexcept] - no exception\n   * @param {boolean} [opt.warn] - console warn\n   * @returns {object} - node\n   */\n  _setup(selector, node, opt = {}) {\n    const { noexcept, warn } = opt;\n    this.#noexcept = !!noexcept;\n    this.#warn = !!warn;\n    this.#node = node;\n    [this.#window, this.#document, this.#root] = prepareDOMObjects(node);\n    this.#shadow = isInShadowTree(node);\n    [this.#ast, this.#nodes] = this._correspond(selector);\n    this.#results = new WeakMap();\n    return node;\n  }\n\n  /**\n   * correspond #ast and #nodes\n   * @private\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of #ast and #nodes\n   */\n  _correspond(selector) {\n    const nodes = [];\n    let ast;\n    let cachedItem = this.#document && this.#cache.get(this.#document);\n    if (cachedItem && cachedItem.has(`${selector}`)) {\n      ast = cachedItem.get(selector);\n    }\n    if (ast) {\n      const l = ast.length;\n      for (let i = 0; i < l; i++) {\n        ast[i].dir = null;\n        ast[i].filtered = false;\n        ast[i].find = false;\n        nodes[i] = [];\n      }\n    } else {\n      let cssAst;\n      try {\n        cssAst = parseSelector(selector);\n      } catch (e) {\n        this._onError(e);\n      }\n      const branches = walkAST(cssAst);\n      ast = [];\n      let i = 0;\n      for (const [...items] of branches) {\n        const branch = [];\n        let item = items.shift();\n        if (item && item.type !== COMBINATOR) {\n          const leaves = new Set();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              const [nextItem] = items;\n              if (nextItem.type === COMBINATOR) {\n                const msg = `Invalid selector ${selector}`;\n                throw new DOMException(msg, SYNTAX_ERR);\n              }\n              branch.push({\n                combo: item,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n            } else if (item) {\n              let { name: itemName } = item;\n              if (itemName) {\n                if (Object.prototype.hasOwnProperty.call(itemName, 'name')) {\n                  itemName = unescapeSelector(itemName.name);\n                  if (/[|:]/.test(itemName)) {\n                    item.namespace = true;\n                  }\n                } else if (typeof itemName === 'string') {\n                  itemName = unescapeSelector(itemName);\n                  if (/[|:]/.test(itemName)) {\n                    item.namespace = true;\n                  }\n                }\n              }\n              leaves.add(item);\n            }\n            if (items.length) {\n              item = items.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n              break;\n            }\n          }\n        }\n        ast.push({\n          branch,\n          dir: null,\n          filtered: false,\n          find: false\n        });\n        nodes[i] = [];\n        i++;\n      }\n      if (this.#document) {\n        if (!cachedItem) {\n          cachedItem = new Map();\n        }\n        cachedItem.set(`${selector}`, ast);\n        this.#cache.set(this.#document, cachedItem);\n      }\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * prepare tree walkers\n   * @private\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @returns {Array} - [#tree, #finder]\n   */\n  _prepareTreeWalkers(node) {\n    this.#tree = this.#document.createTreeWalker(this.#root, WALKER_FILTER);\n    this.#finder = this.#document.createTreeWalker(node, WALKER_FILTER);\n    this.#sort = false;\n    return [\n      this.#tree,\n      this.#finder\n    ];\n  }\n\n  /**\n   * traverse tree walker\n   * @private\n   * @param {object} [node] - Element node\n   * @param {object} [walker] - tree walker\n   * @returns {?object} - current node\n   */\n  _traverse(node = {}, walker = this.#tree) {\n    let current;\n    let refNode = walker.currentNode;\n    if (node.nodeType === ELEMENT_NODE && refNode === node) {\n      current = refNode;\n    } else {\n      if (refNode !== walker.root) {\n        while (refNode) {\n          if (refNode === walker.root ||\n              (node.nodeType === ELEMENT_NODE && refNode === node)) {\n            break;\n          }\n          refNode = walker.parentNode();\n        }\n      }\n      if (node.nodeType === ELEMENT_NODE) {\n        while (refNode) {\n          if (refNode === node) {\n            current = refNode;\n            break;\n          }\n          refNode = walker.nextNode();\n        }\n      } else {\n        current = refNode;\n      }\n    }\n    return current ?? null;\n  }\n\n  /**\n   * collect nth child\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node, opt) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    let matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#cache.has(selector)) {\n        selectorBranches = this.#cache.get(selector);\n      } else {\n        selectorBranches = walkAST(selector);\n        this.#cache.set(selector, selectorBranches);\n      }\n    }\n    if (parentNode) {\n      const walker = this.#document.createTreeWalker(parentNode, WALKER_FILTER);\n      let l = 0;\n      let refNode = walker.firstChild();\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      refNode = this._traverse(parentNode, walker);\n      const selectorNodes = new Set();\n      if (selectorBranches) {\n        refNode = this._traverse(parentNode, walker);\n        refNode = walker.firstChild();\n        while (refNode) {\n          let bool;\n          for (const leaves of selectorBranches) {\n            bool = this._matchLeaves(leaves, refNode, opt);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            selectorNodes.add(refNode);\n          }\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            let i = 0;\n            refNode = this._traverse(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            let i = 0;\n            refNode = this._traverse(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        matched = new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, parentNode, prefix } = node;\n    let matched = new Set();\n    if (parentNode) {\n      const walker = this.#document.createTreeWalker(parentNode, WALKER_FILTER);\n      let l = 0;\n      let refNode = walker.firstChild();\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          let j = 0;\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          while (refNode) {\n            const { localName: itemLocalName, prefix: itemPrefix } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          let j = a > 0 ? 0 : b - 1;\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          while (refNode) {\n            const { localName: itemLocalName, prefix: itemPrefix } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        matched = new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName, opt) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const identName = unescapeSelector(nthIdentName);\n    const anbMap = new Map();\n    if (identName) {\n      if (identName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (identName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    let matched = new Set();\n    if (anbMap.has('a') && anbMap.has('b')) {\n      if (/^nth-(?:last-)?child$/.test(nthName)) {\n        if (selector) {\n          anbMap.set('selector', selector);\n        }\n        const anb = Object.fromEntries(anbMap);\n        const nodes = this._collectNthChild(anb, node, opt);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      } else if (/^nth-(?:last-)?of-type$/.test(nthName)) {\n        const anb = Object.fromEntries(anbMap);\n        const nodes = this._collectNthOfType(anb, node);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match directionality pseudo-class - :dir()\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchDirectionPseudoClass(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    const dir = getDirectionality(node);\n    let res;\n    if (astName === dir) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match language pseudo-class - :lang()\n   * @private\n   * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLanguagePseudoClass(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (astName === '*') {\n      if (node.hasAttribute('lang')) {\n        if (node.getAttribute('lang')) {\n          res = node;\n        }\n      } else {\n        let parent = node.parentNode;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              if (parent.getAttribute('lang')) {\n                res = node;\n              }\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n      }\n    } else if (astName) {\n      const langPart = `(?:-${ALPHA_NUM})*`;\n      const regLang = new RegExp(`^(?:\\\\*-)?${ALPHA_NUM}${langPart}$`, 'i');\n      if (regLang.test(astName)) {\n        let regExtendedLang;\n        if (astName.indexOf('-') > -1) {\n          const [langMain, langSub, ...langRest] = astName.split('-');\n          let extendedMain;\n          if (langMain === '*') {\n            extendedMain = `${ALPHA_NUM}${langPart}`;\n          } else {\n            extendedMain = `${langMain}${langPart}`;\n          }\n          const extendedSub = `-${langSub}${langPart}`;\n          const len = langRest.length;\n          let extendedRest = '';\n          if (len) {\n            for (let i = 0; i < len; i++) {\n              extendedRest += `-${langRest[i]}${langPart}`;\n            }\n          }\n          regExtendedLang =\n            new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n        } else {\n          regExtendedLang = new RegExp(`^${astName}${langPart}$`, 'i');\n        }\n        if (node.hasAttribute('lang')) {\n          if (regExtendedLang.test(node.getAttribute('lang'))) {\n            res = node;\n          }\n        } else {\n          let parent = node.parentNode;\n          while (parent) {\n            if (parent.nodeType === ELEMENT_NODE) {\n              if (parent.hasAttribute('lang')) {\n                const value = parent.getAttribute('lang');\n                if (regExtendedLang.test(value)) {\n                  res = node;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(leaves, node, opt = {}) {\n    let bool;\n    if (Array.isArray(leaves) && leaves.length) {\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      opt.dir = DIR_NEXT;\n      const nodes = this._matchCombinator(twig, node, opt);\n      if (nodes.size) {\n        if (leaves.length) {\n          for (const nextNode of nodes) {\n            bool = this._matchHasPseudoFunc(Object.assign([], leaves),\n              nextNode, opt);\n            if (bool) {\n              break;\n            }\n          }\n        } else {\n          bool = true;\n        }\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @private\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node, opt = {}) {\n    const {\n      astName = '', branches = [], selector = '', twigBranches = []\n    } = astData;\n    let res;\n    if (astName === 'has') {\n      if (selector.includes(':has(')) {\n        res = null;\n      } else {\n        let bool;\n        for (const leaves of branches) {\n          bool = this._matchHasPseudoFunc(Object.assign([], leaves), node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else {\n      const forgive = /^(?:is|where)$/.test(astName);\n      opt.forgive = forgive;\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, opt);\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            opt.dir = DIR_PREV;\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, opt);\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (!bool) {\n          res = node;\n        }\n      } else if (bool) {\n        res = node;\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @private\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive unknown pseudo-class\n   * @param {boolean} [opt.warn] - warn unsupported pseudo-class\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt = {}) {\n    const { children: astChildren } = ast;\n    const { localName, parentNode } = node;\n    const {\n      forgive,\n      warn = this.#warn\n    } = opt;\n    const astName = unescapeSelector(ast.name);\n    let matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (REG_LOGICAL_PSEUDO.test(astName)) {\n      let astData;\n      if (this.#cache.has(ast)) {\n        astData = this.#cache.get(ast);\n      } else {\n        const branches = walkAST(ast);\n        const selectors = [];\n        const twigBranches = [];\n        for (const [...leaves] of branches) {\n          for (const leaf of leaves) {\n            const css = generateCSS(leaf);\n            selectors.push(css);\n          }\n          const branch = [];\n          const leavesSet = new Set();\n          let item = leaves.shift();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              branch.push({\n                combo: item,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n            } else if (item) {\n              leavesSet.add(item);\n            }\n            if (leaves.length) {\n              item = leaves.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n              break;\n            }\n          }\n          twigBranches.push(branch);\n        }\n        astData = {\n          astName,\n          branches,\n          twigBranches,\n          selector: selectors.join(',')\n        };\n        this.#cache.set(ast, astData);\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node, opt);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      const [branch] = astChildren;\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        const nodes = this._matchAnPlusB(branch, node, astName, opt);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      // :dir()\n      } else if (astName === 'dir') {\n        const res = this._matchDirectionPseudoClass(branch, node);\n        if (res) {\n          matched.add(res);\n        }\n      // :lang()\n      } else if (astName === 'lang') {\n        const res = this._matchLanguagePseudoClass(branch, node);\n        if (res) {\n          matched.add(res);\n        }\n      } else {\n        switch (astName) {\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (warn) {\n              const msg = `Unsupported pseudo-class :${astName}()`;\n              throw new DOMException(msg, NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          default: {\n            if (!forgive) {\n              const msg = `Unknown pseudo-class :${astName}()`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      const regAnchor = /^a(?:rea)?$/;\n      const regFormCtrl =\n        /^(?:(?:fieldse|inpu|selec)t|button|opt(?:group|ion)|textarea)$/;\n      const regFormValidity = /^(?:(?:inpu|selec)t|button|form|textarea)$/;\n      const regInteract = /^d(?:etails|ialog)$/;\n      const regTypeCheck = /^(?:checkbox|radio)$/;\n      const regTypeDate = /^(?:date(?:time-local)?|month|time|week)$/;\n      const regTypeRange =\n        /(?:(?:rang|tim)e|date(?:time-local)?|month|number|week)$/;\n      const regTypeText = /^(?:(?:emai|te|ur)l|number|password|search|text)$/;\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if (regAnchor.test(localName) && node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if (regAnchor.test(localName) && node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#document.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#document.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#document.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#document.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#document.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === this.#document.activeElement &&\n              this.#window.getComputedStyle(node).display !== 'none') {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-within': {\n          let current = this.#document.activeElement;\n          while (current) {\n            if (current === node) {\n              if (this.#window.getComputedStyle(node).display !== 'none') {\n                matched.add(node);\n              }\n              break;\n            }\n            current = current.parentNode;\n          }\n          break;\n        }\n        case 'open': {\n          if (regInteract.test(localName) && node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'closed': {\n          if (regInteract.test(localName) && !node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'disabled': {\n          if (regFormCtrl.test(localName) || isCustomElementName(localName)) {\n            if (node.disabled || node.hasAttribute('disabled')) {\n              matched.add(node);\n            } else {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset') {\n                  break;\n                }\n                parent = parent.parentNode;\n              }\n              if (parent && parentNode.localName !== 'legend' &&\n                  parent.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'enabled': {\n          if ((regFormCtrl.test(localName) || isCustomElementName(localName)) &&\n              !(node.disabled && node.hasAttribute('disabled'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'read-only': {\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || regTypeDate.test(node.type) ||\n                   regTypeText.test(node.type)) &&\n                  (node.readonly || node.hasAttribute('readonly') ||\n                   node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (!isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'read-write': {\n          switch (localName) {\n            case 'textarea': {\n              if (!(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || regTypeDate.test(node.type) ||\n                   regTypeText.test(node.type)) &&\n                  !(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let targetNode;\n          if (localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              if (regTypeText.test(node.getAttribute('type'))) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode && node.value === '' &&\n              node.hasAttribute('placeholder') &&\n              node.getAttribute('placeholder').trim().length) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'checked': {\n          if ((node.checked && localName === 'input' &&\n               node.hasAttribute('type') &&\n               regTypeCheck.test(node.getAttribute('type'))) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#document.documentElement;\n            }\n            let checked;\n            const items = parent.getElementsByTagName('input');\n            const l = items.length;\n            if (l) {\n              for (let i = 0; i < l; i++) {\n                const item = items[i];\n                if (item.getAttribute('type') === 'radio') {\n                  if (nodeName) {\n                    if (item.getAttribute('name') === nodeName) {\n                      checked = !!item.checked;\n                    }\n                  } else if (!item.hasAttribute('name')) {\n                    checked = !!item.checked;\n                  }\n                  if (checked) {\n                    break;\n                  }\n                }\n              }\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          const regTypeReset = /^(?:button|reset)$/;\n          const regTypeSubmit = /^(?:image|submit)$/;\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') &&\n                 regTypeReset.test(node.getAttribute('type')))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               regTypeSubmit.test(node.getAttribute('type')))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker =\n                this.#document.createTreeWalker(form, SHOW_ELEMENT);\n              let nextNode = walker.firstChild();\n              while (nextNode) {\n                const nodeName = nextNode.localName;\n                let m;\n                if (nodeName === 'button') {\n                  m = !(nextNode.hasAttribute('type') &&\n                    regTypeReset.test(nextNode.getAttribute('type')));\n                } else if (nodeName === 'input') {\n                  m = nextNode.hasAttribute('type') &&\n                    regTypeSubmit.test(nextNode.getAttribute('type'));\n                }\n                if (m) {\n                  if (nextNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                nextNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     regTypeCheck.test(node.getAttribute('type')) &&\n                     (node.checked || node.hasAttribute('checked'))) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option') {\n            let isMultiple = false;\n            let parent = parentNode;\n            while (parent) {\n              if (parent.localName === 'datalist') {\n                break;\n              } else if (parent.localName === 'select') {\n                if (parent.multiple || parent.hasAttribute('multiple')) {\n                  isMultiple = true;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (isMultiple) {\n              if (node.selected || node.hasAttribute('selected')) {\n                matched.add(node);\n              }\n            } else {\n              const defaultOpt = new Set();\n              const walker =\n                this.#document.createTreeWalker(parentNode, SHOW_ELEMENT);\n              let refNode = walker.firstChild();\n              while (refNode) {\n                if (refNode.selected || refNode.hasAttribute('selected')) {\n                  defaultOpt.add(refNode);\n                  break;\n                }\n                refNode = walker.nextSibling();\n              }\n              if (defaultOpt.size) {\n                if (defaultOpt.has(node)) {\n                  matched.add(node);\n                }\n              }\n            }\n          }\n          break;\n        }\n        case 'valid': {\n          if (regFormValidity.test(localName)) {\n            if (node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            let bool;\n            const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n            let refNode = walker.firstChild();\n            while (refNode) {\n              if (regFormValidity.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'invalid': {\n          if (regFormValidity.test(localName)) {\n            if (!node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            let bool;\n            const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n            let refNode = walker.firstChild();\n            while (refNode) {\n              if (regFormValidity.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (!bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              regTypeRange.test(node.getAttribute('type')) &&\n              !(node.validity.rangeUnderflow ||\n                node.validity.rangeOverflow) &&\n              (node.hasAttribute('min') || node.hasAttribute('max') ||\n               node.getAttribute('type') === 'range')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'out-of-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              regTypeRange.test(node.getAttribute('type')) &&\n              (node.validity.rangeUnderflow || node.validity.rangeOverflow)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'required': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || regTypeCheck.test(inputType) ||\n                  regTypeDate.test(inputType) || regTypeText.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              (node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'optional': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || regTypeCheck.test(inputType) ||\n                  regTypeDate.test(inputType) || regTypeText.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              !(node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            let bool;\n            const walker = this.#document.createTreeWalker(node, SHOW_ALL);\n            let refNode = walker.firstChild();\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode && node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) || node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (warn) {\n            const msg = `Unsupported pseudo-element ::${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        case 'active':\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'defined':\n        case 'focus-visible':\n        case 'fullscreen':\n        case 'future':\n        case 'hover':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (warn) {\n            const msg = `Unsupported pseudo-class :${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (warn) {\n              const msg = `Unsupported pseudo-class :${astName}`;\n              throw new DOMException(msg, NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            const msg = `Unknown pseudo-class :${astName}`;\n            throw new DOMException(msg, SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match shadow host pseudo class\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren } = ast;\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (Array.isArray(astChildren)) {\n      const [branch] = walkAST(astChildren[0]);\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            const msg = `Invalid selector ${css}`;\n            throw new DOMException(msg, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      } else if (astName === 'host-context') {\n        let bool;\n        let parent = host;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              const msg = `Invalid selector ${css}`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else if (astName === 'host') {\n      res = node;\n    } else {\n      const msg = `Invalid selector :${astName}`;\n      throw new DOMException(msg, SYNTAX_ERR);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt) {\n    const { type: astType } = ast;\n    const astName = unescapeSelector(ast.name);\n    let matched = new Set();\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case SELECTOR_PSEUDO_CLASS: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          if (nodes.size) {\n            matched = nodes;\n          }\n          break;\n        }\n        case SELECTOR_PSEUDO_ELEMENT: {\n          matchPseudoElementSelector(astName, opt);\n          break;\n        }\n        default: {\n          const res = matchSelector(ast, node, opt);\n          if (res) {\n            matched.add(res);\n          }\n        }\n      }\n    } else if (this.#shadow && astType === SELECTOR_PSEUDO_CLASS &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (astName !== 'has' && REG_LOGICAL_PSEUDO.test(astName)) {\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      } else if (REG_SHADOW_HOST.test(astName)) {\n        const res = this._matchShadowHostPseudoClass(ast, node, opt);\n        if (res) {\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let bool;\n    if (this.#results.has(leaves)) {\n      const result = this.#results.get(leaves);\n      if (result.has(node)) {\n        bool = result.get(node);\n      } else {\n        for (const leaf of leaves) {\n          bool = this._matchSelector(leaf, node, opt).has(node);\n          if (!bool) {\n            break;\n          }\n        }\n        result.set(node, bool);\n        this.#results.set(leaves, result);\n      }\n    } else {\n      for (const leaf of leaves) {\n        bool = this._matchSelector(leaf, node, opt).has(node);\n        if (!bool) {\n          break;\n        }\n      }\n      const result = new WeakMap();\n      result.set(node, bool);\n      this.#results.set(leaves, result);\n    }\n    return !!bool;\n  }\n\n  /**\n   * match HTML collection\n   * @private\n   * @param {object} items - HTML collection\n   * @param {object} opt - options\n   * @returns {Set.<object>} - matched nodes\n   */\n  _matchHTMLCollection(items, opt = {}) {\n    const { compound, filterLeaves } = opt;\n    let nodes = new Set();\n    const l = items.length;\n    if (l) {\n      if (compound) {\n        for (let i = 0; i < l; i++) {\n          const item = items[i];\n          const bool = this._matchLeaves(filterLeaves, item, opt);\n          if (bool) {\n            nodes.add(item);\n          }\n        }\n      } else {\n        const arr = [].slice.call(items);\n        nodes = new Set(arr);\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * find descendant nodes\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node\n   * @param {object} opt - options\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode, opt) {\n    const [leaf, ...filterLeaves] = leaves;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const compound = filterLeaves.length > 0;\n    let nodes = new Set();\n    let pending = false;\n    if (this.#shadow) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case SELECTOR_PSEUDO_ELEMENT: {\n          matchPseudoElementSelector(leafName, opt);\n          break;\n        }\n        case SELECTOR_ID: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node, opt);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case SELECTOR_CLASS: {\n          const items = baseNode.getElementsByClassName(leafName);\n          nodes = this._matchHTMLCollection(items, {\n            compound,\n            filterLeaves\n          });\n          break;\n        }\n        case SELECTOR_TYPE: {\n          if (this.#document.contentType === 'text/html' &&\n              !/[*|]/.test(leafName)) {\n            const items = baseNode.getElementsByTagName(leafName);\n            nodes = this._matchHTMLCollection(items, {\n              compound,\n              filterLeaves\n            });\n          } else {\n            pending = true;\n          }\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    return {\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * match combinator\n   * @private\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt = {}) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { dir } = opt;\n    let matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          const { parentNode } = node;\n          if (parentNode) {\n            const walker =\n              this.#document.createTreeWalker(parentNode, SHOW_ELEMENT);\n            let refNode = this._traverse(node, walker);\n            if (refNode === node) {\n              refNode = walker.nextSibling();\n            }\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextSibling();\n            }\n          }\n          break;\n        }\n        case '>': {\n          const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n          let refNode = walker.firstChild();\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = walker.nextSibling();\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const { nodes, pending } = this._findDescendantNodes(leaves, node);\n          if (nodes.size) {\n            matched = nodes;\n          } else if (pending) {\n            const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n            let refNode = walker.nextNode();\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextNode();\n            }\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          const walker =\n            this.#document.createTreeWalker(node.parentNode, SHOW_ELEMENT);\n          let refNode = walker.firstChild();\n          while (refNode) {\n            if (refNode === node) {\n              break;\n            } else {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n            }\n            refNode = walker.nextSibling();\n          }\n          break;\n        }\n        case '>': {\n          const refNode = node.parentNode;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = node.parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            matched = new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node from finder\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} [opt] - options\n   * @param {object} [opt.node] - node to start from\n   * @returns {?object} - matched node\n   */\n  _findNode(leaves, opt = {}) {\n    const { node } = opt;\n    let matchedNode;\n    let refNode = this._traverse(node, this.#finder);\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = this.#finder.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = this.#finder.nextNode();\n        }\n      }\n      while (refNode) {\n        let bool;\n        if (this.#node.nodeType === ELEMENT_NODE) {\n          if (refNode === this.#node) {\n            bool = true;\n          } else {\n            bool = this.#node.contains(refNode);\n          }\n        } else {\n          bool = true;\n        }\n        if (bool) {\n          const matched = this._matchLeaves(leaves, refNode, {\n            warn: this.#warn\n          });\n          if (matched) {\n            matchedNode = refNode;\n            break;\n          }\n        }\n        refNode = this.#finder.nextNode();\n      }\n    }\n    return matchedNode ?? null;\n  }\n\n  /**\n   * match self\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _matchSelf(leaves) {\n    const nodes = [];\n    let filtered = false;\n    const bool = this._matchLeaves(leaves, this.#node);\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find lineal\n   * @private\n   * @param {Array} leaf - AST leaf\n   * @param {object} opt - options\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findLineal(leaf, opt = {}) {\n    const { complex, compound, filterLeaves } = opt;\n    const nodes = [];\n    let filtered = false;\n    let bool = this._matchLeaves([leaf], this.#node);\n    if (bool && !complex) {\n      if (compound) {\n        bool = this._matchLeaves(filterLeaves, this.#node);\n        if (bool) {\n          nodes.push(this.#node);\n          filtered = true;\n        }\n      } else {\n        nodes.push(this.#node);\n        filtered = true;\n      }\n    }\n    if (!bool || complex) {\n      if (bool) {\n        nodes.push(this.#node);\n        if (!compound) {\n          filtered = true;\n        }\n      }\n      let refNode = this.#node.parentNode;\n      while (refNode) {\n        bool = this._matchLeaves([leaf], refNode);\n        if (bool) {\n          nodes.push(refNode);\n          if (!compound) {\n            filtered = true;\n          }\n        }\n        if (refNode.parentNode) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find first\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findFirst(leaves) {\n    const nodes = [];\n    let filtered = false;\n    const node = this._findNode(leaves, {\n      node: this.#node\n    });\n    if (node) {\n      nodes.push(node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find from HTML collection\n   * @private\n   * @param {object} items - HTML collection\n   * @param {object} opt - options\n   * @param {boolean} [opt.compound] - compound selector\n   * @param {Array} [opt.filterLeaves] - filter leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findFromHTMLCollection(items, opt = {}) {\n    const { compound, filterLeaves } = opt;\n    let nodes = [];\n    let filtered = false;\n    const l = items.length;\n    if (l) {\n      if (this.#node.nodeType === ELEMENT_NODE) {\n        for (let i = 0; i < l; i++) {\n          const node = items[i];\n          if (node === this.#node || isInclusive(node, this.#node)) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        }\n      } else if (compound) {\n        for (let i = 0; i < l; i++) {\n          const node = items[i];\n          const bool = this._matchLeaves(filterLeaves, node, {\n            warn: this.#warn\n          });\n          if (bool) {\n            nodes.push(node);\n            filtered = true;\n          }\n        }\n      } else {\n        nodes = [].slice.call(items);\n        filtered = true;\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find entry nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @param {boolean} complex - complex selector\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType, complex) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const compound = filterLeaves.length > 0;\n    let nodes = [];\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case SELECTOR_PSEUDO_ELEMENT: {\n        matchPseudoElementSelector(leafName, {\n          warn: this.#warn\n        });\n        break;\n      }\n      case SELECTOR_ID: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaf, {\n            complex,\n            compound,\n            filterLeaves\n          });\n        } else if (targetType === TARGET_FIRST &&\n                   this.#root.nodeType !== ELEMENT_NODE) {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      case SELECTOR_CLASS: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaf, {\n            complex,\n            compound,\n            filterLeaves\n          });\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else if (this.#root.nodeType === DOCUMENT_NODE) {\n          const items = this.#root.getElementsByClassName(leafName);\n          [nodes, filtered] = this._findFromHTMLCollection(items, {\n            compound,\n            filterLeaves\n          });\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      case SELECTOR_TYPE: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaf, {\n            complex,\n            compound,\n            filterLeaves\n          });\n        } else if (this.#document.contentType === 'text/html' &&\n                   this.#root.nodeType === DOCUMENT_NODE &&\n                   !/[*|]/.test(leafName)) {\n          const items = this.#root.getElementsByTagName(leafName);\n          [nodes, filtered] = this._findFromHTMLCollection(items, {\n            compound,\n            filterLeaves\n          });\n        } else {\n          pending = true;\n        }\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL && REG_SHADOW_HOST.test(leafName)) {\n          if (this.#shadow &&\n              this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            const node = this._matchShadowHostPseudoClass(leaf, this.#node);\n            if (node) {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaf, {\n            complex,\n            compound,\n            filterLeaves\n          });\n        } else if (targetType === TARGET_FIRST) {\n          [nodes, filtered] = this._findFirst(leaves);\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * get entry twig\n   * @private\n   * @param {Array.<object>} branch - AST branch\n   * @param {string} targetType - target type\n   * @returns {object} - direction and twig\n   */\n  _getEntryTwig(branch, targetType) {\n    const branchLen = branch.length;\n    const complex = branchLen > 1;\n    const firstTwig = branch[0];\n    let dir;\n    let twig;\n    if (complex) {\n      const {\n        combo: firstCombo,\n        leaves: [{\n          name: firstName,\n          type: firstType\n        }]\n      } = firstTwig;\n      const lastTwig = branch[branchLen - 1];\n      const {\n        leaves: [{\n          name: lastName,\n          type: lastType\n        }]\n      } = lastTwig;\n      if (lastType === SELECTOR_PSEUDO_ELEMENT || lastType === SELECTOR_ID) {\n        dir = DIR_PREV;\n        twig = lastTwig;\n      } else if (firstType === SELECTOR_PSEUDO_ELEMENT ||\n                 firstType === SELECTOR_ID) {\n        dir = DIR_NEXT;\n        twig = firstTwig;\n      } else if (targetType === TARGET_ALL) {\n        if (firstName === '*' && firstType === SELECTOR_TYPE) {\n          dir = DIR_PREV;\n          twig = lastTwig;\n        } else if (lastName === '*' && lastType === SELECTOR_TYPE) {\n          dir = DIR_NEXT;\n          twig = firstTwig;\n        } else if (branchLen === 2) {\n          const { name: comboName } = firstCombo;\n          if (/^[+~]$/.test(comboName)) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          }\n        } else {\n          dir = DIR_NEXT;\n          twig = firstTwig;\n        }\n      } else if (lastName === '*' && lastType === SELECTOR_TYPE) {\n        dir = DIR_NEXT;\n        twig = firstTwig;\n      } else if (firstName === '*' && firstType === SELECTOR_TYPE) {\n        dir = DIR_PREV;\n        twig = lastTwig;\n      } else {\n        let bool;\n        let sibling;\n        for (const { combo, leaves: [leaf] } of branch) {\n          const { type: leafType } = leaf;\n          const leafName = unescapeSelector(leaf.name);\n          if (leafType === SELECTOR_PSEUDO_CLASS && leafName === 'dir') {\n            bool = false;\n            break;\n          }\n          if (combo && !sibling) {\n            const { name: comboName } = combo;\n            if (/^[+~]$/.test(comboName)) {\n              bool = true;\n              sibling = true;\n            }\n          }\n        }\n        if (bool) {\n          dir = DIR_NEXT;\n          twig = firstTwig;\n        } else {\n          dir = DIR_PREV;\n          twig = lastTwig;\n        }\n      }\n    } else {\n      dir = DIR_PREV;\n      twig = firstTwig;\n    }\n    return {\n      complex,\n      dir,\n      twig\n    };\n  }\n\n  /**\n   * collect nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const { complex, dir, twig } = this._getEntryTwig(branch, targetType);\n        const {\n          compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#finder;\n        } else {\n          node = this.#root;\n          walker = this.#tree;\n        }\n        let nextNode = this._traverse(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode, {\n                warn: this.#warn\n              });\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].push(nextNode);\n              }\n            }\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const complex = branch.length > 1;\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * match nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchNodes(targetType) {\n    const [...branches] = this.#ast;\n    const l = branches.length;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, dir, filtered, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = this.#nodes[i];\n        const entryNodesLen = entryNodes.length;\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          const { leaves: [, ...filterLeaves] } = branch[0];\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              if (node !== this.#node && this.#node.contains(node)) {\n                nodes.add(node);\n                if (targetType !== TARGET_ALL) {\n                  break;\n                }\n              }\n            }\n          } else if (filterLeaves.length) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              const bool = filtered || this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.add(node);\n                if (targetType !== TARGET_ALL) {\n                  break;\n                }\n              }\n            }\n          } else if (targetType === TARGET_ALL) {\n            if (nodes.size) {\n              const n = [...nodes];\n              nodes = new Set([...n, ...entryNodes]);\n              this.#sort = true;\n            } else {\n              nodes = new Set([...entryNodes]);\n            }\n          } else {\n            const [node] = [...entryNodes];\n            nodes.add(node);\n          }\n        } else if (dir === DIR_NEXT) {\n          let { combo, leaves: entryLeaves } = branch[0];\n          let matched;\n          for (let j = 0; j < entryNodesLen; j++) {\n            const node = entryNodes[j];\n            let nextNodes = new Set([node]);\n            for (let j = 1; j < branchLen; j++) {\n              const { combo: nextCombo, leaves } = branch[j];\n              const arr = [];\n              for (const nextNode of nextNodes) {\n                const twig = {\n                  combo,\n                  leaves\n                };\n                const m = this._matchCombinator(twig, nextNode, {\n                  dir,\n                  warn: this.#warn\n                });\n                if (m.size) {\n                  arr.push(...m);\n                }\n              }\n              if (arr.length) {\n                if (j === lastIndex) {\n                  if (targetType === TARGET_ALL) {\n                    if (nodes.size) {\n                      const n = [...nodes];\n                      nodes = new Set([...n, ...arr]);\n                    } else {\n                      nodes = new Set([...arr]);\n                    }\n                    this.#sort = true;\n                  } else {\n                    const [node] = sortNodes(arr);\n                    nodes.add(node);\n                  }\n                  matched = true;\n                } else {\n                  combo = nextCombo;\n                  nextNodes = new Set(arr);\n                  matched = false;\n                }\n              } else {\n                matched = false;\n                break;\n              }\n            }\n            if (matched && targetType !== TARGET_ALL) {\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const [entryNode] = [...entryNodes];\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode\n            });\n            while (refNode) {\n              let nextNodes = new Set([refNode]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const arr = [];\n                for (const nextNode of nextNodes) {\n                  const twig = {\n                    combo,\n                    leaves\n                  };\n                  const m = this._matchCombinator(twig, nextNode, {\n                    dir,\n                    warn: this.#warn\n                  });\n                  if (m.size) {\n                    arr.push(...m);\n                  }\n                }\n                if (arr.length) {\n                  if (j === lastIndex) {\n                    const [node] = sortNodes(arr);\n                    nodes.add(node);\n                    matched = true;\n                  } else {\n                    combo = nextCombo;\n                    nextNodes = new Set(arr);\n                    matched = false;\n                  }\n                } else {\n                  matched = false;\n                  break;\n                }\n              }\n              if (matched) {\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode\n              });\n              nextNodes = new Set([refNode]);\n            }\n          }\n        } else {\n          const { leaves: entryLeaves } = branch[lastIndex];\n          let matched;\n          for (let j = 0; j < entryNodesLen; j++) {\n            const node = entryNodes[j];\n            let nextNodes = new Set([node]);\n            for (let j = lastIndex - 1; j >= 0; j--) {\n              const twig = branch[j];\n              const arr = [];\n              for (const nextNode of nextNodes) {\n                const m = this._matchCombinator(twig, nextNode, {\n                  dir,\n                  warn: this.#warn\n                });\n                if (m.size) {\n                  arr.push(...m);\n                }\n              }\n              if (arr.length) {\n                if (j === 0) {\n                  nodes.add(node);\n                  matched = true;\n                  if (targetType === TARGET_ALL &&\n                      branchLen > 1 && nodes.size > 1) {\n                    this.#sort = true;\n                  }\n                } else {\n                  nextNodes = new Set(arr);\n                  matched = false;\n                }\n              } else {\n                matched = false;\n                break;\n              }\n            }\n            if (matched && targetType !== TARGET_ALL) {\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const [entryNode] = [...entryNodes];\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode\n            });\n            while (refNode) {\n              let nextNodes = new Set([refNode]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                const arr = [];\n                for (const nextNode of nextNodes) {\n                  const m = this._matchCombinator(twig, nextNode, {\n                    dir,\n                    warn: this.#warn\n                  });\n                  if (m.size) {\n                    arr.push(...m);\n                  }\n                }\n                if (arr.length) {\n                  if (j === 0) {\n                    nodes.add(refNode);\n                    matched = true;\n                  } else {\n                    nextNodes = new Set(arr);\n                    matched = false;\n                  }\n                } else {\n                  matched = false;\n                  break;\n                }\n              }\n              if (matched) {\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode\n              });\n              nextNodes = new Set([refNode]);\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * find matched nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _find(targetType) {\n    this._collectNodes(targetType);\n    const nodes = this._matchNodes(targetType);\n    return nodes;\n  }\n\n  /**\n   * matches\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - `true` if matched `false` otherwise\n   */\n  matches(selector, node, opt) {\n    let res;\n    try {\n      this.#node = this._setup(selector, node, opt);\n      if (node.nodeType !== ELEMENT_NODE) {\n        const msg = `Unexpected node ${node.nodeName}`;\n        throw new TypeError(msg);\n      }\n      const nodes = this._find(TARGET_SELF);\n      res = nodes.size;\n    } catch (e) {\n      this._onError(e);\n    }\n    return !!res;\n  }\n\n  /**\n   * closest\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  closest(selector, node, opt) {\n    let res;\n    try {\n      this.#node = this._setup(selector, node, opt);\n      if (node.nodeType !== ELEMENT_NODE) {\n        const msg = `Unexpected node ${node.nodeName}`;\n        throw new TypeError(msg);\n      }\n      const nodes = this._find(TARGET_LINEAL);\n      if (nodes.size) {\n        let refNode = this.#node;\n        while (refNode) {\n          if (nodes.has(refNode)) {\n            res = refNode;\n            break;\n          }\n          refNode = refNode.parentNode;\n        }\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  querySelector(selector, node, opt) {\n    let res;\n    try {\n      this.#node = this._setup(selector, node, opt);\n      this._prepareTreeWalkers(node);\n      const nodes = this._find(TARGET_FIRST);\n      nodes.delete(this.#node);\n      if (nodes.size) {\n        [res] = sortNodes(nodes);\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector all\n   * NOTE: returns Array, not NodeList\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {Array.<object|undefined>} - collection of matched nodes\n   */\n  querySelectorAll(selector, node, opt) {\n    let res;\n    try {\n      this.#node = this._setup(selector, node, opt);\n      this._prepareTreeWalkers(node);\n      const nodes = this._find(TARGET_ALL);\n      nodes.delete(this.#node);\n      if (nodes.size) {\n        if (this.#sort) {\n          res = sortNodes(nodes);\n        } else {\n          res = [...nodes];\n        }\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? [];\n  }\n};\n"],
  "mappings": "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",
  "names": ["finder_exports", "__export", "Finder", "__toCommonJS", "import_is_potential_custom_element_name", "import_dom_util", "import_matcher", "import_parser", "import_constant", "DIR_NEXT", "DIR_PREV", "TARGET_ALL", "TARGET_FIRST", "TARGET_LINEAL", "TARGET_SELF", "WALKER_FILTER", "#ast", "#cache", "#document", "#finder", "#node", "#nodes", "#noexcept", "#results", "#root", "#shadow", "#sort", "#tree", "#warn", "#window", "e", "selector", "node", "opt", "noexcept", "warn", "nodes", "ast", "cachedItem", "l", "i", "cssAst", "branches", "items", "branch", "item", "leaves", "nextItem", "msg", "itemName", "walker", "current", "refNode", "anb", "a", "b", "reverse", "parentNode", "matched", "selectorBranches", "selectorNodes", "bool", "nth", "j", "localName", "prefix", "itemLocalName", "itemPrefix", "m", "nthName", "nthIdentName", "identName", "anbMap", "astName", "dir", "res", "parent", "langPart", "regExtendedLang", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "value", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "twigBranches", "forgive", "lastIndex", "nextNodes", "arr", "astChildren", "selectors", "css", "leavesSet", "regAnchor", "regFormCtrl", "regFormValidity", "regInteract", "regTypeCheck", "regTypeDate", "regTypeRange", "regTypeText", "href", "origin", "pathname", "attrURL", "hash", "id", "isCustomElementName", "targetNode", "nodeName", "checked", "regTypeReset", "regTypeSubmit", "form", "isMultiple", "defaultOpt", "inputType", "node1", "node2", "host", "astType", "result", "compound", "filterLeaves", "baseNode", "leafName", "pending", "comboName", "matchedNode", "filtered", "complex", "targetType", "branchLen", "firstTwig", "firstCombo", "firstName", "firstType", "lastTwig", "lastName", "lastType", "sibling", "pendingItems", "pendingItem", "index", "find", "entryNodes", "entryNodesLen", "n", "entryLeaves", "nextCombo", "entryNode"]
}
