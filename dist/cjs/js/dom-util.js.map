{
  "version": 3,
  "sources": ["../../../src/js/dom-util.js"],
  "sourcesContent": ["/**\n * dom-util.js\n */\n\n/* import */\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, REG_DIR, REG_SHADOW_MODE,\n  TEXT_NODE, TYPE_FROM, TYPE_TO, WALKER_FILTER\n} from './constant.js';\n\n/**\n * verify node\n * @param {*} node - node\n * @throws\n * @returns {object} - Document, DocumentFragment, Element node\n */\nexport const verifyNode = node => {\n  if (!node || !node.nodeType || !node.nodeName) {\n    const type = Object.prototype.toString.call(node).slice(TYPE_FROM, TYPE_TO);\n    const msg = `Unexpected type ${type}`;\n    throw new TypeError(msg);\n  } else if (!(node.nodeType === DOCUMENT_NODE ||\n               node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n               node.nodeType === ELEMENT_NODE)) {\n    const msg = `Unexpected node ${node.nodeName}`;\n    throw new TypeError(msg);\n  }\n  return node;\n};\n\n/**\n * resolve content document, root node and tree walker\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object>} - array of document, root node, tree walker\n */\nexport const resolveContent = node => {\n  node = verifyNode(node);\n  let document;\n  let root;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      document = node.ownerDocument;\n      root = node;\n      break;\n    }\n    case ELEMENT_NODE:\n    default: {\n      document = node.ownerDocument;\n      let parent = node;\n      while (parent) {\n        if (parent.parentNode) {\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      root = parent;\n      break;\n    }\n  }\n  const walker = document.createTreeWalker(root, WALKER_FILTER);\n  return [\n    document,\n    root,\n    walker\n  ];\n};\n\n/**\n * traverse node tree\n * @private\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker) => {\n  let current;\n  if (!node || !node.nodeType) {\n    // throws\n    verifyNode(node);\n  } else if (walker?.currentNode) {\n    let refNode = walker.currentNode;\n    if (refNode === node) {\n      current = refNode;\n    } else if (refNode.contains(node)) {\n      refNode = walker.nextNode();\n      while (refNode) {\n        if (refNode === node) {\n          current = refNode;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n    } else {\n      if (refNode !== walker.root) {\n        while (refNode) {\n          if (refNode === walker.root || refNode === node) {\n            break;\n          }\n          refNode = walker.parentNode();\n        }\n      }\n      if (node.nodeType === ELEMENT_NODE) {\n        while (refNode) {\n          if (refNode === node) {\n            current = refNode;\n            break;\n          }\n          refNode = walker.nextNode();\n        }\n      } else {\n        current = refNode;\n      }\n    }\n  }\n  return current ?? null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  let bool;\n  if (!node || !node.nodeType) {\n    // throws\n    verifyNode(node);\n  } else if (node.nodeType === ELEMENT_NODE) {\n    const { localName, ownerDocument } = node;\n    const { formAssociated } = opt;\n    const window = ownerDocument.defaultView;\n    let elmConstructor;\n    const attr = node.getAttribute('is');\n    if (attr) {\n      elmConstructor =\n        isCustomElementName(attr) && window.customElements.get(attr);\n    } else {\n      elmConstructor =\n        isCustomElementName(localName) && window.customElements.get(localName);\n    }\n    if (elmConstructor) {\n      if (formAssociated) {\n        bool = elmConstructor.formAssociated;\n      } else {\n        bool = true;\n      }\n    }\n  }\n  return !!bool;\n};\n\n/**\n * is in shadow tree\n * @param {object} node - node\n * @returns {boolean} - result;\n */\nexport const isInShadowTree = node => {\n  let bool;\n  if (!node || !node.nodeType) {\n    // throws\n    verifyNode(node);\n  } else if (node.nodeType === ELEMENT_NODE ||\n             node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    let refNode = node;\n    while (refNode) {\n      const { host, mode, nodeType, parentNode } = refNode;\n      if (host && mode && nodeType === DOCUMENT_FRAGMENT_NODE &&\n          REG_SHADOW_MODE.test(mode)) {\n        bool = true;\n        break;\n      }\n      refNode = parentNode;\n    }\n  }\n  return !!bool;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  let res;\n  if (!node || !node.nodeType) {\n    // throws\n    verifyNode(node);\n  } else if (node.localName === 'slot' && isInShadowTree(node)) {\n    const nodes = node.assignedNodes();\n    if (nodes.length) {\n      for (const item of nodes) {\n        res = item.textContent.trim();\n        if (res) {\n          break;\n        }\n      }\n    } else {\n      res = node.textContent.trim();\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  let res;\n  if (!node || !node.nodeType) {\n    // throws\n    verifyNode(node);\n  } else if (node.nodeType === ELEMENT_NODE) {\n    const { dir: nodeDir, localName, parentNode } = node;\n    const { getEmbeddingLevels } = bidiFactory();\n    if (REG_DIR.test(nodeDir)) {\n      res = nodeDir;\n    } else if (nodeDir === 'auto') {\n      let text;\n      switch (localName) {\n        case 'input': {\n          if (!node.type || /^(?:button|email|hidden|password|reset|search|submit|tel|text|url)$/.test(node.type)) {\n            text = node.value;\n          } else if (/^(?:checkbox|color|date|image|number|radio|range|time)$/.test(node.type)) {\n            res = 'ltr';\n          }\n          break;\n        }\n        case 'slot': {\n          text = getSlottedTextContent(node);\n          break;\n        }\n        case 'textarea': {\n          text = node.value;\n          break;\n        }\n        default: {\n          const items = [].slice.call(node.childNodes);\n          for (const item of items) {\n            const {\n              dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n              textContent: itemTextContent\n            } = item;\n            if (itemNodeType === TEXT_NODE) {\n              text = itemTextContent.trim();\n            } else if (itemNodeType === ELEMENT_NODE) {\n              if (!/^(?:bdi|script|style|textarea)$/.test(itemLocalName) &&\n                  (!itemDir || !REG_DIR.test(itemDir))) {\n                if (itemLocalName === 'slot') {\n                  text = getSlottedTextContent(item);\n                } else {\n                  text = itemTextContent.trim();\n                }\n              }\n            }\n            if (text) {\n              break;\n            }\n          }\n        }\n      }\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          res = 'rtl';\n        } else {\n          res = 'ltr';\n        }\n      }\n      if (!res) {\n        if (parentNode) {\n          const { nodeType: parentNodeType } = parentNode;\n          if (parentNodeType === ELEMENT_NODE) {\n            res = getDirectionality(parentNode);\n          } else if (parentNodeType === DOCUMENT_NODE ||\n                     parentNodeType === DOCUMENT_FRAGMENT_NODE) {\n            res = 'ltr';\n          }\n        } else {\n          res = 'ltr';\n        }\n      }\n    } else if (localName === 'bdi') {\n      const text = node.textContent.trim();\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          res = 'rtl';\n        } else {\n          res = 'ltr';\n        }\n      }\n      if (!(res || parentNode)) {\n        res = 'ltr';\n      }\n    } else if (localName === 'input' && node.type === 'tel') {\n      res = 'ltr';\n    } else if (parentNode) {\n      if (localName === 'slot') {\n        const text = getSlottedTextContent(node);\n        if (text) {\n          const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n          if (level % 2 === 1) {\n            res = 'rtl';\n          } else {\n            res = 'ltr';\n          }\n        }\n      }\n      if (!res) {\n        const { nodeType: parentNodeType } = parentNode;\n        if (parentNodeType === ELEMENT_NODE) {\n          res = getDirectionality(parentNode);\n        } else if (parentNodeType === DOCUMENT_NODE ||\n                   parentNodeType === DOCUMENT_FRAGMENT_NODE) {\n          res = 'ltr';\n        }\n      }\n    } else {\n      res = 'ltr';\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  let res;\n  if (!node || !node.nodeType) {\n    // throws\n    verifyNode(node);\n  } else if (node.nodeType === ELEMENT_NODE) {\n    if (typeof node.isContentEditable === 'boolean') {\n      res = node.isContentEditable;\n    } else if (node.ownerDocument.designMode === 'on') {\n      res = true;\n    } else if (node.hasAttribute('contenteditable')) {\n      const attr = node.getAttribute('contenteditable');\n      if (attr === '' || /^(?:plaintext-only|true)$/.test(attr)) {\n        res = true;\n      } else if (attr === 'inherit') {\n        let parent = node.parentNode;\n        while (parent) {\n          if (isContentEditable(parent)) {\n            res = true;\n            break;\n          }\n          parent = parent.parentNode;\n        }\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  let res;\n  if (typeof ns !== 'string' || !node || !node.nodeType) {\n    if (typeof ns !== 'string') {\n      const type = Object.prototype.toString.call(ns).slice(TYPE_FROM, TYPE_TO);\n      const msg = `Unexpected type ${type}`;\n      throw new TypeError(msg);\n    } else {\n      // throws\n      verifyNode(node);\n    }\n  } else if (ns && node.nodeType === ELEMENT_NODE) {\n    const { attributes } = node;\n    for (const attr of attributes) {\n      const { name, namespaceURI, prefix, value } = attr;\n      if (name === `xmlns:${ns}`) {\n        res = value;\n        break;\n      } else if (prefix === ns) {\n        res = namespaceURI;\n        break;\n      }\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  let res;\n  if (ns && typeof ns === 'string' && node.nodeType === ELEMENT_NODE) {\n    res = node.lookupNamespaceURI(ns);\n    if (!res) {\n      const root = node.ownerDocument.documentElement;\n      let parent = node;\n      while (parent) {\n        res = getNamespaceURI(ns, parent);\n        if (res || parent === root) {\n          break;\n        }\n        parent = parent.parentNode;\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  let res;\n  if (!nodeA || !nodeA.nodeType) {\n    // throws\n    verifyNode(nodeA);\n  } else if (!nodeB || !nodeB.nodeType) {\n    // throws\n    verifyNode(nodeB);\n  } else if (nodeA.nodeType === ELEMENT_NODE &&\n             nodeB.nodeType === ELEMENT_NODE) {\n    const posBit = nodeB.compareDocumentPosition(nodeA);\n    res = posBit & DOCUMENT_POSITION_PRECEDING ||\n          posBit & DOCUMENT_POSITION_CONTAINS;\n  }\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n"],
  "mappings": "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",
  "names": ["dom_util_exports", "__export", "getDirectionality", "getNamespaceURI", "getSlottedTextContent", "isContentEditable", "isCustomElement", "isInShadowTree", "isNamespaceDeclared", "isPreceding", "resolveContent", "sortNodes", "traverseNode", "verifyNode", "__toCommonJS", "import_bidi_js", "import_is_potential_custom_element_name", "import_constant", "node", "msg", "document", "root", "parent", "walker", "current", "refNode", "opt", "bool", "localName", "ownerDocument", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "host", "mode", "nodeType", "parentNode", "res", "nodes", "item", "nodeDir", "getEmbeddingLevels", "bidiFactory", "text", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "ns", "attributes", "name", "namespaceURI", "prefix", "value", "nodeA", "nodeB", "posBit", "arr", "a", "b"]
}
