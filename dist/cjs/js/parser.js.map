{
  "version": 3,
  "sources": ["../../../src/js/parser.js"],
  "sourcesContent": ["/**\n * parser.js\n */\n\n/* import */\nimport { findAll, parse, toPlainObject, walk } from 'css-tree';\n\n/* constants */\nimport {\n  BIT_01, BIT_02, BIT_04, BIT_08, BIT_16, BIT_32, BIT_FFFF, BIT_HYPHEN,\n  COMBINATOR, DUO, EMPTY, HEX, REG_LOGICAL_PSEUDO, REG_SHADOW_PSEUDO, SELECTOR,\n  SELECTOR_ATTR, SELECTOR_CLASS, SELECTOR_ID, SELECTOR_PSEUDO_CLASS,\n  SELECTOR_PSEUDO_ELEMENT, SELECTOR_TYPE, SYNTAX_ERR, TYPE_FROM, TYPE_TO, U_FFFD\n} from './constant.js';\n\n/**\n * unescape selector\n * @param {string} selector - CSS selector\n * @returns {?string} - unescaped selector\n */\nexport const unescapeSelector = (selector = '') => {\n  if (typeof selector === 'string' && selector.indexOf('\\\\', 0) >= 0) {\n    const arr = selector.split('\\\\');\n    const l = arr.length;\n    for (let i = 1; i < l; i++) {\n      let item = arr[i];\n      if (item === '' && i === l - 1) {\n        item = U_FFFD;\n      } else {\n        const hexExists = /^([\\da-f]{1,6}\\s?)/i.exec(item);\n        if (hexExists) {\n          const [, hex] = hexExists;\n          let str;\n          try {\n            const low = parseInt('D800', HEX);\n            const high = parseInt('DFFF', HEX);\n            const deci = parseInt(hex, HEX);\n            if (deci === 0 || (deci >= low && deci <= high)) {\n              str = U_FFFD;\n            } else {\n              str = String.fromCodePoint(deci);\n            }\n          } catch (e) {\n            str = U_FFFD;\n          }\n          let postStr = '';\n          if (item.length > hex.length) {\n            postStr = item.substring(hex.length);\n          }\n          item = `${str}${postStr}`;\n        // whitespace\n        } else if (/^[\\n\\r\\f]/.test(item)) {\n          item = '\\\\' + item;\n        }\n      }\n      arr[i] = item;\n    }\n    selector = arr.join('');\n  }\n  return selector;\n};\n\n/**\n * preprocess\n * @see https://drafts.csswg.org/css-syntax-3/#input-preprocessing\n * @param {...*} args - arguments\n * @returns {string} - filtered selector string\n */\nexport const preprocess = (...args) => {\n  if (!args.length) {\n    throw new TypeError('1 argument required, but only 0 present.');\n  }\n  let [selector] = args;\n  if (typeof selector === 'string') {\n    let index = 0;\n    while (index >= 0) {\n      index = selector.indexOf('#', index);\n      if (index < 0) {\n        break;\n      }\n      const preHash = selector.substring(0, index + 1);\n      let postHash = selector.substring(index + 1);\n      // @see https://drafts.csswg.org/selectors/#id-selectors\n      // @see https://drafts.csswg.org/css-syntax-3/#ident-token-diagram\n      if (/^\\d$/.test(postHash.substring(0, 1))) {\n        throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n      }\n      const codePoint = postHash.codePointAt(0);\n      if (codePoint === BIT_HYPHEN) {\n        if (/^\\d$/.test(postHash.substring(1, 2))) {\n          throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n        }\n      // escape char above 0xFFFF\n      } else if (codePoint > BIT_FFFF) {\n        const str = `\\\\${codePoint.toString(HEX)} `;\n        if (postHash.length === DUO) {\n          postHash = str;\n        } else {\n          postHash = `${str}${postHash.substring(DUO)}`;\n        }\n      }\n      selector = `${preHash}${postHash}`;\n      index++;\n    }\n    selector = selector.replace(/\\f|\\r\\n?/g, '\\n')\n      .replace(/[\\0\\uD800-\\uDFFF]|\\\\$/g, U_FFFD);\n  } else if (selector === undefined || selector === null) {\n    selector = Object.prototype.toString.call(selector)\n      .slice(TYPE_FROM, TYPE_TO).toLowerCase();\n  } else if (Array.isArray(selector)) {\n    selector = selector.join(',');\n  } else if (Object.prototype.hasOwnProperty.call(selector, 'toString')) {\n    selector = selector.toString();\n  } else {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  return selector;\n};\n\n/**\n * create AST from CSS selector\n * @param {string} selector - CSS selector\n * @returns {object} - AST\n */\nexport const parseSelector = selector => {\n  selector = preprocess(selector);\n  // invalid selectors\n  if (/^$|^\\s*>|,\\s*$/.test(selector)) {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  let res;\n  try {\n    const ast = parse(selector, {\n      context: 'selectorList',\n      parseCustomProperty: true\n    });\n    res = toPlainObject(ast);\n  } catch (e) {\n    const { message } = e;\n    const regEmptyIs = /(:(is|where)\\(\\s*\\))/;\n    // workaround for https://github.com/csstree/csstree/issues/265\n    const regLang = /(:lang\\(\\s*(\"[A-Za-z\\d\\-*]*\")\\s*\\))/;\n    if (message === 'Identifier is expected' && regLang.test(selector)) {\n      const [, lang, range] = regLang.exec(selector);\n      const escapedRange =\n        range.replaceAll('*', '\\\\*').replace(/^\"/, '').replace(/\"$/, '');\n      let escapedLang = lang.replace(range, escapedRange);\n      if (escapedLang === ':lang()') {\n        escapedLang = `:lang(${EMPTY})`;\n      }\n      res = parseSelector(selector.replace(lang, escapedLang));\n    } else if ((message === 'Identifier is expected' ||\n                message === 'Selector is expected') &&\n               regEmptyIs.test(selector)) {\n      const [, logic, name] = regEmptyIs.exec(selector);\n      const emptyIs = `:${name}(${EMPTY})`;\n      res = parseSelector(selector.replace(logic, emptyIs));\n    } else if (message === '\"]\" is expected' && !selector.endsWith(']')) {\n      res = parseSelector(`${selector}]`);\n    } else if (message === '\")\" is expected' && !selector.endsWith(')')) {\n      res = parseSelector(`${selector})`);\n    } else {\n      throw new DOMException(message, SYNTAX_ERR);\n    }\n  }\n  return res;\n};\n\n/**\n * walk AST\n * @param {object} ast - AST\n * @returns {object} - branches and complex\n */\nexport const walkAST = (ast = {}) => {\n  const branches = new Set();\n  let hasPseudoFunc;\n  let hasComplexSelector;\n  const opt = {\n    enter: node => {\n      if (node.type === SELECTOR) {\n        branches.add(node.children);\n      } else if ((node.type === SELECTOR_PSEUDO_CLASS &&\n                  REG_LOGICAL_PSEUDO.test(node.name)) ||\n                 (node.type === SELECTOR_PSEUDO_ELEMENT &&\n                  REG_SHADOW_PSEUDO.test(node.name))) {\n        hasPseudoFunc = true;\n      }\n    }\n  };\n  walk(ast, opt);\n  if (hasPseudoFunc) {\n    findAll(ast, (node, item, list) => {\n      if (list) {\n        if (node.type === SELECTOR_PSEUDO_CLASS &&\n            REG_LOGICAL_PSEUDO.test(node.name)) {\n          const itemList = list.filter(i => {\n            const { name, type } = i;\n            const res =\n              type === SELECTOR_PSEUDO_CLASS && REG_LOGICAL_PSEUDO.test(name);\n            return res;\n          });\n          for (const { children } of itemList) {\n            // SelectorList\n            for (const { children: grandChildren } of children) {\n              // Selector\n              for (const { children: greatGrandChildren } of grandChildren) {\n                if (branches.has(greatGrandChildren)) {\n                  for (const greatGrandChild of greatGrandChildren) {\n                    const { type: greatGrandChildType } = greatGrandChild;\n                    if (greatGrandChildType === COMBINATOR) {\n                      hasComplexSelector = true;\n                      break;\n                    }\n                  }\n                  branches.delete(greatGrandChildren);\n                }\n              }\n            }\n          }\n        } else if (node.type === SELECTOR_PSEUDO_ELEMENT &&\n                   REG_SHADOW_PSEUDO.test(node.name)) {\n          const itemList = list.filter(i => {\n            const { name, type } = i;\n            const res =\n              type === SELECTOR_PSEUDO_ELEMENT && REG_SHADOW_PSEUDO.test(name);\n            return res;\n          });\n          for (const { children } of itemList) {\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  return {\n    branches: [...branches],\n    complex: !!hasComplexSelector\n  };\n};\n\n/**\n * sort AST\n * @param {Array.<object>} asts - collection of AST\n * @returns {Array.<object>} - collection of sorted AST\n */\nexport const sortAST = asts => {\n  const arr = [...asts];\n  if (arr.length > 1) {\n    const order = new Map([\n      [SELECTOR_PSEUDO_ELEMENT, BIT_01],\n      [SELECTOR_ID, BIT_02],\n      [SELECTOR_CLASS, BIT_04],\n      [SELECTOR_TYPE, BIT_08],\n      [SELECTOR_ATTR, BIT_16],\n      [SELECTOR_PSEUDO_CLASS, BIT_32]\n    ]);\n    arr.sort((a, b) => {\n      const { type: typeA } = a;\n      const { type: typeB } = b;\n      const bitA = order.get(typeA);\n      const bitB = order.get(typeB);\n      let res;\n      if (bitA === bitB) {\n        res = 0;\n      } else if (bitA > bitB) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * parse AST name - e.g. ns|E -> { prefix: ns, localName: E }\n * @param {string} selector - type selector\n * @returns {object} - node properties\n */\nexport const parseAstName = selector => {\n  let prefix;\n  let localName;\n  if (selector && typeof selector === 'string') {\n    if (selector.indexOf('|') > -1) {\n      [prefix, localName] = selector.split('|');\n    } else {\n      prefix = '*';\n      localName = selector;\n    }\n  } else {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  return {\n    prefix,\n    localName\n  };\n};\n\n/* filter selector constants */\n// :first-child, :last-child etc.\nconst N_ST = '(?:first|last|only)-(?:child|of-type)';\nconst DIGIT = '(?:0|[1-9]\\\\d*)';\nconst ANB = `[+-]?(?:${DIGIT}n?|n)|(?:[+-]?${DIGIT})?n\\\\s*[+-]\\\\s*${DIGIT}`;\n// exclude An+B with selector list, e.g. :nth-child(2n+1 of .foo)\nconst N_TH = `nth-(?:last-)?(?:child|of-type)\\\\(\\\\s*(?:even|odd|${ANB})\\\\s*\\\\)`;\n// *, tag\nconst TAG_TYPE = '\\\\*|[A-Za-z][\\\\w-]*';\n// attr, id, class, pseudo-class\nconst SUB_CLASS = '\\\\[[^\\\\]]+\\\\]|[#.:][\\\\w-]+';\nconst LOGICAL_KEY = '(?:is|not|where)';\nconst COMBO_A = '\\\\s?[\\\\s>~+]\\\\s?';\nconst COMBO_B = '\\\\s?[~+]\\\\s?';\nconst COMPOUND_A = `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_CLASS})+)`;\nconst COMPLEX_A = `${COMPOUND_A}(?:${COMBO_A}${COMPOUND_A})*`;\nconst COMPLEX_B = `${COMPOUND_A}(?:${COMBO_B}${COMPOUND_A})*`;\nconst NESTED_LOGICAL_A =\n  `:${LOGICAL_KEY}\\\\(\\\\s*${COMPOUND_A}(?:\\\\s*,\\\\s*${COMPOUND_A})*\\\\s*\\\\)`;\nconst NESTED_LOGICAL_B =\n  `:${LOGICAL_KEY}\\\\(\\\\s*${COMPLEX_A}(?:\\\\s*,\\\\s*${COMPLEX_A})*\\\\s*\\\\)`;\nconst NESTED_LOGICAL_C =\n  `:${LOGICAL_KEY}\\\\(\\\\s*${COMPLEX_B}(?:\\\\s*,\\\\s*${COMPLEX_B})*\\\\s*\\\\)`;\nconst COMPOUND_B =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_CLASS}|${NESTED_LOGICAL_A})+)`;\nconst COMPOUND_C =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_CLASS}|${NESTED_LOGICAL_B})+)`;\nconst COMPOUND_D =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_CLASS}|${NESTED_LOGICAL_C})+)`;\nconst COMPLEX_C = `${COMPOUND_C}(?:${COMBO_A}${COMPOUND_C})*`;\nconst COMPLEX_D = `${COMPOUND_D}(?:${COMBO_B}${COMPOUND_D})*`;\nconst LOGICAL_COMPOUND =\n  `${LOGICAL_KEY}\\\\(\\\\s*${COMPOUND_B}(?:\\\\s*,\\\\s*${COMPOUND_B})*\\\\s*\\\\)`;\nconst LOGICAL_COMPLEX_A =\n  `${LOGICAL_KEY}\\\\(\\\\s*${COMPLEX_C}(?:\\\\s*,\\\\s*${COMPLEX_C})*\\\\s*\\\\)`;\nconst LOGICAL_COMPLEX_B =\n  `${LOGICAL_KEY}\\\\(\\\\s*${COMPLEX_D}(?:\\\\s*,\\\\s*${COMPLEX_D})*\\\\s*\\\\)`;\nconst REG_LOGICAL_KEY = new RegExp(`:${LOGICAL_KEY}\\\\(`);\nconst REG_COMPLEX_A = new RegExp(`:(?!${N_ST}|${N_TH}|${LOGICAL_COMPLEX_A})`);\nconst REG_COMPLEX_B = new RegExp(`:(?!${N_ST}|${N_TH}|${LOGICAL_COMPLEX_B})`);\nconst REG_COMPOUND = new RegExp(`:(?!${N_ST}|${N_TH}|${LOGICAL_COMPOUND})`);\nconst REG_CHILD_INDEXED = new RegExp(`:(?!${N_ST}|${N_TH})`);\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  // filter namespaced selectors, e.g. ns|E, pseudo-element selectors and\n  // attribute selectors with case flag, e.g. [attr i], and unclosed quotes\n  if (/\\||::|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]/.test(selector)) {\n    return false;\n  }\n  // filter pseudo-classes other than child-indexed and logical combination\n  if (selector.includes(':')) {\n    let reg;\n    if (REG_LOGICAL_KEY.test(selector)) {\n      const { complex, descendant } = opt;\n      if (complex && descendant) {\n        reg = REG_COMPLEX_A;\n      } else if (complex) {\n        reg = REG_COMPLEX_B;\n      } else {\n        reg = REG_COMPOUND;\n      }\n    } else {\n      reg = REG_CHILD_INDEXED;\n    }\n    if (reg.test(selector)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* export */\nexport { generate as generateCSS } from 'css-tree';\n"],
  "mappings": "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",
  "names": ["parser_exports", "__export", "filterSelector", "parseAstName", "parseSelector", "preprocess", "sortAST", "unescapeSelector", "walkAST", "__toCommonJS", "import_css_tree", "import_constant", "selector", "arr", "l", "i", "item", "hexExists", "hex", "str", "low", "high", "deci", "postStr", "args", "index", "preHash", "postHash", "codePoint", "res", "ast", "e", "message", "regEmptyIs", "regLang", "lang", "range", "escapedRange", "escapedLang", "logic", "name", "emptyIs", "branches", "hasPseudoFunc", "hasComplexSelector", "node", "list", "itemList", "type", "children", "grandChildren", "greatGrandChildren", "greatGrandChild", "greatGrandChildType", "asts", "order", "a", "b", "typeA", "typeB", "bitA", "bitB", "prefix", "localName", "N_ST", "DIGIT", "ANB", "N_TH", "TAG_TYPE", "SUB_CLASS", "LOGICAL_KEY", "COMBO_A", "COMBO_B", "COMPOUND_A", "COMPLEX_A", "COMPLEX_B", "NESTED_LOGICAL_A", "NESTED_LOGICAL_B", "NESTED_LOGICAL_C", "COMPOUND_B", "COMPOUND_C", "COMPOUND_D", "COMPLEX_C", "COMPLEX_D", "LOGICAL_COMPOUND", "LOGICAL_COMPLEX_A", "LOGICAL_COMPLEX_B", "REG_LOGICAL_KEY", "REG_COMPLEX_A", "REG_COMPLEX_B", "REG_COMPOUND", "REG_CHILD_INDEXED", "opt", "reg", "complex", "descendant"]
}
