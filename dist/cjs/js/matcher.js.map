{
  "version": 3,
  "sources": ["../../../src/js/matcher.js"],
  "sourcesContent": ["/**\n * matcher.js\n */\n\n/* import */\nimport { generateCSS, parseAstName, unescapeSelector } from './parser.js';\nimport { getDirectionality, getType, isNamespaceDeclared } from './utility.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, ELEMENT_NODE, IDENT, LANG_PART, NOT_SUPPORTED_ERR,\n  PS_ELEMENT_SELECTOR, STRING, SYNTAX_ERR\n} from './constant.js';\n\n/**\n * match pseudo-element selector\n * @param {string} astName - AST name\n * @param {string} astType - AST type\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive unknown pseudo-element\n * @param {boolean} [opt.warn] - warn unsupported pseudo-element\n * @throws {DOMException}\n * @returns {void}\n */\nexport const matchPseudoElementSelector = (astName, astType, opt = {}) => {\n  const { forgive, warn } = opt;\n  if (astType === PS_ELEMENT_SELECTOR) {\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'placeholder':\n      case 'selection':\n      case 'target-text': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      case 'part':\n      case 'slotted': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}()`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          throw new DOMException(`Unknown pseudo-element ::${astName}`,\n            SYNTAX_ERR);\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`Unexpected ast type ${getType(astType)}`);\n  }\n};\n\n/**\n * match directionality pseudo-class - :dir()\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchDirectionPseudoClass = (ast, node) => {\n  const { name } = ast;\n  if (!name) {\n    let type;\n    if (name === '') {\n      type = '(empty String)';\n    } else {\n      type = getType(name);\n    }\n    throw new TypeError(`Unexpected ast type ${type}`);\n  }\n  const dir = getDirectionality(node);\n  return name === dir;\n};\n\n/**\n * match language pseudo-class - :lang()\n * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchLanguagePseudoClass = (ast, node) => {\n  const { name, type, value } = ast;\n  let astName;\n  if (type === STRING && value) {\n    astName = value;\n  } else if (type === IDENT && name) {\n    astName = unescapeSelector(name);\n  }\n  if (astName === '*') {\n    if (node.hasAttribute('lang')) {\n      if (node.getAttribute('lang')) {\n        return true;\n      }\n    } else {\n      let parent = node.parentNode;\n      let res;\n      while (parent) {\n        if (parent.nodeType === ELEMENT_NODE) {\n          if (parent.hasAttribute('lang')) {\n            if (parent.getAttribute('lang')) {\n              res = true;\n            }\n            break;\n          }\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      return !!res;\n    }\n  } else if (astName) {\n    const reg = new RegExp(`^(?:\\\\*-)?${ALPHA_NUM}${LANG_PART}$`, 'i');\n    if (reg.test(astName)) {\n      let regExtendedLang;\n      if (astName.indexOf('-') > -1) {\n        const [langMain, langSub, ...langRest] = astName.split('-');\n        let extendedMain;\n        if (langMain === '*') {\n          extendedMain = `${ALPHA_NUM}${LANG_PART}`;\n        } else {\n          extendedMain = `${langMain}${LANG_PART}`;\n        }\n        const extendedSub = `-${langSub}${LANG_PART}`;\n        const len = langRest.length;\n        let extendedRest = '';\n        if (len) {\n          for (let i = 0; i < len; i++) {\n            extendedRest += `-${langRest[i]}${LANG_PART}`;\n          }\n        }\n        regExtendedLang =\n          new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n      } else {\n        regExtendedLang = new RegExp(`^${astName}${LANG_PART}$`, 'i');\n      }\n      if (node.hasAttribute('lang')) {\n        return regExtendedLang.test(node.getAttribute('lang'));\n      } else {\n        let parent = node.parentNode;\n        let res;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              res = regExtendedLang.test(parent.getAttribute('lang'));\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n        return !!res;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * match attribute selector\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchAttributeSelector = (ast, node) => {\n  const {\n    flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n  } = ast;\n  if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n    const css = generateCSS(ast);\n    throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n  }\n  const { attributes } = node;\n  if (attributes?.length) {\n    const contentType = node.ownerDocument.contentType;\n    let caseInsensitive;\n    if (contentType === 'text/html') {\n      if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n        caseInsensitive = false;\n      } else {\n        caseInsensitive = true;\n      }\n    } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n      caseInsensitive = true;\n    } else {\n      caseInsensitive = false;\n    }\n    let astAttrName = unescapeSelector(astName.name);\n    if (caseInsensitive) {\n      astAttrName = astAttrName.toLowerCase();\n    }\n    const attrValues = new Set();\n    // namespaced\n    if (astAttrName.indexOf('|') > -1) {\n      const {\n        prefix: astPrefix, localName: astLocalName\n      } = parseAstName(astAttrName);\n      for (const item of attributes) {\n        let { name: itemName, value: itemValue } = item;\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        switch (astPrefix) {\n          case '': {\n            if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          case '*': {\n            if (itemName.indexOf(':') > -1) {\n              if (itemName.endsWith(`:${astLocalName}`)) {\n                attrValues.add(itemValue);\n              }\n            } else if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          default: {\n            if (itemName.indexOf(':') > -1) {\n              const [itemPrefix, itemLocalName] = itemName.split(':');\n              // ignore xml:lang\n              if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n                continue;\n              } else if (astPrefix === itemPrefix &&\n                           astLocalName === itemLocalName) {\n                const namespaceDeclared =\n                    isNamespaceDeclared(astPrefix, node);\n                if (namespaceDeclared) {\n                  attrValues.add(itemValue);\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      for (let { name: itemName, value: itemValue } of attributes) {\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        if (itemName.indexOf(':') > -1) {\n          const [itemPrefix, itemLocalName] = itemName.split(':');\n          // ignore xml:lang\n          if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n            continue;\n          } else if (astAttrName === itemLocalName) {\n            attrValues.add(itemValue);\n          }\n        } else if (astAttrName === itemName) {\n          attrValues.add(itemValue);\n        }\n      }\n    }\n    if (attrValues.size) {\n      const { name: astIdentValue, value: astStringValue } = astValue ?? {};\n      let attrValue;\n      if (astIdentValue) {\n        if (caseInsensitive) {\n          attrValue = astIdentValue.toLowerCase();\n        } else {\n          attrValue = astIdentValue;\n        }\n      } else if (astStringValue) {\n        if (caseInsensitive) {\n          attrValue = astStringValue.toLowerCase();\n        } else {\n          attrValue = astStringValue;\n        }\n      } else if (astStringValue === '') {\n        attrValue = astStringValue;\n      }\n      switch (astMatcher) {\n        case '=': {\n          return typeof attrValue === 'string' && attrValues.has(attrValue);\n        }\n        case '~=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let res;\n            for (const value of attrValues) {\n              const item = new Set(value.split(/\\s+/));\n              if (item.has(attrValue)) {\n                res = true;\n                break;\n              }\n            }\n            return !!res;\n          }\n          return false;\n        }\n        case '|=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '^=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.startsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '$=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.endsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '*=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.includes(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case null:\n        default: {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * match type selector\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive undeclared namespace\n * @returns {boolean} - result\n */\nexport const matchTypeSelector = (ast, node, opt = {}) => {\n  const astName = unescapeSelector(ast.name);\n  const { localName, namespaceURI, prefix } = node;\n  const { forgive } = opt;\n  let {\n    prefix: astPrefix, localName: astLocalName\n  } = parseAstName(astName, node);\n  if (node.ownerDocument.contentType === 'text/html' &&\n      /[A-Z][\\\\w-]*/i.test(localName)) {\n    astPrefix = astPrefix.toLowerCase();\n    astLocalName = astLocalName.toLowerCase();\n  }\n  let nodePrefix;\n  let nodeLocalName;\n  // just in case that the namespaced content is parsed as text/html\n  if (localName.indexOf(':') > -1) {\n    [nodePrefix, nodeLocalName] = localName.split(':');\n  } else {\n    nodePrefix = prefix || '';\n    nodeLocalName = localName;\n  }\n  switch (astPrefix) {\n    case '': {\n      if (!nodePrefix && !namespaceURI &&\n          (astLocalName === '*' || astLocalName === nodeLocalName)) {\n        return true;\n      }\n      return false;\n    }\n    case '*': {\n      if (astLocalName === '*' || astLocalName === nodeLocalName) {\n        return true;\n      }\n      return false;\n    }\n    default: {\n      const astNS = node.lookupNamespaceURI(astPrefix);\n      const nodeNS = node.lookupNamespaceURI(nodePrefix);\n      if (astNS === nodeNS && astPrefix === nodePrefix) {\n        if (astLocalName === '*' || astLocalName === nodeLocalName) {\n          return true;\n        }\n        return false;\n      } else if (!forgive && !astNS) {\n        throw new DOMException(`Undeclared namespace ${astPrefix}`, SYNTAX_ERR);\n      }\n      return false;\n    }\n  }\n};\n"],
  "mappings": "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",
  "names": ["matcher_exports", "__export", "matchAttributeSelector", "matchDirectionPseudoClass", "matchLanguagePseudoClass", "matchPseudoElementSelector", "matchTypeSelector", "__toCommonJS", "import_parser", "import_utility", "import_constant", "astName", "astType", "opt", "forgive", "warn", "ast", "node", "name", "type", "dir", "value", "parent", "res", "regExtendedLang", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "astFlags", "astMatcher", "astValue", "css", "attributes", "contentType", "caseInsensitive", "astAttrName", "attrValues", "astPrefix", "astLocalName", "item", "itemName", "itemValue", "itemPrefix", "itemLocalName", "astIdentValue", "astStringValue", "attrValue", "localName", "namespaceURI", "prefix", "nodePrefix", "nodeLocalName", "astNS", "nodeNS"]
}
