{
  "version": 3,
  "sources": ["../../../src/js/matcher.js"],
  "sourcesContent": ["/**\n * matcher.js\n */\n\n/* import */\nimport isCustomElementName from 'is-potential-custom-element-name';\nimport {\n  getDirectionality, isContentEditable, isInclusive, isInShadowTree,\n  isNamespaceDeclared, isPreceding, selectorToNodeProps\n} from './dom-util.js';\nimport {\n  generateCSS, parseSelector, unescapeSelector, walkAST\n} from './parser.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, BIT_01, BIT_02, BIT_04, BIT_08, BIT_16, BIT_32, COMBINATOR,\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, ELEMENT_NODE, NOT_SUPPORTED_ERR,\n  REG_LOGICAL_PSEUDO, REG_SHADOW_HOST, SELECTOR_ATTR, SELECTOR_CLASS,\n  SELECTOR_ID, SELECTOR_PSEUDO_CLASS, SELECTOR_PSEUDO_ELEMENT, SELECTOR_TYPE,\n  SHOW_ALL, SHOW_DOCUMENT, SHOW_DOCUMENT_FRAGMENT, SHOW_ELEMENT, SYNTAX_ERR,\n  TEXT_NODE, TYPE_FROM, TYPE_TO\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\nconst TARGET_ALL = 'all';\nconst TARGET_FIRST = 'first';\nconst TARGET_LINEAL = 'lineal';\nconst TARGET_SELF = 'self';\nconst WALKER_FILTER = SHOW_DOCUMENT | SHOW_DOCUMENT_FRAGMENT | SHOW_ELEMENT;\n\n/**\n * Matcher\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: [\n *   {\n *     branch: branch[],\n *     dir: string|null,\n *     filtered: boolean,\n *     find: boolean\n *   },\n *   {\n *     branch: branch[],\n *     dir: string|null,\n *     filtered: boolean,\n *     find: boolean\n *   }\n * ]\n * #nodes: [\n *   Set([node{}, node{}]),\n *   Set([node{}, node{}, node{}])\n * ]\n * branch[]: [twig{}, twig{}]\n * twig{}: {\n *   combo: leaf{}|null,\n *   leaves: leaves[]\n * }\n * leaves[]: [leaf{}, leaf{}, leaf{}]\n * leaf{}: CSSTree AST object\n * node{}: Element node\n */\nexport class Matcher {\n  /* private fields */\n  #ast;\n  #bit;\n  #cache;\n  #document;\n  #finder;\n  #node;\n  #nodes;\n  #root;\n  #selector;\n  #shadow;\n  #sort;\n  #tree;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   */\n  constructor() {\n    this.#bit = new Map([\n      [SELECTOR_PSEUDO_ELEMENT, BIT_01],\n      [SELECTOR_ID, BIT_02],\n      [SELECTOR_CLASS, BIT_04],\n      [SELECTOR_TYPE, BIT_08],\n      [SELECTOR_ATTR, BIT_16],\n      [SELECTOR_PSEUDO_CLASS, BIT_32]\n    ]);\n    this.#cache = new WeakMap();\n  }\n\n  /**\n   * handle error\n   * @param {Error} e - Error\n   * @throws Error\n   * @returns {void}\n   */\n  _onError(e) {\n    if (e instanceof DOMException ||\n        (this.#window && e instanceof this.#window.DOMException)) {\n      if (e.name === NOT_SUPPORTED_ERR) {\n        if (this.#warn) {\n          console.warn(e.message);\n        }\n      } else if (this.#window) {\n        throw new this.#window.DOMException(e.message, e.name);\n      } else {\n        throw new DOMException(e.message, e.name);\n      }\n    } else {\n      throw e;\n    }\n  }\n\n  /**\n   * set up #window, #document, #root, #walker\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @returns {Array.<object>} - array of #window, #document, #root, #walker\n   */\n  _setup(node) {\n    let document;\n    let root;\n    switch (node?.nodeType) {\n      case DOCUMENT_NODE: {\n        document = node;\n        root = node;\n        break;\n      }\n      case DOCUMENT_FRAGMENT_NODE: {\n        document = node.ownerDocument;\n        root = node;\n        break;\n      }\n      case ELEMENT_NODE: {\n        if (node.ownerDocument.contains(node)) {\n          document = node.ownerDocument;\n          root = node.ownerDocument;\n        } else {\n          let parent = node;\n          while (parent) {\n            if (parent.parentNode) {\n              parent = parent.parentNode;\n            } else {\n              break;\n            }\n          }\n          document = parent.ownerDocument;\n          root = parent;\n        }\n        break;\n      }\n      default: {\n        let msg;\n        if (node?.nodeName) {\n          msg = `Unexpected node ${node.nodeName}`;\n        } else {\n          const nodeType =\n            Object.prototype.toString.call(node).slice(TYPE_FROM, TYPE_TO);\n          msg = `Unexpected node ${nodeType}`;\n        }\n        throw new TypeError(msg);\n      }\n    }\n    const walker = document.createTreeWalker(root, WALKER_FILTER);\n    const window = document.defaultView;\n    return [\n      window,\n      document,\n      root,\n      walker\n    ];\n  }\n\n  /**\n   * sort AST leaves\n   * @param {Array.<object>} leaves - collection of AST leaves\n   * @returns {Array.<object>} - sorted leaves\n   */\n  _sortLeaves(leaves) {\n    const arr = [...leaves];\n    if (arr.length > 1) {\n      arr.sort((a, b) => {\n        const { type: typeA } = a;\n        const { type: typeB } = b;\n        const bitA = this.#bit.get(typeA);\n        const bitB = this.#bit.get(typeB);\n        let res;\n        if (bitA === bitB) {\n          res = 0;\n        } else if (bitA > bitB) {\n          res = 1;\n        } else {\n          res = -1;\n        }\n        return res;\n      });\n    }\n    return arr;\n  }\n\n  /**\n   * correspond #ast and #nodes\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of #ast and #nodes\n   */\n  _correspond(selector) {\n    let cssAst;\n    try {\n      cssAst = parseSelector(selector);\n    } catch (e) {\n      this._onError(e);\n    }\n    const branches = walkAST(cssAst);\n    const ast = [];\n    const nodes = [];\n    let i = 0;\n    for (const [...items] of branches) {\n      const branch = [];\n      let item = items.shift();\n      if (item && item.type !== COMBINATOR) {\n        const leaves = new Set();\n        while (item) {\n          if (item.type === COMBINATOR) {\n            const [nextItem] = items;\n            if (nextItem.type === COMBINATOR) {\n              const msg = `Invalid combinator ${item.name}${nextItem.name}`;\n              throw new this.#window.DOMException(msg, SYNTAX_ERR);\n            }\n            branch.push({\n              combo: item,\n              leaves: this._sortLeaves(leaves)\n            });\n            leaves.clear();\n          } else if (item) {\n            leaves.add(item);\n          }\n          if (items.length) {\n            item = items.shift();\n          } else {\n            branch.push({\n              combo: null,\n              leaves: this._sortLeaves(leaves)\n            });\n            leaves.clear();\n            break;\n          }\n        }\n      }\n      ast.push({\n        branch,\n        dir: null,\n        filtered: false,\n        find: false\n      });\n      nodes[i] = new Set();\n      i++;\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * traverse tree walker\n   * @param {object} [node] - Element node\n   * @param {object} [walker] - tree walker\n   * @returns {?object} - current node\n   */\n  _traverse(node = {}, walker = this.#tree) {\n    let current;\n    let refNode = walker.currentNode;\n    if (node.nodeType === ELEMENT_NODE && refNode === node) {\n      current = refNode;\n    } else {\n      if (refNode !== walker.root) {\n        while (refNode) {\n          if (refNode === walker.root ||\n              (node.nodeType === ELEMENT_NODE && refNode === node)) {\n            break;\n          }\n          refNode = walker.parentNode();\n        }\n      }\n      if (node.nodeType === ELEMENT_NODE) {\n        while (refNode) {\n          if (refNode === node) {\n            current = refNode;\n            break;\n          }\n          refNode = walker.nextNode();\n        }\n      } else {\n        current = refNode;\n      }\n    }\n    return current ?? null;\n  }\n\n  /**\n   * collect nth child\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    let matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#cache.has(selector)) {\n        selectorBranches = this.#cache.get(selector);\n      } else {\n        selectorBranches = walkAST(selector);\n        this.#cache.set(selector, selectorBranches);\n      }\n    }\n    if (parentNode) {\n      const walker = this.#document.createTreeWalker(parentNode, WALKER_FILTER);\n      let l = 0;\n      let refNode = walker.firstChild();\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      refNode = this._traverse(parentNode, walker);\n      const selectorNodes = new Set();\n      if (selectorBranches) {\n        refNode = this._traverse(parentNode, walker);\n        refNode = walker.firstChild();\n        while (refNode) {\n          let bool;\n          for (const leaves of selectorBranches) {\n            bool = this._matchLeaves(leaves, refNode);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            selectorNodes.add(refNode);\n          }\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            let i = 0;\n            refNode = this._traverse(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            let i = 0;\n            refNode = this._traverse(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        matched = new Set(m.reverse());\n      }\n    } else if (node === this.#root && this.#root.nodeType === ELEMENT_NODE &&\n               (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, parentNode, prefix } = node;\n    let matched = new Set();\n    if (parentNode) {\n      const walker = this.#document.createTreeWalker(parentNode, WALKER_FILTER);\n      let l = 0;\n      let refNode = walker.firstChild();\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          let j = 0;\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          while (refNode) {\n            const { localName: itemLocalName, prefix: itemPrefix } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          let j = a > 0 ? 0 : b - 1;\n          refNode = this._traverse(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          while (refNode) {\n            const { localName: itemLocalName, prefix: itemPrefix } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        matched = new Set(m.reverse());\n      }\n    } else if (node === this.#root && this.#root.nodeType === ELEMENT_NODE &&\n               (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const identName = unescapeSelector(nthIdentName);\n    const anbMap = new Map();\n    if (identName) {\n      if (identName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (identName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    let matched = new Set();\n    if (anbMap.has('a') && anbMap.has('b')) {\n      if (/^nth-(?:last-)?child$/.test(nthName)) {\n        if (selector) {\n          anbMap.set('selector', selector);\n        }\n        const anb = Object.fromEntries(anbMap);\n        const nodes = this._collectNthChild(anb, node);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      } else if (/^nth-(?:last-)?of-type$/.test(nthName)) {\n        const anb = Object.fromEntries(anbMap);\n        const nodes = this._collectNthOfType(anb, node);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match pseudo element selector\n   * @param {string} astName - AST name\n   * @param {object} [opt] - options\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @throws {DOMException}\n   * @returns {void}\n   */\n  _matchPseudoElementSelector(astName, opt = {}) {\n    const { forgive } = opt;\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'placeholder':\n      case 'selection':\n      case 'target-text': {\n        if (this.#warn) {\n          const msg = `Unsupported pseudo-element ::${astName}`;\n          throw new DOMException(msg, NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      case 'part':\n      case 'slotted': {\n        if (this.#warn) {\n          const msg = `Unsupported pseudo-element ::${astName}()`;\n          throw new DOMException(msg, NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (this.#warn) {\n            const msg = `Unsupported pseudo-element ::${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          const msg = `Unknown pseudo-element ::${astName}`;\n          throw new DOMException(msg, SYNTAX_ERR);\n        }\n      }\n    }\n  }\n\n  /**\n   * match directionality pseudo-class - :dir()\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchDirectionPseudoClass(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    const dir = getDirectionality(node);\n    let res;\n    if (astName === dir) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match language pseudo-class - :lang()\n   * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLanguagePseudoClass(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (astName === '*') {\n      if (node.hasAttribute('lang')) {\n        if (node.getAttribute('lang')) {\n          res = node;\n        }\n      } else {\n        let parent = node.parentNode;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              if (parent.getAttribute('lang')) {\n                res = node;\n              }\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n      }\n    } else if (astName) {\n      const langPart = `(?:-${ALPHA_NUM})*`;\n      const regLang = new RegExp(`^(?:\\\\*-)?${ALPHA_NUM}${langPart}$`, 'i');\n      if (regLang.test(astName)) {\n        let regExtendedLang;\n        if (astName.indexOf('-') > -1) {\n          const [langMain, langSub, ...langRest] = astName.split('-');\n          let extendedMain;\n          if (langMain === '*') {\n            extendedMain = `${ALPHA_NUM}${langPart}`;\n          } else {\n            extendedMain = `${langMain}${langPart}`;\n          }\n          const extendedSub = `-${langSub}${langPart}`;\n          const len = langRest.length;\n          let extendedRest = '';\n          if (len) {\n            for (let i = 0; i < len; i++) {\n              extendedRest += `-${langRest[i]}${langPart}`;\n            }\n          }\n          regExtendedLang =\n            new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n        } else {\n          regExtendedLang = new RegExp(`^${astName}${langPart}$`, 'i');\n        }\n        if (node.hasAttribute('lang')) {\n          if (regExtendedLang.test(node.getAttribute('lang'))) {\n            res = node;\n          }\n        } else {\n          let parent = node.parentNode;\n          while (parent) {\n            if (parent.nodeType === ELEMENT_NODE) {\n              if (parent.hasAttribute('lang')) {\n                const value = parent.getAttribute('lang');\n                if (regExtendedLang.test(value)) {\n                  res = node;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - Element node\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(leaves, node) {\n    let bool;\n    if (Array.isArray(leaves) && leaves.length) {\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      const nodes = this._matchCombinator(twig, node, {\n        dir: DIR_NEXT\n      });\n      if (nodes.size) {\n        if (leaves.length) {\n          for (const nextNode of nodes) {\n            bool =\n              this._matchHasPseudoFunc(Object.assign([], leaves), nextNode);\n            if (bool) {\n              break;\n            }\n          }\n        } else {\n          bool = true;\n        }\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node) {\n    const {\n      astName = '', branches = [], selector = '', twigBranches = []\n    } = astData;\n    let res;\n    if (astName === 'has') {\n      if (selector.includes(':has(')) {\n        res = null;\n      } else {\n        let bool;\n        for (const leaves of branches) {\n          bool = this._matchHasPseudoFunc(Object.assign([], leaves), node);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else {\n      const forgive = /^(?:is|where)$/.test(astName);\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, { forgive });\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, {\n                forgive,\n                dir: DIR_PREV\n              });\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (!bool) {\n          res = node;\n        }\n      } else if (bool) {\n        res = node;\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} [opt] - options\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt = {}) {\n    const { children: astChildren } = ast;\n    const { localName, parentNode } = node;\n    const { forgive } = opt;\n    const astName = unescapeSelector(ast.name);\n    let matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (REG_LOGICAL_PSEUDO.test(astName)) {\n      let astData;\n      if (this.#cache.has(ast)) {\n        astData = this.#cache.get(ast);\n      } else {\n        const branches = walkAST(ast);\n        const selectors = [];\n        const twigBranches = [];\n        for (const [...leaves] of branches) {\n          for (const leaf of leaves) {\n            const css = generateCSS(leaf);\n            selectors.push(css);\n          }\n          const branch = [];\n          const leavesSet = new Set();\n          let item = leaves.shift();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              branch.push({\n                combo: item,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n            } else if (item) {\n              leavesSet.add(item);\n            }\n            if (leaves.length) {\n              item = leaves.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n              break;\n            }\n          }\n          twigBranches.push(branch);\n        }\n        astData = {\n          astName,\n          branches,\n          twigBranches,\n          selector: selectors.join(',')\n        };\n        this.#cache.set(ast, astData);\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      const [branch] = astChildren;\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        const nodes = this._matchAnPlusB(branch, node, astName);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      // :dir()\n      } else if (astName === 'dir') {\n        const res = this._matchDirectionPseudoClass(branch, node);\n        if (res) {\n          matched.add(res);\n        }\n      // :lang()\n      } else if (astName === 'lang') {\n        const res = this._matchLanguagePseudoClass(branch, node);\n        if (res) {\n          matched.add(res);\n        }\n      } else {\n        switch (astName) {\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (this.#warn) {\n              const msg = `Unsupported pseudo-class :${astName}()`;\n              throw new DOMException(msg, NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          default: {\n            if (!forgive) {\n              const msg = `Unknown pseudo-class :${astName}()`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      const regAnchor = /^a(?:rea)?$/;\n      const regFormCtrl =\n        /^(?:(?:fieldse|inpu|selec)t|button|opt(?:group|ion)|textarea)$/;\n      const regFormValidity = /^(?:(?:inpu|selec)t|button|form|textarea)$/;\n      const regInteract = /^d(?:etails|ialog)$/;\n      const regTypeCheck = /^(?:checkbox|radio)$/;\n      const regTypeDate = /^(?:date(?:time-local)?|month|time|week)$/;\n      const regTypeRange =\n        /(?:(?:rang|tim)e|date(?:time-local)?|month|number|week)$/;\n      const regTypeText = /^(?:(?:emai|te|ur)l|number|password|search|text)$/;\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if (regAnchor.test(localName) && node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if (regAnchor.test(localName) && node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#document.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#document.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#document.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#document.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#document.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === this.#document.activeElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-within': {\n          let current = this.#document.activeElement;\n          while (current) {\n            if (current === node) {\n              matched.add(node);\n              break;\n            }\n            current = current.parentNode;\n          }\n          break;\n        }\n        case 'open': {\n          if (regInteract.test(localName) && node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'closed': {\n          if (regInteract.test(localName) && !node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'disabled': {\n          if (regFormCtrl.test(localName) || isCustomElementName(localName)) {\n            if (node.disabled || node.hasAttribute('disabled')) {\n              matched.add(node);\n            } else {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset') {\n                  break;\n                }\n                parent = parent.parentNode;\n              }\n              if (parent && parentNode.localName !== 'legend' &&\n                  parent.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'enabled': {\n          if ((regFormCtrl.test(localName) || isCustomElementName(localName)) &&\n              !(node.disabled && node.hasAttribute('disabled'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'read-only': {\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || regTypeDate.test(node.type) ||\n                   regTypeText.test(node.type)) &&\n                  (node.readonly || node.hasAttribute('readonly') ||\n                   node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (!isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'read-write': {\n          switch (localName) {\n            case 'textarea': {\n              if (!(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type || regTypeDate.test(node.type) ||\n                   regTypeText.test(node.type)) &&\n                  !(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let targetNode;\n          if (localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              if (regTypeText.test(node.getAttribute('type'))) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode && node.value === '' &&\n              node.hasAttribute('placeholder') &&\n              node.getAttribute('placeholder').trim().length) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'checked': {\n          if ((node.checked && localName === 'input' &&\n               node.hasAttribute('type') &&\n               regTypeCheck.test(node.getAttribute('type'))) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#document.documentElement;\n            }\n            let checked;\n            const nodes = [].slice.call(parent.getElementsByTagName('input'));\n            for (const item of nodes) {\n              if (item.getAttribute('type') === 'radio') {\n                if (nodeName) {\n                  if (item.getAttribute('name') === nodeName) {\n                    checked = !!item.checked;\n                  }\n                } else if (!item.hasAttribute('name')) {\n                  checked = !!item.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          const regTypeReset = /^(?:button|reset)$/;\n          const regTypeSubmit = /^(?:image|submit)$/;\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') &&\n                 regTypeReset.test(node.getAttribute('type')))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               regTypeSubmit.test(node.getAttribute('type')))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker =\n                this.#document.createTreeWalker(form, SHOW_ELEMENT);\n              let nextNode = walker.firstChild();\n              while (nextNode) {\n                const nodeName = nextNode.localName;\n                let m;\n                if (nodeName === 'button') {\n                  m = !(nextNode.hasAttribute('type') &&\n                    regTypeReset.test(nextNode.getAttribute('type')));\n                } else if (nodeName === 'input') {\n                  m = nextNode.hasAttribute('type') &&\n                    regTypeSubmit.test(nextNode.getAttribute('type'));\n                }\n                if (m) {\n                  if (nextNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                nextNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     regTypeCheck.test(node.getAttribute('type')) &&\n                     (node.checked || node.hasAttribute('checked'))) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option') {\n            let isMultiple = false;\n            let parent = parentNode;\n            while (parent) {\n              if (parent.localName === 'datalist') {\n                break;\n              } else if (parent.localName === 'select') {\n                if (parent.multiple || parent.hasAttribute('multiple')) {\n                  isMultiple = true;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (isMultiple) {\n              if (node.selected || node.hasAttribute('selected')) {\n                matched.add(node);\n              }\n            } else {\n              const defaultOpt = new Set();\n              const walker =\n                this.#document.createTreeWalker(parentNode, SHOW_ELEMENT);\n              let refNode = walker.firstChild();\n              while (refNode) {\n                if (refNode.selected || refNode.hasAttribute('selected')) {\n                  defaultOpt.add(refNode);\n                  break;\n                }\n                refNode = walker.nextSibling();\n              }\n              if (defaultOpt.size) {\n                if (defaultOpt.has(node)) {\n                  matched.add(node);\n                }\n              }\n            }\n          }\n          break;\n        }\n        case 'valid': {\n          if (regFormValidity.test(localName)) {\n            if (node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            let bool;\n            const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n            let refNode = walker.firstChild();\n            while (refNode) {\n              if (regFormValidity.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'invalid': {\n          if (regFormValidity.test(localName)) {\n            if (!node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            let bool;\n            const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n            let refNode = walker.firstChild();\n            while (refNode) {\n              if (regFormValidity.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (!bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              regTypeRange.test(node.getAttribute('type')) &&\n              !(node.validity.rangeUnderflow ||\n                node.validity.rangeOverflow) &&\n              (node.hasAttribute('min') || node.hasAttribute('max') ||\n               node.getAttribute('type') === 'range')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'out-of-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              regTypeRange.test(node.getAttribute('type')) &&\n              (node.validity.rangeUnderflow || node.validity.rangeOverflow)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'required': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || regTypeCheck.test(inputType) ||\n                  regTypeDate.test(inputType) || regTypeText.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              (node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'optional': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (inputType === 'file' || regTypeCheck.test(inputType) ||\n                  regTypeDate.test(inputType) || regTypeText.test(inputType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              !(node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            let bool;\n            const walker = this.#document.createTreeWalker(node, SHOW_ALL);\n            let refNode = walker.firstChild();\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              (node === this.#root && this.#root.nodeType === ELEMENT_NODE)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              (node === this.#root && this.#root.nodeType === ELEMENT_NODE)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode &&\n               node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) ||\n              (node === this.#root && this.#root.nodeType === ELEMENT_NODE)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root &&\n                     this.#root.nodeType === ELEMENT_NODE) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root &&\n                     this.#root.nodeType === ELEMENT_NODE) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root &&\n                     this.#root.nodeType === ELEMENT_NODE) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (this.#warn) {\n            const msg = `Unsupported pseudo-element ::${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        case 'active':\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'defined':\n        case 'focus-visible':\n        case 'fullscreen':\n        case 'future':\n        case 'hover':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (this.#warn) {\n            const msg = `Unsupported pseudo-class :${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (this.#warn) {\n              const msg = `Unsupported pseudo-class :${astName}`;\n              throw new DOMException(msg, NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            const msg = `Unknown pseudo-class :${astName}`;\n            throw new DOMException(msg, SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match attribute selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchAttributeSelector(ast, node) {\n    const {\n      flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n    } = ast;\n    if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n      const css = generateCSS(ast);\n      const msg = `Invalid selector ${css}`;\n      throw new DOMException(msg, SYNTAX_ERR);\n    }\n    const { attributes } = node;\n    let res;\n    if (attributes && attributes.length) {\n      let caseInsensitive;\n      if (this.#document.contentType === 'text/html') {\n        if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n          caseInsensitive = false;\n        } else {\n          caseInsensitive = true;\n        }\n      } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n        caseInsensitive = true;\n      } else {\n        caseInsensitive = false;\n      }\n      let astAttrName = unescapeSelector(astName.name);\n      if (caseInsensitive) {\n        astAttrName = astAttrName.toLowerCase();\n      }\n      const attrValues = new Set();\n      // namespaced\n      if (astAttrName.indexOf('|') > -1) {\n        const {\n          prefix: astAttrPrefix, tagName: astAttrLocalName\n        } = selectorToNodeProps(astAttrName);\n        for (let { name: itemName, value: itemValue } of attributes) {\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          switch (astAttrPrefix) {\n            case '': {\n              if (astAttrLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            case '*': {\n              if (itemName.indexOf(':') > -1) {\n                if (itemName.endsWith(`:${astAttrLocalName}`)) {\n                  attrValues.add(itemValue);\n                }\n              } else if (astAttrLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            default: {\n              if (itemName.indexOf(':') > -1) {\n                const [itemNamePrefix, itemNameLocalName] = itemName.split(':');\n                if (astAttrPrefix === itemNamePrefix &&\n                    astAttrLocalName === itemNameLocalName &&\n                    isNamespaceDeclared(astAttrPrefix, node)) {\n                  attrValues.add(itemValue);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        for (let { name: itemName, value: itemValue } of attributes) {\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          if (itemName.indexOf(':') > -1) {\n            const [itemNamePrefix, itemNameLocalName] = itemName.split(':');\n            // ignore xml:lang\n            if (itemNamePrefix === 'xml' && itemNameLocalName === 'lang') {\n              continue;\n            } else if (astAttrName === itemNameLocalName) {\n              attrValues.add(itemValue);\n            }\n          } else if (astAttrName === itemName) {\n            attrValues.add(itemValue);\n          }\n        }\n      }\n      if (attrValues.size) {\n        const {\n          name: astAttrIdentValue, value: astAttrStringValue\n        } = astValue || {};\n        let attrValue;\n        if (astAttrIdentValue) {\n          if (caseInsensitive) {\n            attrValue = astAttrIdentValue.toLowerCase();\n          } else {\n            attrValue = astAttrIdentValue;\n          }\n        } else if (astAttrStringValue) {\n          if (caseInsensitive) {\n            attrValue = astAttrStringValue.toLowerCase();\n          } else {\n            attrValue = astAttrStringValue;\n          }\n        } else if (astAttrStringValue === '') {\n          attrValue = astAttrStringValue;\n        }\n        switch (astMatcher) {\n          case '=': {\n            if (typeof attrValue === 'string' && attrValues.has(attrValue)) {\n              res = node;\n            }\n            break;\n          }\n          case '~=': {\n            if (attrValue && typeof attrValue === 'string') {\n              for (const value of attrValues) {\n                const item = new Set(value.split(/\\s+/));\n                if (item.has(attrValue)) {\n                  res = node;\n                  break;\n                }\n              }\n            }\n            break;\n          }\n          case '|=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '^=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.startsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '$=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.endsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '*=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.includes(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case null:\n          default: {\n            res = node;\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match class selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchClassSelector(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (node.classList.contains(astName)) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match ID selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchIDSelector(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    const { id } = node;\n    let res;\n    if (astName === id) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match type selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} [opt] - options\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @returns {?object} - matched node\n   */\n  _matchTypeSelector(ast, node, opt = {}) {\n    const astName = unescapeSelector(ast.name);\n    const { localName, prefix } = node;\n    const { forgive } = opt;\n    let {\n      prefix: astPrefix, tagName: astNodeName\n    } = selectorToNodeProps(astName, node);\n    if (this.#document.contentType === 'text/html') {\n      astPrefix = astPrefix.toLowerCase();\n      astNodeName = astNodeName.toLowerCase();\n    }\n    let nodePrefix;\n    let nodeName;\n    // just in case that the namespaced content is parsed as text/html\n    if (localName.indexOf(':') > -1) {\n      [nodePrefix, nodeName] = localName.split(':');\n    } else {\n      nodePrefix = prefix || '';\n      nodeName = localName;\n    }\n    let res;\n    if (astPrefix === '' && nodePrefix === '') {\n      if (node.namespaceURI === null &&\n          (astNodeName === '*' || astNodeName === nodeName)) {\n        res = node;\n      }\n    } else if (astPrefix === '*') {\n      if (astNodeName === '*' || astNodeName === nodeName) {\n        res = node;\n      }\n    } else if (astPrefix === nodePrefix) {\n      if (isNamespaceDeclared(astPrefix, node)) {\n        if (astNodeName === '*' || astNodeName === nodeName) {\n          res = node;\n        }\n      } else if (!forgive) {\n        const msg = `Undeclared namespace ${astPrefix}`;\n        throw new DOMException(msg, SYNTAX_ERR);\n      }\n    } else if (astPrefix && !forgive && !isNamespaceDeclared(astPrefix, node)) {\n      const msg = `Undeclared namespace ${astPrefix}`;\n      throw new DOMException(msg, SYNTAX_ERR);\n    }\n    return res ?? null;\n  };\n\n  /**\n   * match shadow host pseudo class\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren } = ast;\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (Array.isArray(astChildren)) {\n      const [branch] = walkAST(astChildren[0]);\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            const msg = `Invalid selector ${css}`;\n            throw new DOMException(msg, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      } else if (astName === 'host-context') {\n        let bool;\n        let parent = host;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              const msg = `Invalid selector ${css}`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else if (astName === 'host') {\n      res = node;\n    } else {\n      const msg = `Invalid selector :${astName}`;\n      throw new DOMException(msg, SYNTAX_ERR);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match selector\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt) {\n    const { type: astType } = ast;\n    const astName = unescapeSelector(ast.name);\n    let matched = new Set();\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case SELECTOR_ATTR: {\n          const res = this._matchAttributeSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n          break;\n        }\n        case SELECTOR_CLASS: {\n          const res = this._matchClassSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n          break;\n        }\n        case SELECTOR_ID: {\n          const res = this._matchIDSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n          break;\n        }\n        case SELECTOR_PSEUDO_CLASS: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          if (nodes.size) {\n            matched = nodes;\n          }\n          break;\n        }\n        case SELECTOR_PSEUDO_ELEMENT: {\n          this._matchPseudoElementSelector(astName, opt);\n          break;\n        }\n        case SELECTOR_TYPE:\n        default: {\n          const res = this._matchTypeSelector(ast, node, opt);\n          if (res) {\n            matched.add(res);\n          }\n        }\n      }\n    } else if (this.#shadow && astType === SELECTOR_PSEUDO_CLASS &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (astName !== 'has' && REG_LOGICAL_PSEUDO.test(astName)) {\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      } else if (REG_SHADOW_HOST.test(astName)) {\n        const res = this._matchShadowHostPseudoClass(ast, node);\n        if (res) {\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} [opt] - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let bool;\n    for (const leaf of leaves) {\n      bool = this._matchSelector(leaf, node, opt).has(node);\n      if (!bool) {\n        break;\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * find descendant nodes\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode) {\n    const [leaf, ...filterLeaves] = leaves;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const compound = filterLeaves.length > 0;\n    let nodes = new Set();\n    let pending = false;\n    if (this.#shadow) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case SELECTOR_ID: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case SELECTOR_CLASS: {\n          const arr = [].slice.call(baseNode.getElementsByClassName(leafName));\n          if (arr.length) {\n            if (compound) {\n              for (const node of arr) {\n                const bool = this._matchLeaves(filterLeaves, node);\n                if (bool) {\n                  nodes.add(node);\n                }\n              }\n            } else {\n              nodes = new Set(arr);\n            }\n          }\n          break;\n        }\n        case SELECTOR_TYPE: {\n          if (this.#document.contentType === 'text/html' &&\n              !/[*|]/.test(leafName)) {\n            const arr = [].slice.call(baseNode.getElementsByTagName(leafName));\n            if (arr.length) {\n              if (compound) {\n                for (const node of arr) {\n                  const bool = this._matchLeaves(filterLeaves, node);\n                  if (bool) {\n                    nodes.add(node);\n                  }\n                }\n              } else {\n                nodes = new Set(arr);\n              }\n            }\n          } else {\n            pending = true;\n          }\n          break;\n        }\n        case SELECTOR_PSEUDO_ELEMENT: {\n          this._matchPseudoElementSelector(leafName);\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    return {\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * match combinator\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} [opt] - option\n   * @param {string} [opt.dir] - direction to find\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt = {}) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { dir, forgive } = opt;\n    let matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, { forgive });\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          const { parentNode } = node;\n          if (parentNode) {\n            const walker =\n              this.#document.createTreeWalker(parentNode, SHOW_ELEMENT);\n            let refNode = this._traverse(node, walker);\n            if (refNode === node) {\n              refNode = walker.nextSibling();\n            }\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, { forgive });\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextSibling();\n            }\n          }\n          break;\n        }\n        case '>': {\n          const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n          let refNode = walker.firstChild();\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, { forgive });\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = walker.nextSibling();\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const { nodes, pending } = this._findDescendantNodes(leaves, node);\n          if (nodes.size) {\n            matched = nodes;\n          } else if (pending) {\n            const walker = this.#document.createTreeWalker(node, SHOW_ELEMENT);\n            let refNode = walker.nextNode();\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, { forgive });\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = walker.nextNode();\n            }\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, { forgive });\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          const walker =\n            this.#document.createTreeWalker(node.parentNode, SHOW_ELEMENT);\n          let refNode = walker.firstChild();\n          while (refNode) {\n            if (refNode === node) {\n              break;\n            } else {\n              const bool = this._matchLeaves(leaves, refNode, { forgive });\n              if (bool) {\n                matched.add(refNode);\n              }\n            }\n            refNode = walker.nextSibling();\n          }\n          break;\n        }\n        case '>': {\n          const refNode = node.parentNode;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, { forgive });\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = node.parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, { forgive });\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            matched = new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node from tree walker\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} [opt] - options\n   * @param {object} [opt.node] - node to start from\n   * @param {object} [opt.tree] - tree walker\n   * @returns {?object} - matched node\n   */\n  _findNode(leaves, opt = {}) {\n    let { node, walker } = opt;\n    if (!walker) {\n      walker = this.#tree;\n    }\n    let matchedNode;\n    let refNode = this._traverse(node, walker);\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = walker.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = walker.nextNode();\n        }\n      }\n      while (refNode) {\n        let bool;\n        if (this.#node.nodeType === ELEMENT_NODE) {\n          if (refNode === this.#node) {\n            bool = true;\n          } else {\n            bool = this.#node.contains(refNode);\n          }\n        } else {\n          bool = true;\n        }\n        if (bool) {\n          const matched = this._matchLeaves(leaves, refNode);\n          if (matched) {\n            matchedNode = refNode;\n            break;\n          }\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return matchedNode ?? null;\n  }\n\n  /**\n   * find entry nodes\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const compound = filterLeaves.length > 0;\n    let nodes = new Set();\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case SELECTOR_ID: {\n        if (targetType === TARGET_SELF) {\n          const bool = this._matchLeaves(leaves, this.#node);\n          if (bool) {\n            nodes.add(this.#node);\n            filtered = true;\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode);\n            if (bool) {\n              nodes.add(refNode);\n              filtered = true;\n            }\n            refNode = refNode.parentNode;\n          }\n        } else if (targetType === TARGET_ALL ||\n                   this.#root.nodeType === ELEMENT_NODE) {\n          pending = true;\n        } else {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            nodes.add(node);\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case SELECTOR_CLASS: {\n        if (targetType === TARGET_SELF) {\n          if (this.#node.nodeType === ELEMENT_NODE &&\n              this.#node.classList.contains(leafName)) {\n            nodes.add(this.#node);\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            if (refNode.nodeType === ELEMENT_NODE) {\n              if (refNode.classList.contains(leafName)) {\n                nodes.add(refNode);\n              }\n              refNode = refNode.parentNode;\n            } else {\n              break;\n            }\n          }\n        } else if (targetType === TARGET_FIRST) {\n          const node = this._findNode(leaves, {\n            node: this.#node,\n            walker: this.#finder\n          });\n          if (node) {\n            nodes.add(node);\n            filtered = true;\n          }\n        } else if (this.#root.nodeType === DOCUMENT_FRAGMENT_NODE ||\n                   this.#root.nodeType === ELEMENT_NODE) {\n          pending = true;\n        } else {\n          const arr =\n            [].slice.call(this.#root.getElementsByClassName(leafName));\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            for (const node of arr) {\n              if (node === this.#node || isInclusive(node, this.#node)) {\n                nodes.add(node);\n              }\n            }\n          } else if (arr.length) {\n            nodes = new Set(arr);\n          }\n        }\n        break;\n      }\n      case SELECTOR_TYPE: {\n        if (targetType === TARGET_SELF) {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            const bool = this._matchLeaves(leaves, this.#node);\n            if (bool) {\n              nodes.add(this.#node);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            if (refNode.nodeType === ELEMENT_NODE) {\n              const bool = this._matchLeaves(leaves, refNode);\n              if (bool) {\n                nodes.add(refNode);\n                filtered = true;\n              }\n              refNode = refNode.parentNode;\n            } else {\n              break;\n            }\n          }\n        } else if (targetType === TARGET_FIRST) {\n          const node = this._findNode(leaves, {\n            node: this.#node,\n            walker: this.#finder\n          });\n          if (node) {\n            nodes.add(node);\n            filtered = true;\n          }\n        } else if (this.#document.contentType !== 'text/html' ||\n                   /[*|]/.test(leafName) ||\n                   this.#root.nodeType === DOCUMENT_FRAGMENT_NODE ||\n                   this.#root.nodeType === ELEMENT_NODE) {\n          pending = true;\n        } else {\n          const arr = [].slice.call(this.#root.getElementsByTagName(leafName));\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            for (const node of arr) {\n              if (node === this.#node || isInclusive(node, this.#node)) {\n                nodes.add(node);\n              }\n            }\n          } else if (arr.length) {\n            nodes = new Set(arr);\n          }\n        }\n        break;\n      }\n      case SELECTOR_PSEUDO_ELEMENT: {\n        // throws\n        this._matchPseudoElementSelector(leafName);\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL && REG_SHADOW_HOST.test(leafName)) {\n          if (this.#shadow && this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            const node = this._matchShadowHostPseudoClass(leaf, this.#node);\n            if (node) {\n              nodes.add(node);\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          const bool = this._matchLeaves(leaves, this.#node);\n          if (bool) {\n            nodes.add(this.#node);\n            filtered = true;\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode);\n            if (bool) {\n              nodes.add(refNode);\n              filtered = true;\n            }\n            refNode = refNode.parentNode;\n          }\n        } else if (targetType === TARGET_FIRST) {\n          const node = this._findNode(leaves, {\n            node: this.#node,\n            walker: this.#finder\n          });\n          if (node) {\n            nodes.add(node);\n            filtered = true;\n          }\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * get entry twig\n   * @param {Array.<object>} branch - AST branch\n   * @param {string} targetType - target type\n   * @returns {object} - direction and twig\n   */\n  _getEntryTwig(branch, targetType) {\n    const branchLen = branch.length;\n    const complex = branchLen > 1;\n    const firstTwig = branch[0];\n    let dir;\n    let twig;\n    if (complex) {\n      const { combo: firstCombo, leaves: [{ type: firstType }] } = firstTwig;\n      const lastTwig = branch[branchLen - 1];\n      const { leaves: [{ type: lastType }] } = lastTwig;\n      if (lastType === SELECTOR_PSEUDO_ELEMENT || lastType === SELECTOR_ID) {\n        dir = DIR_PREV;\n        twig = lastTwig;\n      } else if (firstType === SELECTOR_PSEUDO_ELEMENT ||\n                 firstType === SELECTOR_ID) {\n        dir = DIR_NEXT;\n        twig = firstTwig;\n      } else if (targetType === TARGET_ALL) {\n        if (branchLen === 2) {\n          const { name: comboName } = firstCombo;\n          if (/^[+~]$/.test(comboName)) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          }\n        } else {\n          dir = DIR_NEXT;\n          twig = firstTwig;\n        }\n      } else {\n        let bool;\n        let sibling;\n        for (const { combo, leaves: [leaf] } of branch) {\n          const { type: leafType } = leaf;\n          const leafName = unescapeSelector(leaf.name);\n          if (leafType === SELECTOR_PSEUDO_CLASS && leafName === 'dir') {\n            bool = false;\n            break;\n          }\n          if (combo && !sibling) {\n            const { name: comboName } = combo;\n            if (/^[+~]$/.test(comboName)) {\n              bool = true;\n              sibling = true;\n            }\n          }\n        }\n        if (bool) {\n          dir = DIR_NEXT;\n          twig = firstTwig;\n        } else {\n          dir = DIR_PREV;\n          twig = lastTwig;\n        }\n      }\n    } else {\n      dir = DIR_PREV;\n      twig = firstTwig;\n    }\n    return {\n      complex,\n      dir,\n      twig\n    };\n  }\n\n  /**\n   * collect nodes\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const { dir, twig } = this._getEntryTwig(branch, targetType);\n        const {\n          compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType);\n        if (nodes.size) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#finder;\n        } else {\n          node = this.#root;\n          walker = this.#tree;\n        }\n        let nextNode = this._traverse(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode);\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].add(nextNode);\n              }\n            }\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType);\n        if (nodes.size) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * sort nodes\n   * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n   * @returns {Array.<object|undefined>} - collection of sorted nodes\n   */\n  _sortNodes(nodes) {\n    const arr = [...nodes];\n    if (arr.length > 1) {\n      arr.sort((a, b) => {\n        let res;\n        if (isPreceding(b, a)) {\n          res = 1;\n        } else {\n          res = -1;\n        }\n        return res;\n      });\n    }\n    return arr;\n  }\n\n  /**\n   * match nodes\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchNodes(targetType) {\n    const [...branches] = this.#ast;\n    const l = branches.length;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, dir, filtered, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = this.#nodes[i];\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          const { leaves: [, ...filterLeaves] } = branch[0];\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (const node of entryNodes) {\n              const bool = filtered || this._matchLeaves(filterLeaves, node);\n              if (bool && node !== this.#node && this.#node.contains(node)) {\n                nodes.add(node);\n                if (targetType !== TARGET_ALL) {\n                  break;\n                }\n              }\n            }\n          } else if (!filterLeaves.length) {\n            if (targetType === TARGET_ALL) {\n              if (nodes.size) {\n                const n = [...nodes];\n                nodes = new Set([...n, ...entryNodes]);\n                this.#sort = true;\n              } else {\n                nodes = new Set([...entryNodes]);\n              }\n            } else {\n              const [node] = [...entryNodes];\n              nodes.add(node);\n            }\n          } else {\n            for (const node of entryNodes) {\n              const bool = filtered || this._matchLeaves(filterLeaves, node);\n              if (bool) {\n                nodes.add(node);\n                if (targetType !== TARGET_ALL) {\n                  break;\n                }\n              }\n            }\n          }\n        } else if (dir === DIR_NEXT) {\n          let { combo, leaves: entryLeaves } = branch[0];\n          const [, ...filterLeaves] = entryLeaves;\n          let matched;\n          for (const node of entryNodes) {\n            const bool = filtered || this._matchLeaves(filterLeaves, node);\n            if (bool) {\n              let nextNodes = new Set([node]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const arr = [];\n                for (const nextNode of nextNodes) {\n                  const twig = {\n                    combo,\n                    leaves\n                  };\n                  const m = this._matchCombinator(twig, nextNode, { dir });\n                  if (m.size) {\n                    arr.push(...m);\n                  }\n                }\n                if (arr.length) {\n                  if (j === lastIndex) {\n                    if (targetType === TARGET_ALL) {\n                      if (nodes.size) {\n                        const n = [...nodes];\n                        nodes = new Set([...n, ...arr]);\n                        this.#sort = true;\n                      } else {\n                        nodes = new Set([...arr]);\n                      }\n                    } else {\n                      const [node] = this._sortNodes(arr);\n                      nodes.add(node);\n                    }\n                    matched = true;\n                  } else {\n                    combo = nextCombo;\n                    nextNodes = new Set(arr);\n                    matched = false;\n                  }\n                } else {\n                  matched = false;\n                  break;\n                }\n              }\n            } else {\n              matched = false;\n            }\n            if (matched && targetType !== TARGET_ALL) {\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const [entryNode] = [...entryNodes];\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode,\n              walker: this.#finder\n            });\n            while (refNode) {\n              let nextNodes = new Set([refNode]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const arr = [];\n                for (const nextNode of nextNodes) {\n                  const twig = {\n                    combo,\n                    leaves\n                  };\n                  const m = this._matchCombinator(twig, nextNode, { dir });\n                  if (m.size) {\n                    arr.push(...m);\n                  }\n                }\n                if (arr.length) {\n                  if (j === lastIndex) {\n                    const [node] = this._sortNodes(arr);\n                    nodes.add(node);\n                    matched = true;\n                  } else {\n                    combo = nextCombo;\n                    nextNodes = new Set(arr);\n                    matched = false;\n                  }\n                } else {\n                  matched = false;\n                  break;\n                }\n              }\n              if (matched) {\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode,\n                walker: this.#finder\n              });\n              nextNodes = new Set([refNode]);\n            }\n          }\n        } else {\n          const { leaves: entryLeaves } = branch[lastIndex];\n          const [, ...filterLeaves] = entryLeaves;\n          let matched;\n          for (const node of entryNodes) {\n            const bool = filtered || this._matchLeaves(filterLeaves, node);\n            if (bool) {\n              let nextNodes = new Set([node]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                const arr = [];\n                for (const nextNode of nextNodes) {\n                  const m = this._matchCombinator(twig, nextNode, { dir });\n                  if (m.size) {\n                    arr.push(...m);\n                  }\n                }\n                if (arr.length) {\n                  if (j === 0) {\n                    nodes.add(node);\n                    matched = true;\n                  } else {\n                    nextNodes = new Set(arr);\n                    matched = false;\n                  }\n                } else {\n                  matched = false;\n                  break;\n                }\n              }\n            }\n            if (matched && targetType !== TARGET_ALL) {\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const [entryNode] = [...entryNodes];\n            let refNode = this._findNode(entryLeaves, {\n              node: entryNode,\n              walker: this.#finder\n            });\n            while (refNode) {\n              let nextNodes = new Set([refNode]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                const arr = [];\n                for (const nextNode of nextNodes) {\n                  const m = this._matchCombinator(twig, nextNode, { dir });\n                  if (m.size) {\n                    arr.push(...m);\n                  }\n                }\n                if (arr.length) {\n                  if (j === 0) {\n                    nodes.add(refNode);\n                    matched = true;\n                  } else {\n                    nextNodes = new Set(arr);\n                    matched = false;\n                  }\n                } else {\n                  matched = false;\n                  break;\n                }\n              }\n              if (matched) {\n                break;\n              }\n              refNode = this._findNode(entryLeaves, {\n                node: refNode,\n                walker: this.#finder\n              });\n              nextNodes = new Set([refNode]);\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * find matched nodes\n   * @param {string} targetType - target type\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {string} selector - CSS selector\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _find(targetType, node, selector, opt = {}) {\n    const { warn } = opt;\n    this.#warn = !!warn;\n    if (!node) {\n      const nodeType =\n        Object.prototype.toString.call(node).slice(TYPE_FROM, TYPE_TO);\n      const msg = `Unexpected node ${nodeType}`;\n      throw new TypeError(msg);\n    } else if (node.nodeType !== DOCUMENT_NODE &&\n               node.nodeType !== DOCUMENT_FRAGMENT_NODE &&\n               node.nodeType !== ELEMENT_NODE) {\n      const msg = `Unexpected node ${node.nodeName}`;\n      throw new TypeError(msg);\n    } else if ((targetType === TARGET_SELF || targetType === TARGET_LINEAL) &&\n               node.nodeType !== ELEMENT_NODE) {\n      const msg = `Unexpected node ${node.nodeName}`;\n      throw new TypeError(msg);\n    }\n    this.#cache = new WeakMap();\n    this.#node = node;\n    [this.#window, this.#document, this.#root, this.#tree] = this._setup(node);\n    this.#shadow = isInShadowTree(node);\n    if (selector && selector === this.#selector) {\n      for (const i of this.#nodes) {\n        i.clear();\n      }\n    } else {\n      this.#selector = selector;\n      [this.#ast, this.#nodes] = this._correspond(selector);\n    }\n    // prepare #finder\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      this.#finder = this.#document.createTreeWalker(this.#node, SHOW_ELEMENT);\n      this.#sort = false;\n    }\n    this._collectNodes(targetType);\n    const nodes = this._matchNodes(targetType);\n    return nodes;\n  }\n\n  /**\n   * matches\n   * @param {object} node - Element node\n   * @param {string} selector - CSS selector\n   * @param {object} opt - options\n   * @returns {boolean} - `true` if matched `false` otherwise\n   */\n  matches(node, selector, opt) {\n    let res;\n    try {\n      const nodes = this._find(TARGET_SELF, node, selector, opt);\n      if (nodes.size) {\n        res = nodes.has(this.#node);\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return !!res;\n  }\n\n  /**\n   * closest\n   * @param {object} node - Element node\n   * @param {string} selector - CSS selector\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  closest(node, selector, opt) {\n    let res;\n    try {\n      const nodes = this._find(TARGET_LINEAL, node, selector, opt);\n      let refNode = this.#node;\n      while (refNode) {\n        if (nodes.has(refNode)) {\n          res = refNode;\n          break;\n        }\n        refNode = refNode.parentNode;\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {string} selector - CSS selector\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  querySelector(node, selector, opt) {\n    let res;\n    try {\n      const nodes = this._find(TARGET_FIRST, node, selector, opt);\n      nodes.delete(this.#node);\n      if (nodes.size) {\n        [res] = this._sortNodes(nodes);\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector all\n   * NOTE: returns Array, not NodeList\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {string} selector - CSS selector\n   * @param {object} opt - options\n   * @returns {Array.<object|undefined>} - collection of matched nodes\n   */\n  querySelectorAll(node, selector, opt) {\n    let res;\n    try {\n      const nodes = this._find(TARGET_ALL, node, selector, opt);\n      nodes.delete(this.#node);\n      if (nodes.size) {\n        if (this.#sort) {\n          res = this._sortNodes(nodes);\n        } else {\n          res = [...nodes];\n        }\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? [];\n  }\n};\n"],
  "mappings": "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",
  "names": ["matcher_exports", "__export", "Matcher", "__toCommonJS", "import_is_potential_custom_element_name", "import_dom_util", "import_parser", "import_constant", "DIR_NEXT", "DIR_PREV", "TARGET_ALL", "TARGET_FIRST", "TARGET_LINEAL", "TARGET_SELF", "WALKER_FILTER", "#ast", "#bit", "#cache", "#document", "#finder", "#node", "#nodes", "#root", "#selector", "#shadow", "#sort", "#tree", "#warn", "#window", "e", "node", "document", "root", "parent", "msg", "walker", "leaves", "arr", "a", "b", "typeA", "typeB", "bitA", "bitB", "res", "selector", "cssAst", "branches", "ast", "nodes", "i", "items", "branch", "item", "nextItem", "current", "refNode", "anb", "reverse", "parentNode", "matched", "selectorBranches", "l", "selectorNodes", "bool", "nth", "j", "m", "localName", "prefix", "itemLocalName", "itemPrefix", "nthName", "nthIdentName", "identName", "anbMap", "astName", "opt", "forgive", "dir", "langPart", "regExtendedLang", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "value", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "twigBranches", "lastIndex", "nextNodes", "astChildren", "selectors", "css", "leavesSet", "regAnchor", "regFormCtrl", "regFormValidity", "regInteract", "regTypeCheck", "regTypeDate", "regTypeRange", "regTypeText", "href", "origin", "pathname", "attrURL", "hash", "id", "isCustomElementName", "targetNode", "nodeName", "checked", "regTypeReset", "regTypeSubmit", "form", "isMultiple", "defaultOpt", "inputType", "node1", "node2", "astFlags", "astMatcher", "astValue", "attributes", "caseInsensitive", "astAttrName", "attrValues", "astAttrPrefix", "astAttrLocalName", "itemName", "itemValue", "itemNamePrefix", "itemNameLocalName", "astAttrIdentValue", "astAttrStringValue", "attrValue", "astPrefix", "astNodeName", "nodePrefix", "host", "astType", "baseNode", "filterLeaves", "leafName", "compound", "pending", "comboName", "matchedNode", "targetType", "filtered", "branchLen", "complex", "firstTwig", "firstCombo", "firstType", "lastTwig", "lastType", "sibling", "pendingItems", "pendingItem", "index", "find", "entryNodes", "n", "entryLeaves", "nextCombo", "entryNode", "warn"]
}
