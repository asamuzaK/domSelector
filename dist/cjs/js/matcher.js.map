{
  "version": 3,
  "sources": ["../../../src/js/matcher.js"],
  "sourcesContent": ["/**\n * matcher.js\n */\n\n/* import */\nimport isCustomElementName from 'is-potential-custom-element-name';\nimport {\n  getDirectionality, isContentEditable, isNamespaceDeclared, isSameOrDescendant,\n  selectorToNodeProps\n} from './dom-util.js';\nimport {\n  generateCSS, parseSelector, unescapeSelector, walkAST\n} from './parser.js';\n\n/* constants */\nimport {\n  ATTRIBUTE_SELECTOR, BIT_1, BIT_10, BIT_100, BIT_1000, BIT_10000, BIT_100000,\n  CLASS_SELECTOR, COMBINATOR, DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE,\n  DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE,\n  ID_SELECTOR, NOT_SUPPORTED_ERR, PSEUDO_CLASS_SELECTOR,\n  PSEUDO_ELEMENT_SELECTOR, SHOW_ELEMENT, SYNTAX_ERR, TEXT_NODE, TYPE_SELECTOR\n} from './constant.js';\nconst TARGET_ALL = 'all';\nconst TARGET_FIRST = 'first';\nconst TARGET_LINEAL = 'lineal';\nconst TARGET_SELF = 'self';\n\n/* regexp */\nconst FORM_PARTS =\n  /^(?:(?:fieldse|inpu|selec)t|button|opt(?:group|ion)|textarea)$/;\nconst FORM_VALIDITY = /^(?:(?:(?:in|out)pu|selec)t|button|form|textarea)$/;\nconst HTML_ANCHOR = /^a(?:rea)?$/;\nconst HTML_INTERACT = /^d(?:etails|ialog)$/;\nconst INPUT_CHECK = /^(?:checkbox|radio)$/;\nconst INPUT_EDIT = /^(?:(?:emai|te|ur)l|number|password|search|text)$/;\nconst INPUT_RANGE = /(?:(?:rang|tim)e|date(?:time-local)?|month|number|week)$/;\nconst INPUT_RESET = /^(?:button|reset)$/;\nconst INPUT_SUBMIT = /^(?:image|submit)$/;\nconst INPUT_TIME = /^(?:date(?:time-local)?|month|time|week)$/;\nconst PSEUDO_FUNC = /^(?:(?:ha|i)s|not|where)$/;\nconst PSEUDO_NTH = /^nth-(?:last-)?(?:child|of-type)$/;\n\n/**\n * Matcher\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: [\n *   {\n *     branch: branch[],\n *     skip: boolean\n *   },\n *   {\n *     branch: branch[],\n *     skip: boolean\n *   }\n * ]\n * #nodes: [\n *   Set([node{}, node{}]),\n *   Set([node{}, node, node{}])\n * ]\n * branch[]: [twig{}, twig{}]\n * twig{}: {\n *   combo: leaf{}|null,\n *   leaves: leaves[]\n * }\n * leaves[]: [leaf{}, leaf{}, leaf{}]\n * leaf{}: AST leaf\n * node{}: Element node\n */\nexport class Matcher {\n  /* private fields */\n  #ast;\n  #bit;\n  #cache;\n  #node;\n  #nodes;\n  #root;\n  #selector;\n  #sort;\n  #warn;\n\n  /**\n   * construct\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @param {boolean} [opt.sort] - sort results of querySelectorAll()\n   * @param {boolean} [opt.warn] - console warn\n   */\n  constructor(selector, node, opt = {}) {\n    const { sort, warn } = opt;\n    this.#bit = new Map([\n      [ATTRIBUTE_SELECTOR, BIT_10000],\n      [CLASS_SELECTOR, BIT_100],\n      [ID_SELECTOR, BIT_10],\n      [PSEUDO_CLASS_SELECTOR, BIT_100000],\n      [PSEUDO_ELEMENT_SELECTOR, BIT_1],\n      [TYPE_SELECTOR, BIT_1000]\n    ]);\n    this.#cache = new WeakMap();\n    this.#selector = selector;\n    this.#node = node;\n    this.#sort = !!sort;\n    this.#warn = !!warn;\n    [this.#ast, this.#nodes] = this._prepare(selector);\n    this.#root = this._getRoot(node);\n  }\n\n  /**\n   * handle error\n   * @param {Error} e - Error\n   * @throws Error\n   * @returns {void}\n   */\n  _onError(e) {\n    if (e instanceof DOMException && e.name === NOT_SUPPORTED_ERR) {\n      if (this.#warn) {\n        console.warn(e.message);\n      }\n    } else {\n      throw e;\n    }\n  }\n\n  /**\n   * get root\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @returns {object} - root object\n   */\n  _getRoot(node = this.#node) {\n    let document;\n    let root;\n    switch (node.nodeType) {\n      case DOCUMENT_NODE: {\n        document = node;\n        root = node;\n        break;\n      }\n      case DOCUMENT_FRAGMENT_NODE: {\n        document = node.ownerDocument;\n        root = node;\n        break;\n      }\n      case ELEMENT_NODE: {\n        if (isSameOrDescendant(node)) {\n          document = node.ownerDocument;\n          root = node.ownerDocument;\n        } else {\n          let parent = node;\n          while (parent) {\n            if (parent.parentNode) {\n              parent = parent.parentNode;\n            } else {\n              break;\n            }\n          }\n          document = parent.ownerDocument;\n          root = parent;\n        }\n        break;\n      }\n      default: {\n        throw new TypeError(`Unexpected node ${node.nodeName}`);\n      }\n    }\n    return {\n      document,\n      root\n    };\n  }\n\n  /**\n   * sort AST leaves\n   * @param {Array.<object>} leaves - AST leaves\n   * @returns {Array.<object>} - sorted leaves\n   */\n  _sortLeaves(leaves) {\n    const arr = [...leaves];\n    if (arr.length > 1) {\n      arr.sort((a, b) => {\n        const { type: typeA } = a;\n        const { type: typeB } = b;\n        const bitA = this.#bit.get(typeA);\n        const bitB = this.#bit.get(typeB);\n        let res;\n        if (bitA === bitB) {\n          res = 0;\n        } else if (bitA > bitB) {\n          res = 1;\n        } else {\n          res = -1;\n        }\n        return res;\n      });\n    }\n    return arr;\n  }\n\n  /**\n   * prepare ast and nodes\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - list and matrix\n   */\n  _prepare(selector = this.#selector) {\n    const ast = parseSelector(selector);\n    const branches = walkAST(ast);\n    const tree = [];\n    const nodes = [];\n    let i = 0;\n    for (const [...items] of branches) {\n      const branch = [];\n      let item = items.shift();\n      if (item && item.type !== COMBINATOR) {\n        const leaves = new Set();\n        while (item) {\n          if (item.type === COMBINATOR) {\n            const [nextItem] = items;\n            if (nextItem.type === COMBINATOR) {\n              const msg = `Invalid combinator ${item.name}${nextItem.name}`;\n              throw new DOMException(msg, SYNTAX_ERR);\n            }\n            branch.push({\n              combo: item,\n              leaves: this._sortLeaves(leaves)\n            });\n            leaves.clear();\n          } else if (item) {\n            leaves.add(item);\n          }\n          if (items.length) {\n            item = items.shift();\n          } else {\n            branch.push({\n              combo: null,\n              leaves: this._sortLeaves(leaves)\n            });\n            leaves.clear();\n            break;\n          }\n        }\n      }\n      tree.push({\n        branch,\n        find: null,\n        skip: false\n      });\n      nodes[i] = new Set();\n      i++;\n    }\n    return [\n      tree,\n      nodes\n    ];\n  }\n\n  /**\n   * collect nth child\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @returns {object} - collection of matched nodes\n   */\n  _collectNthChild(anb, node) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    const matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#cache.has(selector)) {\n        selectorBranches = this.#cache.get(selector);\n      } else {\n        selectorBranches = walkAST(selector);\n        this.#cache.set(selector, selectorBranches);\n      }\n    }\n    if (parentNode) {\n      const arr = [...parentNode.children];\n      const l = arr.length;\n      if (l) {\n        const selectorNodes = new Set();\n        if (selectorBranches) {\n          const branchesLen = selectorBranches.length;\n          for (const refNode of arr) {\n            let bool;\n            for (let i = 0; i < branchesLen; i++) {\n              const leaves = selectorBranches[i];\n              bool = this._matchLeaves(leaves, refNode);\n              if (!bool) {\n                break;\n              }\n            }\n            if (bool) {\n              selectorNodes.add(refNode);\n            }\n          }\n        }\n        if (reverse) {\n          arr.reverse();\n        }\n        // :first-child, :last-child, :nth-child(0 of S)\n        if (a === 0) {\n          if (b > 0 && b <= l) {\n            if (selectorNodes.size) {\n              for (let i = 0; i < l; i++) {\n                const current = arr[i];\n                if (selectorNodes.has(current)) {\n                  matched.add(current);\n                  break;\n                }\n              }\n            } else if (!selector) {\n              const current = arr[b - 1];\n              matched.add(current);\n            }\n          }\n        // :nth-child()\n        } else {\n          let n = 0;\n          let nth = b - 1;\n          if (a > 0) {\n            while (nth < 0) {\n              nth += (++n * a);\n            }\n          }\n          if (nth >= 0 && nth < l) {\n            let j = a > 0 ? 0 : b - 1;\n            for (let i = 0; i < l && nth >= 0 && nth < l; i++) {\n              const current = arr[i];\n              if (selectorNodes.size) {\n                if (selectorNodes.has(current)) {\n                  if (j === nth) {\n                    matched.add(current);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(current);\n                }\n                nth += a;\n              }\n            }\n          }\n        }\n      }\n    } else {\n      const { root } = this.#root;\n      if (root.nodeType === ELEMENT_NODE && node === root && (a + b) === 1) {\n        if (selectorBranches) {\n          const branchesLen = selectorBranches.length;\n          let bool;\n          for (let i = 0; i < branchesLen; i++) {\n            const leaves = selectorBranches[i];\n            bool = this._matchLeaves(leaves, node);\n            if (bool) {\n              break;\n            }\n          }\n          if (bool) {\n            matched.add(node);\n          }\n        } else {\n          matched.add(node);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {object} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, parentNode, prefix } = node;\n    const matched = new Set();\n    if (parentNode) {\n      const arr = [...parentNode.children];\n      const l = arr.length;\n      if (l) {\n        if (reverse) {\n          arr.reverse();\n        }\n        // :first-of-type, :last-of-type\n        if (a === 0) {\n          if (b > 0 && b <= l) {\n            let j = 0;\n            for (let i = 0; i < l; i++) {\n              const current = arr[i];\n              const { localName: itemLocalName, prefix: itemPrefix } = current;\n              if (itemLocalName === localName && itemPrefix === prefix) {\n                if (j === b - 1) {\n                  matched.add(current);\n                  break;\n                }\n                j++;\n              }\n            }\n          }\n        // :nth-of-type()\n        } else {\n          let nth = b - 1;\n          if (a > 0) {\n            while (nth < 0) {\n              nth += a;\n            }\n          }\n          if (nth >= 0 && nth < l) {\n            let j = a > 0 ? 0 : b - 1;\n            for (let i = 0; i < l; i++) {\n              const current = arr[i];\n              const { localName: itemLocalName, prefix: itemPrefix } = current;\n              if (itemLocalName === localName && itemPrefix === prefix) {\n                if (j === nth) {\n                  matched.add(current);\n                  nth += a;\n                }\n                if (nth < 0 || nth >= l) {\n                  break;\n                } else if (a > 0) {\n                  j++;\n                } else {\n                  j--;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      const { root } = this.#root;\n      if (root.nodeType === ELEMENT_NODE && node === root && (a + b) === 1) {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @returns {object} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const identName = unescapeSelector(nthIdentName);\n    const anbMap = new Map();\n    if (identName) {\n      if (identName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (identName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (/last/.test(nthName)) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (/last/.test(nthName)) {\n        anbMap.set('reverse', true);\n      }\n    }\n    let matched = new Set();\n    if (anbMap.has('a') && anbMap.has('b')) {\n      if (/^nth-(?:last-)?child$/.test(nthName)) {\n        if (selector) {\n          anbMap.set('selector', selector);\n        }\n        const anb = Object.fromEntries(anbMap);\n        const nodes = this._collectNthChild(anb, node);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      } else if (/^nth-(?:last-)?of-type$/.test(nthName)) {\n        const anb = Object.fromEntries(anbMap);\n        const nodes = this._collectNthOfType(anb, node);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match pseudo element selector\n   * @param {string} astName - AST name\n   * @param {object} [opt] - options\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @throws {DOMException}\n   * @returns {void}\n   */\n  _matchPseudoElementSelector(astName, opt = {}) {\n    const { forgive } = opt;\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'part':\n      case 'placeholder':\n      case 'selection':\n      case 'slotted':\n      case 'target-text': {\n        if (this.#warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (this.#warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          throw new DOMException(`Unknown pseudo-element ::${astName}`,\n            SYNTAX_ERR);\n        }\n      }\n    }\n  }\n\n  /**\n   * match directionality pseudo-class - :dir()\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchDirectionPseudoClass(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    const dir = getDirectionality(node);\n    let res;\n    if (astName === dir) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match language pseudo-class - :lang()\n   * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLanguagePseudoClass(ast, node) {\n    const { lang } = node;\n    const astName = unescapeSelector(ast.name);\n    let res;\n    // TBD: what about xml:lang?\n    if (astName === '') {\n      if (node.getAttribute('lang') === '') {\n        res = node;\n      }\n    } else if (astName === '*') {\n      if (!node.hasAttribute('lang')) {\n        res = node;\n      }\n    } else if (/[A-Z\\d-]+/i.test(astName)) {\n      const codePart = '(?:-[A-Za-z\\\\d]+)?';\n      let reg;\n      if (/-/.test(astName)) {\n        const [langMain, langSub, ...langRest] = astName.split('-');\n        const extendedMain = `${langMain}${codePart}`;\n        const extendedSub = `-${langSub}${codePart}`;\n        const len = langRest.length;\n        let extendedRest = '';\n        if (len) {\n          for (let i = 0; i < len; i++) {\n            extendedRest += `-${langRest[i]}${codePart}`;\n          }\n        }\n        reg = new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n      } else {\n        reg = new RegExp(`^${astName}${codePart}$`, 'i');\n      }\n      if (lang) {\n        if (reg.test(lang)) {\n          res = node;\n        }\n      } else {\n        let target = node;\n        while (target) {\n          if (reg.test(target.lang)) {\n            res = node;\n            break;\n          }\n          target = target.parentNode;\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - Element node\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(leaves, node) {\n    let bool;\n    if (Array.isArray(leaves) && leaves.length) {\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      const nodes = this._matchCombinator(twig, node, {\n        find: 'next'\n      });\n      if (nodes.size) {\n        if (leaves.length) {\n          for (const nextNode of nodes) {\n            bool =\n              this._matchHasPseudoFunc(Object.assign([], leaves), nextNode);\n            if (bool) {\n              break;\n            }\n          }\n        } else {\n          bool = true;\n        }\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node) {\n    const {\n      astName = '', branches = [], selector = '', twigBranches = []\n    } = astData;\n    let res;\n    if (astName === 'has') {\n      if (selector.includes(':has(')) {\n        res = null;\n      } else {\n        let bool;\n        const l = branches.length;\n        for (let i = 0; i < l; i++) {\n          const leaves = branches[i];\n          bool = this._matchHasPseudoFunc(Object.assign([], leaves), node);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          res = node;\n        }\n      }\n    } else {\n      const forgive = /^(?:is|where)$/.test(astName);\n      let bool;\n      const l = twigBranches.length;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, {\n          forgive\n        });\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, {\n                forgive,\n                find: 'prev'\n              });\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            const matchedNodes = new Set(arr);\n            if (matchedNodes.size) {\n              if (j === 0) {\n                bool = true;\n                break;\n              } else {\n                nextNodes = matchedNodes;\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (!bool) {\n          res = node;\n        }\n      } else if (bool) {\n        res = node;\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} [opt] - options\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @returns {object} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt = {}) {\n    const { children: astChildren } = ast;\n    const { localName, parentNode } = node;\n    const { forgive } = opt;\n    const astName = unescapeSelector(ast.name);\n    let matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (PSEUDO_FUNC.test(astName)) {\n      let astData;\n      if (this.#cache.has(ast)) {\n        astData = this.#cache.get(ast);\n      } else {\n        const branches = walkAST(ast);\n        const selectors = [];\n        const twigBranches = [];\n        for (const [...leaves] of branches) {\n          for (const leaf of leaves) {\n            const css = generateCSS(leaf);\n            selectors.push(css);\n          }\n          const branch = [];\n          const leavesSet = new Set();\n          let item = leaves.shift();\n          while (item) {\n            if (item.type === COMBINATOR) {\n              branch.push({\n                combo: item,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n            } else if (item) {\n              leavesSet.add(item);\n            }\n            if (leaves.length) {\n              item = leaves.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: [...leavesSet]\n              });\n              leavesSet.clear();\n              break;\n            }\n          }\n          twigBranches.push(branch);\n        }\n        astData = {\n          astName,\n          branches,\n          twigBranches,\n          selector: selectors.join(',')\n        };\n        this.#cache.set(ast, astData);\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      const [branch] = astChildren;\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (PSEUDO_NTH.test(astName)) {\n        const nodes = this._matchAnPlusB(branch, node, astName);\n        if (nodes.size) {\n          matched = nodes;\n        }\n      // :dir()\n      } else if (astName === 'dir') {\n        const res = this._matchDirectionPseudoClass(branch, node);\n        if (res) {\n          matched.add(res);\n        }\n      // :lang()\n      } else if (astName === 'lang') {\n        const res = this._matchLanguagePseudoClass(branch, node);\n        if (res) {\n          matched.add(res);\n        }\n      } else {\n        switch (astName) {\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (this.#warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          default: {\n            if (!forgive) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      const { document, root } = this.#root;\n      const { documentElement } = document;\n      const docURL = new URL(document.URL);\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if (HTML_ANCHOR.test(localName) && node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if (HTML_ANCHOR.test(localName) && node.hasAttribute('href')) {\n            const attrURL = new URL(node.getAttribute('href'), docURL.href);\n            if (attrURL.origin === docURL.origin &&\n                attrURL.pathname === docURL.pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'target': {\n          if (isSameOrDescendant(node) && docURL.hash &&\n              node.id && docURL.hash === `#${node.id}`) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          if (docURL.hash) {\n            const hash = docURL.hash.replace(/^#/, '');\n            let current = document.getElementById(hash);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === document.activeElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-within': {\n          let current = document.activeElement;\n          while (current) {\n            if (current === node) {\n              matched.add(node);\n              break;\n            }\n            current = current.parentNode;\n          }\n          break;\n        }\n        case 'open': {\n          if (HTML_INTERACT.test(localName) && node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'closed': {\n          if (HTML_INTERACT.test(localName) && !node.hasAttribute('open')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'disabled': {\n          if (FORM_PARTS.test(localName) || isCustomElementName(localName)) {\n            if (node.disabled || node.hasAttribute('disabled')) {\n              matched.add(node);\n            } else {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset') {\n                  break;\n                }\n                parent = parent.parentNode;\n              }\n              if (parent && parent.hasAttribute('disabled') &&\n                  parentNode.localName !== 'legend') {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'enabled': {\n          if ((FORM_PARTS.test(localName) || isCustomElementName(localName)) &&\n              !(node.disabled && node.hasAttribute('disabled'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'read-only': {\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type ||\n                   INPUT_EDIT.test(node.type) || INPUT_TIME.test(node.type)) &&\n                  (node.readonly || node.hasAttribute('readonly') ||\n                   node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (!isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'read-write': {\n          switch (localName) {\n            case 'textarea': {\n              if (!(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            case 'input': {\n              if ((!node.type ||\n                   INPUT_EDIT.test(node.type) || INPUT_TIME.test(node.type)) &&\n                  !(node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled'))) {\n                matched.add(node);\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let targetNode;\n          if (localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              if (INPUT_EDIT.test(node.getAttribute('type'))) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode && node.hasAttribute('placeholder') &&\n              node.getAttribute('placeholder').trim().length &&\n              node.value === '') {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'checked': {\n          if ((localName === 'input' && node.hasAttribute('type') &&\n               INPUT_CHECK.test(node.getAttribute('type')) &&\n               node.checked) ||\n              (localName === 'option' && node.selected)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((localName === 'input' && node.type === 'checkbox' &&\n               node.indeterminate) ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = documentElement;\n            }\n            const nodes = [...parent.getElementsByTagName('input')];\n            let checked;\n            for (const item of nodes) {\n              if (item.getAttribute('type') === 'radio') {\n                if (nodeName) {\n                  if (item.getAttribute('name') === nodeName) {\n                    checked = !!item.checked;\n                  }\n                } else if (!item.hasAttribute('name')) {\n                  checked = !!item.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') &&\n                 INPUT_RESET.test(node.getAttribute('type')))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               INPUT_SUBMIT.test(node.getAttribute('type')))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const iterator = document.createNodeIterator(form, SHOW_ELEMENT);\n              let nextNode = iterator.nextNode();\n              while (nextNode) {\n                const nodeName = nextNode.localName;\n                let m;\n                if (nodeName === 'button') {\n                  m = !(nextNode.hasAttribute('type') &&\n                    INPUT_RESET.test(nextNode.getAttribute('type')));\n                } else if (nodeName === 'input') {\n                  m = nextNode.hasAttribute('type') &&\n                    INPUT_SUBMIT.test(nextNode.getAttribute('type'));\n                }\n                if (m) {\n                  if (nextNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                nextNode = iterator.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     INPUT_CHECK.test(node.getAttribute('type')) &&\n                     (node.checked || node.hasAttribute('checked'))) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option') {\n            let isMultiple = false;\n            let parent = parentNode;\n            while (parent) {\n              if (parent.localName === 'datalist') {\n                break;\n              } else if (parent.localName === 'select') {\n                if (parent.multiple || parent.hasAttribute('multiple')) {\n                  isMultiple = true;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (isMultiple) {\n              if (node.selected || node.hasAttribute('selected')) {\n                matched.add(node);\n              }\n            } else {\n              const firstOpt = parentNode.firstElementChild;\n              const defaultOpt = new Set();\n              let opt = firstOpt;\n              while (opt) {\n                if (opt.selected || opt.hasAttribute('selected')) {\n                  defaultOpt.add(opt);\n                  break;\n                }\n                opt = opt.nextElementSibling;\n              }\n              if (!defaultOpt.size) {\n                defaultOpt.add(firstOpt);\n              }\n              if (defaultOpt.has(node)) {\n                matched.add(node);\n              }\n            }\n          }\n          break;\n        }\n        case 'valid': {\n          if (FORM_VALIDITY.test(localName)) {\n            if (node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (/^fieldset$/.test(localName)) {\n            const iterator = document.createNodeIterator(node, SHOW_ELEMENT);\n            let refNode = iterator.nextNode();\n            if (refNode === node) {\n              refNode = iterator.nextNode();\n            }\n            let bool;\n            while (refNode) {\n              if (FORM_VALIDITY.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = iterator.nextNode();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'invalid': {\n          if (FORM_VALIDITY.test(localName)) {\n            if (!node.checkValidity()) {\n              matched.add(node);\n            }\n          } else if (/^fieldset$/.test(localName)) {\n            const iterator = document.createNodeIterator(node, SHOW_ELEMENT);\n            let refNode = iterator.nextNode();\n            if (refNode === node) {\n              refNode = iterator.nextNode();\n            }\n            let bool;\n            while (refNode) {\n              if (FORM_VALIDITY.test(refNode.localName)) {\n                bool = refNode.checkValidity();\n                if (!bool) {\n                  break;\n                }\n              }\n              refNode = iterator.nextNode();\n            }\n            if (!bool) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              INPUT_RANGE.test(node.getAttribute('type')) &&\n              !(node.validity.rangeUnderflow ||\n                node.validity.rangeOverflow) &&\n              (node.hasAttribute('min') || node.hasAttribute('max') ||\n               node.getAttribute('type') === 'range')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'out-of-range': {\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              node.hasAttribute('type') &&\n              INPUT_RANGE.test(node.getAttribute('type')) &&\n              (node.validity.rangeUnderflow || node.validity.rangeOverflow)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'required': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (INPUT_EDIT.test(inputType) || INPUT_CHECK.test(inputType) ||\n                  INPUT_TIME.test(inputType) || inputType === 'file') {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              (node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'optional': {\n          let targetNode;\n          if (/^(?:select|textarea)$/.test(localName)) {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const inputType = node.getAttribute('type');\n              if (INPUT_EDIT.test(inputType) || INPUT_CHECK.test(inputType) ||\n                  INPUT_TIME.test(inputType) || inputType === 'file') {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode &&\n              !(node.required || node.hasAttribute('required'))) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'root': {\n          if (node === documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            const nodes = node.childNodes.values();\n            let bool;\n            for (const refNode of nodes) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              (root.nodeType === ELEMENT_NODE && node === root)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              (root.nodeType === ELEMENT_NODE && node === root)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode &&\n               node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) ||\n              (root.nodeType === ELEMENT_NODE && node === root)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (root.nodeType === ELEMENT_NODE && node === root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (root.nodeType === ELEMENT_NODE && node === root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (root.nodeType === ELEMENT_NODE && node === root) {\n            matched.add(node);\n          }\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (this.#warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        case 'active':\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'focus-visible':\n        case 'fullscreen':\n        case 'future':\n        case 'hover':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (this.#warn) {\n            throw new DOMException(`Unsupported pseudo-class :${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (this.#warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}`,\n                NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            throw new DOMException(`Unknown pseudo-class :${astName}`,\n              SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match attribute selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchAttributeSelector(ast, node) {\n    const {\n      flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n    } = ast;\n    if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n      throw new DOMException('Invalid attribute selector', SYNTAX_ERR);\n    }\n    const { attributes } = node;\n    let res;\n    if (attributes && attributes.length) {\n      const { document } = this.#root;\n      let caseInsensitive;\n      if (document.contentType === 'text/html') {\n        if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n          caseInsensitive = false;\n        } else {\n          caseInsensitive = true;\n        }\n      } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n        caseInsensitive = true;\n      } else {\n        caseInsensitive = false;\n      }\n      let { name: astAttrName } = astName;\n      astAttrName = unescapeSelector(astAttrName);\n      if (caseInsensitive) {\n        astAttrName = astAttrName.toLowerCase();\n      }\n      const attrValues = new Set();\n      // namespaced\n      if (/\\|/.test(astAttrName)) {\n        const {\n          prefix: astAttrPrefix, tagName: astAttrLocalName\n        } = selectorToNodeProps(astAttrName);\n        for (let { name: itemName, value: itemValue } of attributes) {\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          switch (astAttrPrefix) {\n            case '': {\n              if (astAttrLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            case '*': {\n              if (/:/.test(itemName)) {\n                if (itemName.endsWith(`:${astAttrLocalName}`)) {\n                  attrValues.add(itemValue);\n                }\n              } else if (astAttrLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            default: {\n              if (/:/.test(itemName)) {\n                const [itemNamePrefix, itemNameLocalName] = itemName.split(':');\n                if (astAttrPrefix === itemNamePrefix &&\n                    astAttrLocalName === itemNameLocalName &&\n                    isNamespaceDeclared(astAttrPrefix, node)) {\n                  attrValues.add(itemValue);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        for (let { name: itemName, value: itemValue } of attributes) {\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          if (/:/.test(itemName)) {\n            const [, itemNameLocalName] = itemName.split(':');\n            if (astAttrName === itemNameLocalName) {\n              attrValues.add(itemValue);\n            }\n          } else if (astAttrName === itemName) {\n            attrValues.add(itemValue);\n          }\n        }\n      }\n      if (attrValues.size) {\n        const {\n          name: astAttrIdentValue, value: astAttrStringValue\n        } = astValue || {};\n        let attrValue;\n        if (astAttrIdentValue) {\n          if (caseInsensitive) {\n            attrValue = astAttrIdentValue.toLowerCase();\n          } else {\n            attrValue = astAttrIdentValue;\n          }\n        } else if (astAttrStringValue) {\n          if (caseInsensitive) {\n            attrValue = astAttrStringValue.toLowerCase();\n          } else {\n            attrValue = astAttrStringValue;\n          }\n        } else if (astAttrStringValue === '') {\n          attrValue = astAttrStringValue;\n        }\n        switch (astMatcher) {\n          case '=': {\n            if (typeof attrValue === 'string' && attrValues.has(attrValue)) {\n              res = node;\n            }\n            break;\n          }\n          case '~=': {\n            if (attrValue && typeof attrValue === 'string') {\n              for (const value of attrValues) {\n                const item = new Set(value.split(/\\s+/));\n                if (item.has(attrValue)) {\n                  res = node;\n                  break;\n                }\n              }\n            }\n            break;\n          }\n          case '|=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '^=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.startsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '$=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.endsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '*=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.includes(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case null:\n          default: {\n            res = node;\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match class selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchClassSelector(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (node.classList.contains(astName)) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match ID selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchIDSelector(ast, node) {\n    const { id } = node;\n    const astName = unescapeSelector(ast.name);\n    let res;\n    if (astName === id) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match type selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchTypeSelector(ast, node) {\n    const astName = unescapeSelector(ast.name);\n    const { localName, prefix } = node;\n    const { document } = this.#root;\n    let {\n      prefix: astPrefix, tagName: astNodeName\n    } = selectorToNodeProps(astName, node);\n    if (document.contentType === 'text/html') {\n      astPrefix = astPrefix.toLowerCase();\n      astNodeName = astNodeName.toLowerCase();\n    }\n    let nodePrefix;\n    let nodeName;\n    // just in case that the namespaced content is parsed as text/html\n    if (/:/.test(localName)) {\n      [nodePrefix, nodeName] = localName.split(':');\n    } else {\n      nodePrefix = prefix || '';\n      nodeName = localName;\n    }\n    let res;\n    if (astPrefix === '' && nodePrefix === '') {\n      if (node.namespaceURI === null &&\n          (astNodeName === '*' || astNodeName === nodeName)) {\n        res = node;\n      }\n    } else if (astPrefix === '*') {\n      if (astNodeName === '*' || astNodeName === nodeName) {\n        res = node;\n      }\n    } else if (astPrefix === nodePrefix &&\n               isNamespaceDeclared(astPrefix, node)) {\n      if (astNodeName === '*' || astNodeName === nodeName) {\n        res = node;\n      }\n    }\n    return res ?? null;\n  };\n\n  /**\n   * match selector\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {object} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt) {\n    const { type } = ast;\n    let matched = new Set();\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (type) {\n        case ATTRIBUTE_SELECTOR: {\n          const res = this._matchAttributeSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n          break;\n        }\n        case CLASS_SELECTOR: {\n          const res = this._matchClassSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n          break;\n        }\n        case ID_SELECTOR: {\n          const res = this._matchIDSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n          break;\n        }\n        case PSEUDO_CLASS_SELECTOR: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          if (nodes.size) {\n            matched = nodes;\n          }\n          break;\n        }\n        case PSEUDO_ELEMENT_SELECTOR: {\n          const astName = unescapeSelector(ast.name);\n          this._matchPseudoElementSelector(astName, opt);\n          break;\n        }\n        case TYPE_SELECTOR:\n        default: {\n          const res = this._matchTypeSelector(ast, node);\n          if (res) {\n            matched.add(res);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} [opt] - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let bool;\n    for (const leaf of leaves) {\n      bool = this._matchSelector(leaf, node, opt).has(node);\n      if (!bool) {\n        break;\n      }\n    }\n    return !!bool;\n  }\n\n  /**\n   * find descendant nodes\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node\n   * @returns {object} - result\n   */\n  _findDescendantNodes(leaves, baseNode) {\n    const [leaf, ...items] = leaves;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const matchItems = items.length > 0;\n    const { document, root } = this.#root;\n    let nodes = new Set();\n    let pending = false;\n    switch (leafType) {\n      case ID_SELECTOR: {\n        if (root.nodeType === ELEMENT_NODE) {\n          pending = true;\n        } else {\n          const elm = root.getElementById(leafName);\n          if (elm && elm !== baseNode) {\n            const bool = isSameOrDescendant(elm, baseNode);\n            let node;\n            if (bool) {\n              node = elm;\n            }\n            if (node) {\n              if (matchItems) {\n                const bool = this._matchLeaves(items, node);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n        }\n        break;\n      }\n      case CLASS_SELECTOR: {\n        const arr = [...baseNode.getElementsByClassName(leafName)];\n        if (arr.length) {\n          if (matchItems) {\n            for (const node of arr) {\n              const bool = this._matchLeaves(items, node);\n              if (bool) {\n                nodes.add(node);\n              }\n            }\n          } else {\n            nodes = new Set(arr);\n          }\n        }\n        break;\n      }\n      case TYPE_SELECTOR: {\n        if (document.contentType !== 'text/html' || /[*|]/.test(leafName)) {\n          pending = true;\n        } else {\n          const arr = [...baseNode.getElementsByTagName(leafName)];\n          if (arr.length) {\n            if (matchItems) {\n              for (const node of arr) {\n                const bool = this._matchLeaves(items, node);\n                if (bool) {\n                  nodes.add(node);\n                }\n              }\n            } else {\n              nodes = new Set(arr);\n            }\n          }\n        }\n        break;\n      }\n      case PSEUDO_ELEMENT_SELECTOR: {\n        this._matchPseudoElementSelector(leafName);\n        break;\n      }\n      default: {\n        pending = true;\n      }\n    }\n    return {\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * match combinator\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} [opt] - option\n   * @param {string} [opt.find] - 'prev'|'next', which nodes to find\n   * @param {boolean} [opt.forgive] - is forgiving selector list\n   * @returns {object} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt = {}) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { find, forgive } = opt;\n    let matched = new Set();\n    if (find === 'next') {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          let refNode = node.nextElementSibling;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = refNode.nextElementSibling;\n          }\n          break;\n        }\n        case '>': {\n          const childNodes = [...node.children];\n          for (const refNode of childNodes) {\n            const bool = this._matchLeaves(leaves, refNode);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const { nodes, pending } = this._findDescendantNodes(leaves, node);\n          if (nodes.size) {\n            matched = nodes;\n          } else if (pending) {\n            const { document } = this.#root;\n            const iterator = document.createNodeIterator(node, SHOW_ELEMENT);\n            let refNode = iterator.nextNode();\n            if (refNode === node) {\n              refNode = iterator.nextNode();\n            }\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = iterator.nextNode();\n            }\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, {\n              forgive\n            });\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          const arr = [];\n          let refNode = node.previousElementSibling;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, {\n              forgive\n            });\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.previousElementSibling;\n          }\n          if (arr.length) {\n            matched = new Set(arr.reverse());\n          }\n          break;\n        }\n        case '>': {\n          const refNode = node.parentNode;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, {\n              forgive\n            });\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = node.parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, {\n              forgive\n            });\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            matched = new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find nodes\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @returns {object} - result\n   */\n  _findNodes(twig, targetType) {\n    const { leaves: [leaf, ...items] } = twig;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const matchItems = items.length > 0;\n    const { document, root } = this.#root;\n    let nodes = new Set();\n    let pending = false;\n    switch (leafType) {\n      case ID_SELECTOR: {\n        let node;\n        if (targetType === TARGET_SELF) {\n          const bool = this._matchLeaves([leaf], this.#node);\n          if (bool) {\n            node = this.#node;\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            const bool = this._matchLeaves([leaf], refNode);\n            if (bool) {\n              node = refNode;\n              break;\n            }\n            refNode = refNode.parentNode;\n          }\n        } else if (root.nodeType === ELEMENT_NODE) {\n          pending = true;\n        } else {\n          node = root.getElementById(leafName);\n        }\n        if (node) {\n          if (matchItems) {\n            const bool = this._matchLeaves(items, node);\n            if (bool) {\n              nodes.add(node);\n            }\n          } else {\n            nodes.add(node);\n          }\n        }\n        break;\n      }\n      case CLASS_SELECTOR: {\n        const arr = [];\n        if (targetType === TARGET_SELF) {\n          if (this.#node.nodeType === ELEMENT_NODE &&\n              this.#node.classList.contains(leafName)) {\n            arr.push(this.#node);\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            if (refNode.nodeType === ELEMENT_NODE) {\n              if (refNode.classList.contains(leafName)) {\n                arr.push(refNode);\n              }\n              refNode = refNode.parentNode;\n            } else {\n              break;\n            }\n          }\n        } else if (root.nodeType === DOCUMENT_FRAGMENT_NODE) {\n          const childNodes = [...root.children];\n          for (const node of childNodes) {\n            if (node.classList.contains(leafName)) {\n              arr.push(node);\n            }\n            const a = [...node.getElementsByClassName(leafName)];\n            arr.push(...a);\n          }\n        } else {\n          const a = [...root.getElementsByClassName(leafName)];\n          arr.push(...a);\n        }\n        if (arr.length) {\n          if (matchItems) {\n            for (const node of arr) {\n              const bool = this._matchLeaves(items, node);\n              if (bool) {\n                nodes.add(node);\n              }\n            }\n          } else {\n            nodes = new Set(arr);\n          }\n        }\n        break;\n      }\n      case TYPE_SELECTOR: {\n        const arr = [];\n        if (targetType === TARGET_SELF) {\n          const bool = this.#node.nodeType === ELEMENT_NODE &&\n                       this._matchLeaves([leaf], this.#node);\n          if (bool) {\n            arr.push(this.#node);\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            if (refNode.nodeType === ELEMENT_NODE) {\n              const bool = this._matchLeaves([leaf], refNode);\n              if (bool) {\n                arr.push(refNode);\n              }\n              refNode = refNode.parentNode;\n            } else {\n              break;\n            }\n          }\n        } else if (document.contentType !== 'text/html' ||\n                   /[*|]/.test(leafName)) {\n          pending = true;\n        } else if (root.nodeType === DOCUMENT_FRAGMENT_NODE) {\n          const tagName = leafName.toLowerCase();\n          const childNodes = [...root.children];\n          for (const node of childNodes) {\n            if (node.localName === tagName) {\n              arr.push(node);\n            }\n            const a = [...node.getElementsByTagName(leafName)];\n            arr.push(...a);\n          }\n        } else {\n          const a = [...root.getElementsByTagName(leafName)];\n          arr.push(...a);\n        }\n        if (arr.length) {\n          if (matchItems) {\n            for (const node of arr) {\n              const bool = this._matchLeaves(items, node);\n              if (bool) {\n                nodes.add(node);\n              }\n            }\n          } else {\n            nodes = new Set(arr);\n          }\n        }\n        break;\n      }\n      case PSEUDO_ELEMENT_SELECTOR: {\n        this._matchPseudoElementSelector(leafName);\n        break;\n      }\n      default: {\n        const arr = [];\n        if (targetType === TARGET_SELF) {\n          const bool = this._matchLeaves([leaf], this.#node);\n          if (bool) {\n            arr.push(this.#node);\n          }\n        } else if (targetType === TARGET_LINEAL) {\n          let refNode = this.#node;\n          while (refNode) {\n            const bool = this._matchLeaves([leaf], refNode);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n        } else {\n          pending = true;\n        }\n        if (arr.length) {\n          if (matchItems) {\n            for (const node of arr) {\n              const bool = this._matchLeaves(items, node);\n              if (bool) {\n                nodes.add(node);\n              }\n            }\n          } else {\n            nodes = new Set(arr);\n          }\n        }\n      }\n    }\n    return {\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * get first twig\n   * @param {Array.<object>} branch - AST branch\n   * @returns {object} - result\n   */\n  _getFirstTwig(branch) {\n    const lastIndex = branch.length - 1;\n    const firstTwig = branch[0];\n    let find;\n    let twig;\n    if (lastIndex) {\n      const lastTwig = branch[lastIndex];\n      const { leaves: [{ type: lastType }] } = lastTwig;\n      if (lastType === PSEUDO_ELEMENT_SELECTOR || lastType === ID_SELECTOR) {\n        find = 'prev';\n        twig = lastTwig;\n      } else {\n        find = 'next';\n        twig = firstTwig;\n      }\n    } else {\n      find = 'prev';\n      twig = firstTwig;\n    }\n    return {\n      find,\n      twig\n    };\n  }\n\n  /**\n   * collect nodes\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - matrix\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const { find, twig } = this._getFirstTwig(branch);\n        const { nodes, pending } = this._findNodes(twig, targetType);\n        if (nodes.size) {\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        } else {\n          this.#ast[i].skip = true;\n        }\n        this.#ast[i].find = find;\n        i++;\n      }\n      if (pendingItems.size) {\n        const { document, root } = this.#root;\n        const iterator = document.createNodeIterator(root, SHOW_ELEMENT);\n        let nextNode = iterator.nextNode();\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            bool = isSameOrDescendant(nextNode, this.#node);\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode);\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#nodes[index].add(nextNode);\n              }\n            }\n          }\n          nextNode = iterator.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const { nodes } = this._findNodes(twig, targetType);\n        if (nodes.size) {\n          this.#nodes[i] = nodes;\n        } else {\n          this.#ast[i].skip = true;\n        }\n        this.#ast[i].find = 'prev';\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * match nodes\n   * @param {string} targetType - target type\n   * @returns {object} - collection of matched nodes\n   */\n  _matchNodes(targetType) {\n    const [...branches] = this.#ast;\n    const l = branches.length;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, find, skip } = branches[i];\n      const branchLen = branch.length;\n      if (skip) {\n        continue;\n      } else if (branchLen) {\n        const matched = this.#nodes[i];\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (const node of matched) {\n              if (node !== this.#node) {\n                if (isSameOrDescendant(node, this.#node)) {\n                  nodes.add(node);\n                  if (targetType === TARGET_FIRST) {\n                    break;\n                  }\n                }\n              }\n            }\n          } else if (targetType === TARGET_FIRST) {\n            const [node] = [...matched];\n            nodes.add(node);\n          } else {\n            const n = [...nodes];\n            const m = [...matched];\n            nodes = new Set([...n, ...m]);\n          }\n        } else if (find === 'next') {\n          let { combo } = branch[0];\n          for (const node of matched) {\n            let nextNodes = new Set([node]);\n            for (let j = 1; j < branchLen; j++) {\n              const { combo: nextCombo, leaves } = branch[j];\n              const arr = [];\n              for (const nextNode of nextNodes) {\n                const twig = {\n                  combo,\n                  leaves\n                };\n                const m = this._matchCombinator(twig, nextNode, { find });\n                if (m.size) {\n                  arr.push(...m);\n                }\n              }\n              const matchedNodes = new Set(arr);\n              if (matchedNodes.size) {\n                if (j === lastIndex) {\n                  if (targetType === TARGET_FIRST) {\n                    const [node] = [...matchedNodes];\n                    nodes.add(node);\n                  } else {\n                    const n = [...nodes];\n                    const m = [...matchedNodes];\n                    nodes = new Set([...n, ...m]);\n                  }\n                  break;\n                } else {\n                  combo = nextCombo;\n                  nextNodes = matchedNodes;\n                }\n              } else {\n                break;\n              }\n            }\n          }\n        } else {\n          for (const node of matched) {\n            let nextNodes = new Set([node]);\n            let bool;\n            for (let j = lastIndex - 1; j >= 0; j--) {\n              const twig = branch[j];\n              const arr = [];\n              for (const nextNode of nextNodes) {\n                const m = this._matchCombinator(twig, nextNode, { find });\n                if (m.size) {\n                  arr.push(...m);\n                }\n              }\n              const matchedNodes = new Set(arr);\n              if (matchedNodes.size) {\n                bool = true;\n                if (j === 0) {\n                  nodes.add(node);\n                  break;\n                } else {\n                  nextNodes = matchedNodes;\n                }\n              } else {\n                bool = false;\n                break;\n              }\n            }\n            if (bool && targetType !== TARGET_ALL) {\n              break;\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * find matched nodes\n   * @param {string} targetType - target type\n   * @returns {object} - collection of matched nodes\n   */\n  _find(targetType) {\n    this._collectNodes(targetType);\n    const nodes = this._matchNodes(targetType);\n    return nodes;\n  }\n\n  /**\n   * sort nodes\n   * @param {object} nodes - collection of nodes\n   * @returns {Array.<object|undefined>} - collection of sorted nodes\n   */\n  _sortNodes(nodes) {\n    const arr = [...nodes];\n    if (arr.length > 1) {\n      arr.sort((a, b) => {\n        let res;\n        const posBit = a.compareDocumentPosition(b);\n        if (posBit & DOCUMENT_POSITION_PRECEDING ||\n            posBit & DOCUMENT_POSITION_CONTAINS) {\n          res = 1;\n        } else {\n          res = -1;\n        }\n        return res;\n      });\n    }\n    return arr;\n  }\n\n  /**\n   * matches\n   * @returns {boolean} - `true` if matched `false` otherwise\n   */\n  matches() {\n    if (this.#node.nodeType !== ELEMENT_NODE) {\n      throw new TypeError(`Unexpected node ${this.#node.nodeName}`);\n    }\n    let res;\n    try {\n      const nodes = this._find(TARGET_SELF);\n      res = nodes.has(this.#node);\n    } catch (e) {\n      this._onError(e);\n    }\n    return !!res;\n  }\n\n  /**\n   * closest\n   * @returns {?object} - matched node\n   */\n  closest() {\n    if (this.#node.nodeType !== ELEMENT_NODE) {\n      throw new TypeError(`Unexpected node ${this.#node.nodeName}`);\n    }\n    let res;\n    try {\n      const nodes = this._find(TARGET_LINEAL);\n      let node = this.#node;\n      while (node) {\n        if (nodes.has(node)) {\n          res = node;\n          break;\n        }\n        node = node.parentNode;\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector\n   * @returns {?object} - matched node\n   */\n  querySelector() {\n    let res;\n    try {\n      const nodes = this._find(TARGET_FIRST);\n      nodes.delete(this.#node);\n      if (nodes.size > 1) {\n        [res] = this._sortNodes(nodes);\n      } else if (nodes.size) {\n        [res] = [...nodes];\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector all\n   * NOTE: returns Array, not NodeList\n   * @returns {Array.<object|undefined>} - collection of matched nodes\n   */\n  querySelectorAll() {\n    const res = [];\n    try {\n      const nodes = this._find(TARGET_ALL);\n      nodes.delete(this.#node);\n      if (nodes.size > 1 && this.#sort) {\n        res.push(...this._sortNodes(nodes));\n      } else if (nodes.size) {\n        res.push(...nodes);\n      }\n    } catch (e) {\n      this._onError(e);\n    }\n    return res;\n  }\n};\n"],
  "mappings": "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",
  "names": ["matcher_exports", "__export", "Matcher", "__toCommonJS", "import_is_potential_custom_element_name", "import_dom_util", "import_parser", "import_constant", "TARGET_ALL", "TARGET_FIRST", "TARGET_LINEAL", "TARGET_SELF", "FORM_PARTS", "FORM_VALIDITY", "HTML_ANCHOR", "HTML_INTERACT", "INPUT_CHECK", "INPUT_EDIT", "INPUT_RANGE", "INPUT_RESET", "INPUT_SUBMIT", "INPUT_TIME", "PSEUDO_FUNC", "PSEUDO_NTH", "#ast", "#bit", "#cache", "#node", "#nodes", "#root", "#selector", "#sort", "#warn", "selector", "node", "opt", "sort", "warn", "e", "document", "root", "parent", "leaves", "arr", "a", "b", "typeA", "typeB", "bitA", "bitB", "res", "ast", "branches", "tree", "nodes", "i", "items", "branch", "item", "nextItem", "msg", "anb", "reverse", "parentNode", "matched", "selectorBranches", "l", "selectorNodes", "branchesLen", "refNode", "bool", "current", "n", "nth", "j", "localName", "prefix", "itemLocalName", "itemPrefix", "nthName", "nthIdentName", "identName", "anbMap", "astName", "forgive", "dir", "lang", "codePart", "reg", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "target", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "twigBranches", "lastIndex", "nextNodes", "m", "matchedNodes", "astChildren", "selectors", "css", "leavesSet", "documentElement", "docURL", "attrURL", "hash", "isCustomElementName", "targetNode", "nodeName", "checked", "form", "iterator", "isMultiple", "firstOpt", "defaultOpt", "inputType", "node1", "node2", "astFlags", "astMatcher", "astValue", "attributes", "caseInsensitive", "astAttrName", "attrValues", "astAttrPrefix", "astAttrLocalName", "itemName", "itemValue", "itemNamePrefix", "itemNameLocalName", "astAttrIdentValue", "astAttrStringValue", "attrValue", "value", "id", "astPrefix", "astNodeName", "nodePrefix", "type", "baseNode", "leafName", "matchItems", "pending", "elm", "comboName", "find", "childNodes", "targetType", "tagName", "firstTwig", "lastTwig", "lastType", "pendingItems", "pendingItem", "index", "skip", "branchLen", "nextCombo", "posBit"]
}
