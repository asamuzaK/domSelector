{
  "version": 3,
  "sources": ["../../../src/js/matcher.js"],
  "sourcesContent": ["/**\n * matcher.js\n * NOTE: Pseudo-class selector matching is done within `./finder.js`.\n *       Functions that begin with `_` are not intended for general use,\n *       and are exported for testing purposes only.\n */\n\n/* import */\nimport { isNamespaceDeclared } from './dom-util.js';\nimport { generateCSS, parseAstName, unescapeSelector } from './parser.js';\n\n/* constants */\nimport {\n  ELEMENT_NODE, NOT_SUPPORTED_ERR, SELECTOR_ATTR, SELECTOR_TYPE, SYNTAX_ERR,\n  TYPE_FROM, TYPE_TO\n} from './constant.js';\n\n/**\n * match attribute selector\n * @private\n * @param {object} ast - AST\n * @param {object} node - Element node or structured clone\n * @returns {?object} - matched node\n */\nexport const _matchAttributeSelector = (ast, node) => {\n  const {\n    flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n  } = ast;\n  if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n    const css = generateCSS(ast);\n    const msg = `Invalid selector ${css}`;\n    throw new DOMException(msg, SYNTAX_ERR);\n  }\n  const { attributes } = node;\n  let res;\n  if (attributes && attributes.length) {\n    const contentType = node.ownerDocument.contentType;\n    let caseInsensitive;\n    if (contentType === 'text/html') {\n      if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n        caseInsensitive = false;\n      } else {\n        caseInsensitive = true;\n      }\n    } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n      caseInsensitive = true;\n    } else {\n      caseInsensitive = false;\n    }\n    let astAttrName = unescapeSelector(astName.name);\n    if (caseInsensitive) {\n      astAttrName = astAttrName.toLowerCase();\n    }\n    const attrValues = new Set();\n    // namespaced\n    if (astAttrName.indexOf('|') > -1) {\n      const {\n        prefix: astPrefix, localName: astLocalName\n      } = parseAstName(astAttrName);\n      for (const item of attributes) {\n        let { name: itemName, value: itemValue } = item;\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        switch (astPrefix) {\n          case '': {\n            if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          case '*': {\n            if (itemName.indexOf(':') > -1) {\n              if (itemName.endsWith(`:${astLocalName}`)) {\n                attrValues.add(itemValue);\n              }\n            } else if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          default: {\n            if (itemName.indexOf(':') > -1) {\n              const [itemPrefix, itemLocalName] = itemName.split(':');\n              // ignore xml:lang\n              if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n                continue;\n              } else if (astPrefix === itemPrefix &&\n                         astLocalName === itemLocalName) {\n                const namespaceDeclared = isNamespaceDeclared(astPrefix, node);\n                if (namespaceDeclared) {\n                  attrValues.add(itemValue);\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      for (let { name: itemName, value: itemValue } of attributes) {\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        if (itemName.indexOf(':') > -1) {\n          const [itemPrefix, itemLocalName] = itemName.split(':');\n          // ignore xml:lang\n          if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n            continue;\n          } else if (astAttrName === itemLocalName) {\n            attrValues.add(itemValue);\n          }\n        } else if (astAttrName === itemName) {\n          attrValues.add(itemValue);\n        }\n      }\n    }\n    if (attrValues.size) {\n      const { name: astIdentValue, value: astStringValue } = astValue ?? {};\n      let attrValue;\n      if (astIdentValue) {\n        if (caseInsensitive) {\n          attrValue = astIdentValue.toLowerCase();\n        } else {\n          attrValue = astIdentValue;\n        }\n      } else if (astStringValue) {\n        if (caseInsensitive) {\n          attrValue = astStringValue.toLowerCase();\n        } else {\n          attrValue = astStringValue;\n        }\n      } else if (astStringValue === '') {\n        attrValue = astStringValue;\n      }\n      switch (astMatcher) {\n        case '=': {\n          if (typeof attrValue === 'string' && attrValues.has(attrValue)) {\n            res = node;\n          }\n          break;\n        }\n        case '~=': {\n          if (attrValue && typeof attrValue === 'string') {\n            for (const value of attrValues) {\n              const item = new Set(value.split(/\\s+/));\n              if (item.has(attrValue)) {\n                res = node;\n                break;\n              }\n            }\n          }\n          break;\n        }\n        case '|=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              res = node;\n            }\n          }\n          break;\n        }\n        case '^=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.startsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              res = node;\n            }\n          }\n          break;\n        }\n        case '$=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.endsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              res = node;\n            }\n          }\n          break;\n        }\n        case '*=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.includes(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              res = node;\n            }\n          }\n          break;\n        }\n        case null:\n        default: {\n          res = node;\n        }\n      }\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * match type selector\n * @private\n * @param {object} ast - AST\n * @param {object} node - Element node or structured clone\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive undeclared namespace\n * @returns {?object} - matched node\n */\nexport const _matchTypeSelector = (ast, node, opt = {}) => {\n  const astName = unescapeSelector(ast.name);\n  const { localName, namespaceURI, prefix } = node;\n  const { forgive } = opt;\n  let {\n    prefix: astPrefix, localName: astLocalName\n  } = parseAstName(astName, node);\n  if (node.ownerDocument.contentType === 'text/html') {\n    astPrefix = astPrefix.toLowerCase();\n    astLocalName = astLocalName.toLowerCase();\n  }\n  let nodePrefix;\n  let nodeLocalName;\n  // just in case that the namespaced content is parsed as text/html\n  if (localName.indexOf(':') > -1) {\n    [nodePrefix, nodeLocalName] = localName.split(':');\n  } else {\n    nodePrefix = prefix || '';\n    nodeLocalName = localName;\n  }\n  let res;\n  switch (astPrefix) {\n    case '': {\n      if (!nodePrefix && !namespaceURI &&\n          (astLocalName === '*' || astLocalName === nodeLocalName)) {\n        res = node;\n      }\n      break;\n    }\n    case '*': {\n      if (astLocalName === '*' || astLocalName === nodeLocalName) {\n        res = node;\n      }\n      break;\n    }\n    default: {\n      const astNS = node.lookupNamespaceURI(astPrefix);\n      const nodeNS = node.lookupNamespaceURI(nodePrefix);\n      if (astNS === nodeNS && astPrefix === nodePrefix) {\n        if (astLocalName === '*' || astLocalName === nodeLocalName) {\n          res = node;\n        }\n      } else if (!forgive && !astNS) {\n        const msg = `Undeclared namespace ${astPrefix}`;\n        throw new DOMException(msg, SYNTAX_ERR);\n      }\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * match selector\n * @param {object} ast - AST\n * @param {object} node - Element node or structured clone\n * @param {object} opt - options\n * @returns {?object} - matched node\n */\nexport const matchSelector = (ast, node, opt) => {\n  if (!ast || !ast.type) {\n    const nodeType =\n      Object.prototype.toString.call(ast).slice(TYPE_FROM, TYPE_TO);\n    const msg = `Unexpected node ${nodeType}`;\n    throw new TypeError(msg);\n  } else if (!node || !node.nodeType) {\n    const nodeType =\n      Object.prototype.toString.call(node).slice(TYPE_FROM, TYPE_TO);\n    const msg = `Unexpected node ${nodeType}`;\n    throw new TypeError(msg);\n  } else if (node.nodeType !== ELEMENT_NODE) {\n    const msg = `Unexpected node ${node.nodeName}`;\n    throw new TypeError(msg);\n  }\n  let matched;\n  switch (ast.type) {\n    case SELECTOR_ATTR: {\n      matched = _matchAttributeSelector(ast, node);\n      break;\n    }\n    case SELECTOR_TYPE:\n    default: {\n      matched = _matchTypeSelector(ast, node, opt);\n    }\n  }\n  return matched;\n};\n\n/**\n * match pseudo-element selector\n * @param {string} astName - AST name\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive unknown pseudo-element\n * @param {boolean} [opt.warn] - warn unsupported pseudo-element\n * @throws {DOMException}\n * @returns {void}\n */\nexport const matchPseudoElementSelector = (astName, opt = {}) => {\n  if (!astName || typeof astName !== 'string') {\n    const nodeType =\n      Object.prototype.toString.call(astName).slice(TYPE_FROM, TYPE_TO);\n    const msg = `Unexpected type ${nodeType}`;\n    throw new TypeError(msg);\n  }\n  const { forgive, warn } = opt;\n  switch (astName) {\n    case 'after':\n    case 'backdrop':\n    case 'before':\n    case 'cue':\n    case 'cue-region':\n    case 'first-letter':\n    case 'first-line':\n    case 'file-selector-button':\n    case 'marker':\n    case 'placeholder':\n    case 'selection':\n    case 'target-text': {\n      if (warn) {\n        const msg = `Unsupported pseudo-element ::${astName}`;\n        throw new DOMException(msg, NOT_SUPPORTED_ERR);\n      }\n      break;\n    }\n    case 'part':\n    case 'slotted': {\n      if (warn) {\n        const msg = `Unsupported pseudo-element ::${astName}()`;\n        throw new DOMException(msg, NOT_SUPPORTED_ERR);\n      }\n      break;\n    }\n    default: {\n      if (astName.startsWith('-webkit-')) {\n        if (warn) {\n          const msg = `Unsupported pseudo-element ::${astName}`;\n          throw new DOMException(msg, NOT_SUPPORTED_ERR);\n        }\n      } else if (!forgive) {\n        const msg = `Unknown pseudo-element ::${astName}`;\n        throw new DOMException(msg, SYNTAX_ERR);\n      }\n    }\n  }\n};\n"],
  "mappings": "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",
  "names": ["matcher_exports", "__export", "_matchAttributeSelector", "_matchTypeSelector", "matchPseudoElementSelector", "matchSelector", "__toCommonJS", "import_dom_util", "import_parser", "import_constant", "ast", "node", "astFlags", "astMatcher", "astName", "astValue", "msg", "attributes", "res", "contentType", "caseInsensitive", "astAttrName", "attrValues", "astPrefix", "astLocalName", "item", "itemName", "itemValue", "itemPrefix", "itemLocalName", "astIdentValue", "astStringValue", "attrValue", "value", "opt", "localName", "namespaceURI", "prefix", "forgive", "nodePrefix", "nodeLocalName", "astNS", "nodeNS", "matched", "warn"]
}
