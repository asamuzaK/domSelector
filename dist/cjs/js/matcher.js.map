{
  "version": 3,
  "sources": ["../../../src/js/matcher.js"],
  "sourcesContent": ["/**\n * matcher.js\n */\n\n/* import */\nimport { generateCSS, parseAstName, unescapeSelector } from './parser.js';\nimport { getDirectionality, getType, isNamespaceDeclared } from './utility.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, ELEMENT_NODE, EMPTY, LANG_PART, NOT_SUPPORTED_ERR, REG_LANG,\n  REG_TAG_NAME, SELECTOR_ATTR, SELECTOR_TYPE, SYNTAX_ERR\n} from './constant.js';\n\n/* Matcher */\nexport class Matcher {\n  /**\n   * match pseudo-element selector\n   * @param {string} astName - AST name\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive unknown pseudo-element\n   * @param {boolean} [opt.warn] - warn unsupported pseudo-element\n   * @throws {DOMException}\n   * @returns {void}\n   */\n  matchPseudoElementSelector(astName, opt = {}) {\n    if (!astName || typeof astName !== 'string') {\n      throw new TypeError(`Unexpected type ${getType(astName)}`);\n    }\n    const { forgive, warn } = opt;\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'placeholder':\n      case 'selection':\n      case 'target-text': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      case 'part':\n      case 'slotted': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}()`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          throw new DOMException(`Unknown pseudo-element ::${astName}`,\n            SYNTAX_ERR);\n        }\n      }\n    }\n  }\n\n  /**\n   * match attribute selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchAttributeSelector(ast, node) {\n    const {\n      flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n    } = ast;\n    if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n      const css = generateCSS(ast);\n      throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n    }\n    const { attributes } = node;\n    let res;\n    if (attributes && attributes.length) {\n      const contentType = node.ownerDocument.contentType;\n      let caseInsensitive;\n      if (contentType === 'text/html') {\n        if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n          caseInsensitive = false;\n        } else {\n          caseInsensitive = true;\n        }\n      } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n        caseInsensitive = true;\n      } else {\n        caseInsensitive = false;\n      }\n      let astAttrName = unescapeSelector(astName.name);\n      if (caseInsensitive) {\n        astAttrName = astAttrName.toLowerCase();\n      }\n      const attrValues = new Set();\n      // namespaced\n      if (astAttrName.indexOf('|') > -1) {\n        const {\n          prefix: astPrefix, localName: astLocalName\n        } = parseAstName(astAttrName);\n        for (const item of attributes) {\n          let { name: itemName, value: itemValue } = item;\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          switch (astPrefix) {\n            case '': {\n              if (astLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            case '*': {\n              if (itemName.indexOf(':') > -1) {\n                if (itemName.endsWith(`:${astLocalName}`)) {\n                  attrValues.add(itemValue);\n                }\n              } else if (astLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            default: {\n              if (itemName.indexOf(':') > -1) {\n                const [itemPrefix, itemLocalName] = itemName.split(':');\n                // ignore xml:lang\n                if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n                  continue;\n                } else if (astPrefix === itemPrefix &&\n                           astLocalName === itemLocalName) {\n                  const namespaceDeclared =\n                    isNamespaceDeclared(astPrefix, node);\n                  if (namespaceDeclared) {\n                    attrValues.add(itemValue);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        for (let { name: itemName, value: itemValue } of attributes) {\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          if (itemName.indexOf(':') > -1) {\n            const [itemPrefix, itemLocalName] = itemName.split(':');\n            // ignore xml:lang\n            if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n              continue;\n            } else if (astAttrName === itemLocalName) {\n              attrValues.add(itemValue);\n            }\n          } else if (astAttrName === itemName) {\n            attrValues.add(itemValue);\n          }\n        }\n      }\n      if (attrValues.size) {\n        const { name: astIdentValue, value: astStringValue } = astValue ?? {};\n        let attrValue;\n        if (astIdentValue) {\n          if (caseInsensitive) {\n            attrValue = astIdentValue.toLowerCase();\n          } else {\n            attrValue = astIdentValue;\n          }\n        } else if (astStringValue) {\n          if (caseInsensitive) {\n            attrValue = astStringValue.toLowerCase();\n          } else {\n            attrValue = astStringValue;\n          }\n        } else if (astStringValue === '') {\n          attrValue = astStringValue;\n        }\n        switch (astMatcher) {\n          case '=': {\n            if (typeof attrValue === 'string' && attrValues.has(attrValue)) {\n              res = node;\n            }\n            break;\n          }\n          case '~=': {\n            if (attrValue && typeof attrValue === 'string') {\n              for (const value of attrValues) {\n                const item = new Set(value.split(/\\s+/));\n                if (item.has(attrValue)) {\n                  res = node;\n                  break;\n                }\n              }\n            }\n            break;\n          }\n          case '|=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '^=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.startsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '$=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.endsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '*=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.includes(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case null:\n          default: {\n            res = node;\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match type selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive undeclared namespace\n   * @returns {?object} - matched node\n   */\n  _matchTypeSelector(ast, node, opt = {}) {\n    const astName = unescapeSelector(ast.name);\n    const { localName, namespaceURI, prefix } = node;\n    const { forgive } = opt;\n    let {\n      prefix: astPrefix, localName: astLocalName\n    } = parseAstName(astName, node);\n    if (node.ownerDocument.contentType === 'text/html' &&\n        REG_TAG_NAME.test(localName)) {\n      astPrefix = astPrefix.toLowerCase();\n      astLocalName = astLocalName.toLowerCase();\n    }\n    let nodePrefix;\n    let nodeLocalName;\n    // just in case that the namespaced content is parsed as text/html\n    if (localName.indexOf(':') > -1) {\n      [nodePrefix, nodeLocalName] = localName.split(':');\n    } else {\n      nodePrefix = prefix || '';\n      nodeLocalName = localName;\n    }\n    let res;\n    switch (astPrefix) {\n      case '': {\n        if (!nodePrefix && !namespaceURI &&\n            (astLocalName === '*' || astLocalName === nodeLocalName)) {\n          res = node;\n        }\n        break;\n      }\n      case '*': {\n        if (astLocalName === '*' || astLocalName === nodeLocalName) {\n          res = node;\n        }\n        break;\n      }\n      default: {\n        const astNS = node.lookupNamespaceURI(astPrefix);\n        const nodeNS = node.lookupNamespaceURI(nodePrefix);\n        if (astNS === nodeNS && astPrefix === nodePrefix) {\n          if (astLocalName === '*' || astLocalName === nodeLocalName) {\n            res = node;\n          }\n        } else if (!forgive && !astNS) {\n          throw new DOMException(`Undeclared namespace ${astPrefix}`,\n            SYNTAX_ERR);\n        }\n      }\n    }\n    return res ?? null;\n  };\n\n  /**\n   * match directionality pseudo-class - :dir()\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchDirectionPseudoClass(ast, node) {\n    const dir = getDirectionality(node);\n    let res;\n    if (ast.name === dir) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match language pseudo-class - :lang()\n   * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLanguagePseudoClass(ast, node) {\n    if (ast.name === EMPTY) {\n      return null;\n    }\n    const astName = unescapeSelector(ast.name);\n    if (typeof astName === 'string' && astName !== ast.name) {\n      ast.name = astName;\n    }\n    let res;\n    if (astName === '*') {\n      if (node.hasAttribute('lang')) {\n        if (node.getAttribute('lang')) {\n          res = node;\n        }\n      } else {\n        let parent = node.parentNode;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              if (parent.getAttribute('lang')) {\n                res = node;\n              }\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n      }\n    } else if (astName) {\n      if (REG_LANG.test(astName)) {\n        let regExtendedLang;\n        if (astName.indexOf('-') > -1) {\n          const [langMain, langSub, ...langRest] = astName.split('-');\n          let extendedMain;\n          if (langMain === '*') {\n            extendedMain = `${ALPHA_NUM}${LANG_PART}`;\n          } else {\n            extendedMain = `${langMain}${LANG_PART}`;\n          }\n          const extendedSub = `-${langSub}${LANG_PART}`;\n          const len = langRest.length;\n          let extendedRest = '';\n          if (len) {\n            for (let i = 0; i < len; i++) {\n              extendedRest += `-${langRest[i]}${LANG_PART}`;\n            }\n          }\n          regExtendedLang =\n            new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n        } else {\n          regExtendedLang = new RegExp(`^${astName}${LANG_PART}$`, 'i');\n        }\n        if (node.hasAttribute('lang')) {\n          if (regExtendedLang.test(node.getAttribute('lang'))) {\n            res = node;\n          }\n        } else {\n          let parent = node.parentNode;\n          while (parent) {\n            if (parent.nodeType === ELEMENT_NODE) {\n              if (parent.hasAttribute('lang')) {\n                const value = parent.getAttribute('lang');\n                if (regExtendedLang.test(value)) {\n                  res = node;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @param {boolean} validated - args are validated\n   * @returns {?object} - matched node\n   */\n  matchSelector(ast, node, opt = {}, validated = false) {\n    if (!validated) {\n      if (!ast || !ast.type) {\n        throw new TypeError(`Unexpected ast type ${getType(ast)}`);\n      } else if (!node || !node.nodeType) {\n        throw new TypeError(`Unexpected node type ${getType(node)}`);\n      } else if (node.nodeType !== ELEMENT_NODE) {\n        throw new TypeError(`Unexpected node ${node.nodeName}`);\n      }\n    }\n    let matched;\n    switch (ast.type) {\n      case SELECTOR_ATTR: {\n        matched = this._matchAttributeSelector(ast, node);\n        break;\n      }\n      case SELECTOR_TYPE: {\n        matched = this._matchTypeSelector(ast, node, opt ?? {});\n        break;\n      }\n      default: {\n        const { children: [child], name: astName } = ast;\n        if (astName === 'dir') {\n          matched = this._matchDirectionPseudoClass(child, node);\n        } else if (astName === 'lang') {\n          matched = this._matchLanguagePseudoClass(child, node);\n        }\n      }\n    }\n    return matched;\n  }\n}\n"],
  "mappings": "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",
  "names": ["matcher_exports", "__export", "Matcher", "__toCommonJS", "import_parser", "import_utility", "import_constant", "astName", "opt", "forgive", "warn", "ast", "node", "astFlags", "astMatcher", "astValue", "css", "attributes", "res", "contentType", "caseInsensitive", "astAttrName", "attrValues", "astPrefix", "astLocalName", "item", "itemName", "itemValue", "itemPrefix", "itemLocalName", "astIdentValue", "astStringValue", "attrValue", "value", "localName", "namespaceURI", "prefix", "nodePrefix", "nodeLocalName", "astNS", "nodeNS", "dir", "parent", "regExtendedLang", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "i", "validated", "matched", "child"]
}
