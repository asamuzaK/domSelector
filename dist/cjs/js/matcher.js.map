{
  "version": 3,
  "sources": ["../../../src/js/matcher.js"],
  "sourcesContent": ["/**\n * matcher.js\n */\n\n/* import */\nimport { getDirectionality, isNamespaceDeclared } from './dom-util.js';\nimport { generateCSS, parseAstName, unescapeSelector } from './parser.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, ELEMENT_NODE, EMPTY, LANG_PART, NOT_SUPPORTED_ERR, REG_LANG,\n  REG_TAG_NAME, SELECTOR_ATTR, SELECTOR_TYPE, SYNTAX_ERR, TYPE_FROM, TYPE_TO\n} from './constant.js';\n\n/* Matcher */\nexport class Matcher {\n  /**\n   * match pseudo-element selector\n   * @param {string} astName - AST name\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive unknown pseudo-element\n   * @param {boolean} [opt.warn] - warn unsupported pseudo-element\n   * @throws {DOMException}\n   * @returns {void}\n   */\n  matchPseudoElementSelector(astName, opt = {}) {\n    if (!astName || typeof astName !== 'string') {\n      const nodeType =\n        Object.prototype.toString.call(astName).slice(TYPE_FROM, TYPE_TO);\n      const msg = `Unexpected type ${nodeType}`;\n      throw new TypeError(msg);\n    }\n    const { forgive, warn } = opt;\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'placeholder':\n      case 'selection':\n      case 'target-text': {\n        if (warn) {\n          const msg = `Unsupported pseudo-element ::${astName}`;\n          throw new DOMException(msg, NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      case 'part':\n      case 'slotted': {\n        if (warn) {\n          const msg = `Unsupported pseudo-element ::${astName}()`;\n          throw new DOMException(msg, NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (warn) {\n            const msg = `Unsupported pseudo-element ::${astName}`;\n            throw new DOMException(msg, NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          const msg = `Unknown pseudo-element ::${astName}`;\n          throw new DOMException(msg, SYNTAX_ERR);\n        }\n      }\n    }\n  }\n\n  /**\n   * match attribute selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchAttributeSelector(ast, node) {\n    const {\n      flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n    } = ast;\n    if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n      const css = generateCSS(ast);\n      const msg = `Invalid selector ${css}`;\n      throw new DOMException(msg, SYNTAX_ERR);\n    }\n    const { attributes } = node;\n    let res;\n    if (attributes && attributes.length) {\n      const contentType = node.ownerDocument.contentType;\n      let caseInsensitive;\n      if (contentType === 'text/html') {\n        if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n          caseInsensitive = false;\n        } else {\n          caseInsensitive = true;\n        }\n      } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n        caseInsensitive = true;\n      } else {\n        caseInsensitive = false;\n      }\n      let astAttrName = unescapeSelector(astName.name);\n      if (caseInsensitive) {\n        astAttrName = astAttrName.toLowerCase();\n      }\n      const attrValues = new Set();\n      // namespaced\n      if (astAttrName.indexOf('|') > -1) {\n        const {\n          prefix: astPrefix, localName: astLocalName\n        } = parseAstName(astAttrName);\n        for (const item of attributes) {\n          let { name: itemName, value: itemValue } = item;\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          switch (astPrefix) {\n            case '': {\n              if (astLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            case '*': {\n              if (itemName.indexOf(':') > -1) {\n                if (itemName.endsWith(`:${astLocalName}`)) {\n                  attrValues.add(itemValue);\n                }\n              } else if (astLocalName === itemName) {\n                attrValues.add(itemValue);\n              }\n              break;\n            }\n            default: {\n              if (itemName.indexOf(':') > -1) {\n                const [itemPrefix, itemLocalName] = itemName.split(':');\n                // ignore xml:lang\n                if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n                  continue;\n                } else if (astPrefix === itemPrefix &&\n                           astLocalName === itemLocalName) {\n                  const namespaceDeclared =\n                    isNamespaceDeclared(astPrefix, node);\n                  if (namespaceDeclared) {\n                    attrValues.add(itemValue);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        for (let { name: itemName, value: itemValue } of attributes) {\n          if (caseInsensitive) {\n            itemName = itemName.toLowerCase();\n            itemValue = itemValue.toLowerCase();\n          }\n          if (itemName.indexOf(':') > -1) {\n            const [itemPrefix, itemLocalName] = itemName.split(':');\n            // ignore xml:lang\n            if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n              continue;\n            } else if (astAttrName === itemLocalName) {\n              attrValues.add(itemValue);\n            }\n          } else if (astAttrName === itemName) {\n            attrValues.add(itemValue);\n          }\n        }\n      }\n      if (attrValues.size) {\n        const { name: astIdentValue, value: astStringValue } = astValue ?? {};\n        let attrValue;\n        if (astIdentValue) {\n          if (caseInsensitive) {\n            attrValue = astIdentValue.toLowerCase();\n          } else {\n            attrValue = astIdentValue;\n          }\n        } else if (astStringValue) {\n          if (caseInsensitive) {\n            attrValue = astStringValue.toLowerCase();\n          } else {\n            attrValue = astStringValue;\n          }\n        } else if (astStringValue === '') {\n          attrValue = astStringValue;\n        }\n        switch (astMatcher) {\n          case '=': {\n            if (typeof attrValue === 'string' && attrValues.has(attrValue)) {\n              res = node;\n            }\n            break;\n          }\n          case '~=': {\n            if (attrValue && typeof attrValue === 'string') {\n              for (const value of attrValues) {\n                const item = new Set(value.split(/\\s+/));\n                if (item.has(attrValue)) {\n                  res = node;\n                  break;\n                }\n              }\n            }\n            break;\n          }\n          case '|=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '^=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.startsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '$=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.endsWith(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case '*=': {\n            if (attrValue && typeof attrValue === 'string') {\n              let item;\n              for (const value of attrValues) {\n                if (value.includes(`${attrValue}`)) {\n                  item = value;\n                  break;\n                }\n              }\n              if (item) {\n                res = node;\n              }\n            }\n            break;\n          }\n          case null:\n          default: {\n            res = node;\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match type selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.forgive] - forgive undeclared namespace\n   * @returns {?object} - matched node\n   */\n  _matchTypeSelector(ast, node, opt = {}) {\n    const astName = unescapeSelector(ast.name);\n    const { localName, namespaceURI, prefix } = node;\n    const { forgive } = opt;\n    let {\n      prefix: astPrefix, localName: astLocalName\n    } = parseAstName(astName, node);\n    if (node.ownerDocument.contentType === 'text/html' &&\n        REG_TAG_NAME.test(localName)) {\n      astPrefix = astPrefix.toLowerCase();\n      astLocalName = astLocalName.toLowerCase();\n    }\n    let nodePrefix;\n    let nodeLocalName;\n    // just in case that the namespaced content is parsed as text/html\n    if (localName.indexOf(':') > -1) {\n      [nodePrefix, nodeLocalName] = localName.split(':');\n    } else {\n      nodePrefix = prefix || '';\n      nodeLocalName = localName;\n    }\n    let res;\n    switch (astPrefix) {\n      case '': {\n        if (!nodePrefix && !namespaceURI &&\n            (astLocalName === '*' || astLocalName === nodeLocalName)) {\n          res = node;\n        }\n        break;\n      }\n      case '*': {\n        if (astLocalName === '*' || astLocalName === nodeLocalName) {\n          res = node;\n        }\n        break;\n      }\n      default: {\n        const astNS = node.lookupNamespaceURI(astPrefix);\n        const nodeNS = node.lookupNamespaceURI(nodePrefix);\n        if (astNS === nodeNS && astPrefix === nodePrefix) {\n          if (astLocalName === '*' || astLocalName === nodeLocalName) {\n            res = node;\n          }\n        } else if (!forgive && !astNS) {\n          const msg = `Undeclared namespace ${astPrefix}`;\n          throw new DOMException(msg, SYNTAX_ERR);\n        }\n      }\n    }\n    return res ?? null;\n  };\n\n  /**\n   * match directionality pseudo-class - :dir()\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchDirectionPseudoClass(ast, node) {\n    const dir = getDirectionality(node);\n    let res;\n    if (ast.name === dir) {\n      res = node;\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match language pseudo-class - :lang()\n   * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @returns {?object} - matched node\n   */\n  _matchLanguagePseudoClass(ast, node) {\n    if (ast.name === EMPTY) {\n      return null;\n    }\n    const astName = unescapeSelector(ast.name);\n    if (typeof astName === 'string' && astName !== ast.name) {\n      ast.name = astName;\n    }\n    let res;\n    if (astName === '*') {\n      if (node.hasAttribute('lang')) {\n        if (node.getAttribute('lang')) {\n          res = node;\n        }\n      } else {\n        let parent = node.parentNode;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              if (parent.getAttribute('lang')) {\n                res = node;\n              }\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n      }\n    } else if (astName) {\n      if (REG_LANG.test(astName)) {\n        let regExtendedLang;\n        if (astName.indexOf('-') > -1) {\n          const [langMain, langSub, ...langRest] = astName.split('-');\n          let extendedMain;\n          if (langMain === '*') {\n            extendedMain = `${ALPHA_NUM}${LANG_PART}`;\n          } else {\n            extendedMain = `${langMain}${LANG_PART}`;\n          }\n          const extendedSub = `-${langSub}${LANG_PART}`;\n          const len = langRest.length;\n          let extendedRest = '';\n          if (len) {\n            for (let i = 0; i < len; i++) {\n              extendedRest += `-${langRest[i]}${LANG_PART}`;\n            }\n          }\n          regExtendedLang =\n            new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n        } else {\n          regExtendedLang = new RegExp(`^${astName}${LANG_PART}$`, 'i');\n        }\n        if (node.hasAttribute('lang')) {\n          if (regExtendedLang.test(node.getAttribute('lang'))) {\n            res = node;\n          }\n        } else {\n          let parent = node.parentNode;\n          while (parent) {\n            if (parent.nodeType === ELEMENT_NODE) {\n              if (parent.hasAttribute('lang')) {\n                const value = parent.getAttribute('lang');\n                if (regExtendedLang.test(value)) {\n                  res = node;\n                }\n                break;\n              }\n              parent = parent.parentNode;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    }\n    return res ?? null;\n  }\n\n  /**\n   * match selector\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  matchSelector(ast, node, opt) {\n    if (!ast || !ast.type) {\n      const nodeType =\n        Object.prototype.toString.call(ast).slice(TYPE_FROM, TYPE_TO);\n      const msg = `Unexpected node ${nodeType}`;\n      throw new TypeError(msg);\n    } else if (!node || !node.nodeType) {\n      const nodeType =\n        Object.prototype.toString.call(node).slice(TYPE_FROM, TYPE_TO);\n      const msg = `Unexpected node ${nodeType}`;\n      throw new TypeError(msg);\n    } else if (node.nodeType !== ELEMENT_NODE) {\n      const msg = `Unexpected node ${node.nodeName}`;\n      throw new TypeError(msg);\n    }\n    let matched;\n    switch (ast.type) {\n      case SELECTOR_ATTR: {\n        matched = this._matchAttributeSelector(ast, node);\n        break;\n      }\n      case SELECTOR_TYPE: {\n        matched = this._matchTypeSelector(ast, node, opt);\n        break;\n      }\n      default: {\n        const { children: [child], name: astName } = ast;\n        if (astName === 'dir') {\n          matched = this._matchDirectionPseudoClass(child, node);\n        } else if (astName === 'lang') {\n          matched = this._matchLanguagePseudoClass(child, node);\n        }\n      }\n    }\n    return matched;\n  }\n}\n\nexport const matcher = new Matcher();\nexport default matcher;\n"],
  "mappings": "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",
  "names": ["matcher_exports", "__export", "Matcher", "matcher_default", "matcher", "__toCommonJS", "import_dom_util", "import_parser", "import_constant", "astName", "opt", "msg", "forgive", "warn", "ast", "node", "astFlags", "astMatcher", "astValue", "attributes", "res", "contentType", "caseInsensitive", "astAttrName", "attrValues", "astPrefix", "astLocalName", "item", "itemName", "itemValue", "itemPrefix", "itemLocalName", "astIdentValue", "astStringValue", "attrValue", "value", "localName", "namespaceURI", "prefix", "nodePrefix", "nodeLocalName", "astNS", "nodeNS", "dir", "parent", "regExtendedLang", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "i", "matched", "child"]
}
