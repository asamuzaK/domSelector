{
  "version": 3,
  "sources": ["../../../src/js/utility.js"],
  "sourcesContent": ["/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, KEY_INPUT_BUTTON, KEY_INPUT_EDIT,\n  KEY_INPUT_TEXT, LOGICAL_COMPLEX, LOGICAL_COMPOUND, N_TH, PSEUDO_CLASS,\n  TEXT_NODE, TYPE_FROM, TYPE_TO, WALKER_FILTER\n} from './constant.js';\nconst REG_LOGICAL_COMPLEX =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGICAL_COMPLEX})`);\nconst REG_LOGICAL_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGICAL_COMPOUND})`);\nconst REG_WO_LOGICAL = new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH})`);\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * resolve content document, root node and tree walker\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object>} - array of document, root node, tree walker\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      document = node.ownerDocument;\n      root = node;\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let parent = node;\n      while (parent) {\n        if (parent.parentNode) {\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      root = parent;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  const walker = document.createTreeWalker(root, WALKER_FILTER);\n  return [\n    document,\n    root,\n    walker\n  ];\n};\n\n/**\n * traverse node tree\n * @private\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let current;\n  if (walker?.currentNode) {\n    let refNode = walker.currentNode;\n    if (refNode === node) {\n      return refNode;\n    } else if (refNode.contains(node)) {\n      refNode = walker.nextNode();\n      while (refNode) {\n        if (refNode === node) {\n          return refNode;\n        }\n        refNode = walker.nextNode();\n      }\n    } else {\n      if (refNode !== walker.root) {\n        while (refNode) {\n          if (refNode === walker.root || refNode === node) {\n            break;\n          }\n          refNode = walker.parentNode();\n        }\n      }\n      if (node.nodeType === ELEMENT_NODE) {\n        while (refNode) {\n          if (refNode === node) {\n            return refNode;\n          }\n          refNode = walker.nextNode();\n        }\n      } else {\n        current = refNode;\n      }\n    }\n  }\n  return current ?? null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let bool;\n  if (node.nodeType === ELEMENT_NODE) {\n    const { localName, ownerDocument } = node;\n    const { formAssociated } = opt;\n    const window = ownerDocument.defaultView;\n    let elmConstructor;\n    const attr = node.getAttribute('is');\n    if (attr) {\n      elmConstructor =\n        isCustomElementName(attr) && window.customElements.get(attr);\n    } else {\n      elmConstructor =\n        isCustomElementName(localName) && window.customElements.get(localName);\n    }\n    if (elmConstructor) {\n      if (formAssociated) {\n        bool = elmConstructor.formAssociated;\n      } else {\n        bool = true;\n      }\n    }\n  }\n  return !!bool;\n};\n\n/**\n * is in shadow tree\n * @param {object} node - node\n * @returns {boolean} - result;\n */\nexport const isInShadowTree = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let bool;\n  if (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    let refNode = node;\n    while (refNode) {\n      const { host, mode, nodeType, parentNode } = refNode;\n      if (host && mode && nodeType === DOCUMENT_FRAGMENT_NODE &&\n          (mode === 'close' || mode === 'open')) {\n        bool = true;\n        break;\n      }\n      refNode = parentNode;\n    }\n  }\n  return !!bool;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (node.localName === 'slot' && isInShadowTree(node)) {\n    const nodes = node.assignedNodes();\n    if (nodes.length) {\n      for (const item of nodes) {\n        res = item.textContent.trim();\n        if (res) {\n          break;\n        }\n      }\n    } else {\n      res = node.textContent.trim();\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (node.nodeType === ELEMENT_NODE) {\n    const { dir: nodeDir, localName, parentNode } = node;\n    const { getEmbeddingLevels } = bidiFactory();\n    if (nodeDir === 'ltr' || nodeDir === 'rtl') {\n      return nodeDir;\n    } else if (nodeDir === 'auto') {\n      let text;\n      switch (localName) {\n        case 'input': {\n          const valueKeys = [...KEY_INPUT_BUTTON, ...KEY_INPUT_TEXT, 'hidden'];\n          if (!node.type || valueKeys.includes(node.type)) {\n            text = node.value;\n          } else {\n            const ltrKeys = [\n              'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio',\n              'time'\n            ];\n            if (ltrKeys.includes(node.type)) {\n              return 'ltr';\n            }\n          }\n          break;\n        }\n        case 'slot': {\n          text = getSlottedTextContent(node);\n          break;\n        }\n        case 'textarea': {\n          text = node.value;\n          break;\n        }\n        default: {\n          const items = [].slice.call(node.childNodes);\n          for (const item of items) {\n            const {\n              dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n              textContent: itemTextContent\n            } = item;\n            if (itemNodeType === TEXT_NODE) {\n              text = itemTextContent.trim();\n            } else if (itemNodeType === ELEMENT_NODE) {\n              const keys = ['bdi', 'script', 'style', 'textarea'];\n              if (!keys.includes(itemLocalName) &&\n                  (!itemDir || (itemDir !== 'ltr' && itemDir !== 'rtl'))) {\n                if (itemLocalName === 'slot') {\n                  text = getSlottedTextContent(item);\n                } else {\n                  text = itemTextContent.trim();\n                }\n              }\n            }\n            if (text) {\n              break;\n            }\n          }\n        }\n      }\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n      if (!res) {\n        if (parentNode) {\n          const { nodeType: parentNodeType } = parentNode;\n          if (parentNodeType === ELEMENT_NODE) {\n            return getDirectionality(parentNode);\n          } else if (parentNodeType === DOCUMENT_NODE ||\n                     parentNodeType === DOCUMENT_FRAGMENT_NODE) {\n            return 'ltr';\n          }\n        } else {\n          return 'ltr';\n        }\n      }\n    } else if (localName === 'bdi') {\n      const text = node.textContent.trim();\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n      if (!(res || parentNode)) {\n        return 'ltr';\n      }\n    } else if (localName === 'input' && node.type === 'tel') {\n      return 'ltr';\n    } else if (parentNode) {\n      if (localName === 'slot') {\n        const text = getSlottedTextContent(node);\n        if (text) {\n          const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n          if (level % 2 === 1) {\n            return 'rtl';\n          }\n          return 'ltr';\n        }\n      }\n      if (!res) {\n        const { nodeType: parentNodeType } = parentNode;\n        if (parentNodeType === ELEMENT_NODE) {\n          return getDirectionality(parentNode);\n        } else if (parentNodeType === DOCUMENT_NODE ||\n                   parentNodeType === DOCUMENT_FRAGMENT_NODE) {\n          return 'ltr';\n        }\n      }\n    } else {\n      return 'ltr';\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (node.nodeType === ELEMENT_NODE) {\n    if (typeof node.isContentEditable === 'boolean') {\n      return node.isContentEditable;\n    } else if (node.ownerDocument.designMode === 'on') {\n      return true;\n    } else if (node.hasAttribute('contenteditable')) {\n      const attr = node.getAttribute('contenteditable');\n      switch (attr) {\n        case '':\n        case 'true': {\n          return true;\n        }\n        case 'plaintext-only': {\n          // FIXME: the element's raw text is editable,\n          // but rich text formatting is disabled\n          return true;\n        }\n        case 'false': {\n          return false;\n        }\n        default: {\n          let parent = node.parentNode;\n          while (parent) {\n            if (isContentEditable(parent)) {\n              return true;\n            }\n            parent = parent.parentNode;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  let res;\n  if (node?.nodeType === ELEMENT_NODE) {\n    const window = node.ownerDocument.defaultView;\n    const { display, visibility } = window.getComputedStyle(node);\n    if (display !== 'none' && visibility === 'visible') {\n      return true;\n    }\n  }\n  return !!res;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  let res;\n  if (node?.nodeType === ELEMENT_NODE) {\n    const { localName, type } = node;\n    switch (localName) {\n      case 'input': {\n        if (!type || KEY_INPUT_EDIT.includes(type)) {\n          return true;\n        }\n        break;\n      }\n      case 'textarea': {\n        return true;\n      }\n      default: {\n        return isContentEditable(node);\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is focusable area\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusableArea = node => {\n  if (node?.nodeType === ELEMENT_NODE) {\n    if (!node.isConnected) {\n      return false;\n    }\n    const window = node.ownerDocument.defaultView;\n    if (node instanceof window.HTMLElement) {\n      if (Number.isInteger(parseInt(node.getAttribute('tabindex')))) {\n        return true;\n      }\n      if (isContentEditable(node)) {\n        return true;\n      }\n      const { localName, parentNode } = node;\n      switch (localName) {\n        case 'a': {\n          if (node.href || node.hasAttribute('href')) {\n            return true;\n          }\n          return false;\n        }\n        case 'iframe': {\n          return true;\n        }\n        case 'input': {\n          if (node.disabled || node.hasAttribute('disabled') ||\n              node.hidden || node.hasAttribute('hidden')) {\n            return false;\n          }\n          return true;\n        }\n        case 'summary': {\n          if (parentNode.localName === 'details') {\n            let child = parentNode.firstElementChild;\n            while (child) {\n              if (child.localName === 'summary') {\n                return node === child;\n              }\n              child = child.nextElementSibling;\n            }\n          }\n          return false;\n        }\n        default: {\n          const keys = new Set(['button', 'select', 'textarea']);\n          if (keys.has(localName) &&\n              !(node.disabled || node.hasAttribute('disabled'))) {\n            return true;\n          }\n          return false;\n        }\n      }\n    } else if (node instanceof window.SVGElement) {\n      if (Number.isInteger(parseInt(node.getAttributeNS(null, 'tabindex')))) {\n        const keys = new Set([\n          'clipPath', 'defs', 'desc', 'linearGradient', 'marker', 'mask',\n          'metadata', 'pattern', 'radialGradient', 'script', 'style', 'symbol',\n          'title'\n        ]);\n        const ns = 'http://www.w3.org/2000/svg';\n        let bool;\n        let refNode = node;\n        while (refNode.namespaceURI === ns) {\n          bool = keys.has(refNode.localName);\n          if (bool) {\n            break;\n          }\n          if (refNode?.parentNode?.namespaceURI === ns) {\n            refNode = refNode.parentNode;\n          } else {\n            break;\n          }\n        }\n        if (bool) {\n          return false;\n        }\n        return true;\n      }\n      if (node.localName === 'a' &&\n          (node.href || node.hasAttributeNS(null, 'href'))) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * is focusable\n * NOTE: not applied, need fix in jsdom itself\n * @see https://github.com/whatwg/html/pull/8392\n * @see https://phabricator.services.mozilla.com/D156219\n * @see https://github.com/jsdom/jsdom/issues/3029\n * @see https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  let res;\n  if (node?.nodeType === ELEMENT_NODE) {\n    const window = node.ownerDocument.defaultView;\n    let refNode = node;\n    res = true;\n    while (refNode) {\n      if (refNode.disabled || refNode.hasAttribute('disabled')) {\n        return false;\n      }\n      if (refNode.hidden || refNode.hasAttribute('hidden')) {\n        res = false;\n      }\n      const {\n        contentVisibility, display, visibility\n      } = window.getComputedStyle(refNode);\n      if (display === 'none' || visibility !== 'visible' ||\n          (contentVisibility === 'hidden' && refNode !== node)) {\n        res = false;\n      } else {\n        res = true;\n      }\n      if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n        refNode = refNode.parentNode;\n      } else {\n        break;\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (ns && node.nodeType === ELEMENT_NODE) {\n    const { attributes } = node;\n    for (const attr of attributes) {\n      const { name, namespaceURI, prefix, value } = attr;\n      if (name === `xmlns:${ns}`) {\n        return value;\n      }\n      if (prefix === ns) {\n        return namespaceURI;\n      }\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  let res;\n  if (ns && typeof ns === 'string' && node.nodeType === ELEMENT_NODE) {\n    res = node.lookupNamespaceURI(ns);\n    if (!res) {\n      const root = node.ownerDocument.documentElement;\n      let parent = node;\n      while (parent) {\n        res = getNamespaceURI(ns, parent);\n        if (res || parent === root) {\n          break;\n        }\n        parent = parent.parentNode;\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  let res;\n  if (nodeA.nodeType === ELEMENT_NODE && nodeB.nodeType === ELEMENT_NODE) {\n    const posBit = nodeB.compareDocumentPosition(nodeA);\n    res = posBit & DOCUMENT_POSITION_PRECEDING ||\n          posBit & DOCUMENT_POSITION_CONTAINS;\n  }\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  // exclude missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // exclude namespaced selectors, escaped selectors, pseudo-element selectors,\n  // selectors containing non-ASCII or control character other than whitespace,\n  // attribute selectors with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // include pseudo-classes that are known to work correctly\n  if (selector.includes(':')) {\n    const { complex, descend } = opt;\n    if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        return !REG_LOGICAL_COMPLEX.test(selector);\n      } else {\n        return !REG_LOGICAL_COMPOUND.test(selector);\n      }\n    } else if (descend) {\n      return false;\n    } else {\n      return !REG_WO_LOGICAL.test(selector);\n    }\n  }\n  return true;\n};\n"],
  "mappings": "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",
  "names": ["utility_exports", "__export", "filterSelector", "getDirectionality", "getNamespaceURI", "getSlottedTextContent", "getType", "initNwsapi", "isContentEditable", "isCustomElement", "isFocusVisible", "isFocusable", "isFocusableArea", "isInShadowTree", "isNamespaceDeclared", "isPreceding", "isVisible", "resolveContent", "sortNodes", "traverseNode", "__toCommonJS", "import_nwsapi", "import_bidi_js", "import_is_potential_custom_element_name", "import_constant", "REG_LOGICAL_COMPLEX", "REG_LOGICAL_COMPOUND", "REG_WO_LOGICAL", "o", "node", "document", "root", "parent", "walker", "current", "refNode", "opt", "bool", "localName", "ownerDocument", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "host", "mode", "nodeType", "parentNode", "res", "nodes", "item", "nodeDir", "getEmbeddingLevels", "bidiFactory", "text", "valueKeys", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "display", "visibility", "type", "child", "keys", "ns", "contentVisibility", "attributes", "name", "namespaceURI", "prefix", "value", "nodeA", "nodeB", "posBit", "arr", "a", "b", "nw", "nwsapi", "selector", "index", "complex", "descend"]
}
