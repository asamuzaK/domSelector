{
  "version": 3,
  "sources": ["../../../src/js/utility.js"],
  "sourcesContent": ["/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, KEY_INPUT_BUTTON, KEY_INPUT_EDIT,\n  KEY_INPUT_TEXT, LOGICAL_COMPLEX, LOGICAL_COMPOUND, N_TH, PSEUDO_CLASS,\n  TEXT_NODE, TYPE_FROM, TYPE_TO, WALKER_FILTER\n} from './constant.js';\nconst REG_LOGICAL_COMPLEX =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGICAL_COMPLEX})`);\nconst REG_LOGICAL_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGICAL_COMPOUND})`);\nconst REG_WO_LOGICAL = new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH})`);\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * resolve content document, root node and tree walker\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object>} - array of document, root node, tree walker\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      document = node.ownerDocument;\n      root = node;\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let parent = node;\n      while (parent) {\n        if (parent.parentNode) {\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      root = parent;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  const walker = document.createTreeWalker(root, WALKER_FILTER);\n  return [\n    document,\n    root,\n    walker\n  ];\n};\n\n/**\n * traverse node tree\n * @private\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!walker) {\n    return null;\n  }\n  let refNode = walker.currentNode;\n  if (refNode === node) {\n    return refNode;\n  } else if (refNode.contains(node)) {\n    refNode = walker.nextNode();\n    while (refNode) {\n      if (refNode === node) {\n        break;\n      }\n      refNode = walker.nextNode();\n    }\n    return refNode;\n  } else {\n    if (refNode !== walker.root) {\n      while (refNode) {\n        if (refNode === walker.root || refNode === node) {\n          break;\n        }\n        refNode = walker.parentNode();\n      }\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n      return null;\n    } else {\n      return refNode;\n    }\n  }\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, ownerDocument } = node;\n  const { formAssociated } = opt;\n  const window = ownerDocument.defaultView;\n  let elmConstructor;\n  const attr = node.getAttribute('is');\n  if (attr) {\n    elmConstructor =\n      isCustomElementName(attr) && window.customElements.get(attr);\n  } else {\n    elmConstructor =\n      isCustomElementName(localName) && window.customElements.get(localName);\n  }\n  if (elmConstructor) {\n    if (formAssociated) {\n      return !!elmConstructor.formAssociated;\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * is in shadow tree\n * @param {object} node - node\n * @returns {boolean} - result;\n */\nexport const isInShadowTree = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE &&\n      node.nodeType !== DOCUMENT_FRAGMENT_NODE) {\n    return false;\n  }\n  let refNode = node;\n  let bool = false;\n  while (refNode) {\n    const { host, mode, nodeType, parentNode } = refNode;\n    if (host && mode && nodeType === DOCUMENT_FRAGMENT_NODE &&\n        (mode === 'close' || mode === 'open')) {\n      bool = true;\n      break;\n    }\n    refNode = parentNode;\n  }\n  return bool;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.localName !== 'slot' || !isInShadowTree(node)) {\n    return null;\n  }\n  const nodes = node.assignedNodes();\n  if (nodes.length) {\n    let text;\n    for (const item of nodes) {\n      text = item.textContent.trim();\n      if (text) {\n        break;\n      }\n    }\n    return text;\n  }\n  return node.textContent.trim();\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { dir: nodeDir, localName, parentNode } = node;\n  const { getEmbeddingLevels } = bidiFactory();\n  if (nodeDir === 'ltr' || nodeDir === 'rtl') {\n    return nodeDir;\n  } else if (nodeDir === 'auto') {\n    let text;\n    switch (localName) {\n      case 'input': {\n        const valueKeys = [...KEY_INPUT_BUTTON, ...KEY_INPUT_TEXT, 'hidden'];\n        if (!node.type || valueKeys.includes(node.type)) {\n          text = node.value;\n        } else {\n          const ltrKeys = [\n            'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio',\n            'time'\n          ];\n          if (ltrKeys.includes(node.type)) {\n            return 'ltr';\n          }\n        }\n        break;\n      }\n      case 'slot': {\n        text = getSlottedTextContent(node);\n        break;\n      }\n      case 'textarea': {\n        text = node.value;\n        break;\n      }\n      default: {\n        const items = [].slice.call(node.childNodes);\n        for (const item of items) {\n          const {\n            dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n            textContent: itemTextContent\n          } = item;\n          if (itemNodeType === TEXT_NODE) {\n            text = itemTextContent.trim();\n          } else if (itemNodeType === ELEMENT_NODE) {\n            const keys = ['bdi', 'script', 'style', 'textarea'];\n            if (!keys.includes(itemLocalName) &&\n                (!itemDir || (itemDir !== 'ltr' && itemDir !== 'rtl'))) {\n              if (itemLocalName === 'slot') {\n                text = getSlottedTextContent(item);\n              } else {\n                text = itemTextContent.trim();\n              }\n            }\n          }\n          if (text) {\n            break;\n          }\n        }\n      }\n    }\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n      return 'ltr';\n    } else if (parentNode) {\n      const { nodeType: parentNodeType } = parentNode;\n      if (parentNodeType === ELEMENT_NODE) {\n        return getDirectionality(parentNode);\n      }\n      return 'ltr';\n    }\n    return 'ltr';\n  } else if (localName === 'bdi') {\n    const text = node.textContent.trim();\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n      return 'ltr';\n    }\n    return 'ltr';\n  } else if (localName === 'input' && node.type === 'tel') {\n    return 'ltr';\n  } else if (parentNode) {\n    if (localName === 'slot') {\n      const text = getSlottedTextContent(node);\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n    }\n    const { nodeType: parentNodeType } = parentNode;\n    if (parentNodeType === ELEMENT_NODE) {\n      return getDirectionality(parentNode);\n    }\n    return 'ltr';\n  }\n  return 'ltr';\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (typeof node.isContentEditable === 'boolean') {\n    return node.isContentEditable;\n  } else if (node.ownerDocument.designMode === 'on') {\n    return true;\n  } else if (node.hasAttribute('contenteditable')) {\n    const attr = node.getAttribute('contenteditable');\n    switch (attr) {\n      case '':\n      case 'true': {\n        return true;\n      }\n      case 'plaintext-only': {\n        // FIXME: the element's raw text is editable,\n        // but rich text formatting is disabled\n        return true;\n      }\n      case 'false': {\n        return false;\n      }\n      default: {\n        let parent = node.parentNode;\n        let bool = false;\n        while (parent) {\n          if (isContentEditable(parent)) {\n            bool = true;\n            break;\n          }\n          parent = parent.parentNode;\n        }\n        return bool;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  const { display, visibility } = window.getComputedStyle(node);\n  if (display !== 'none' && visibility === 'visible') {\n    return true;\n  }\n  return false;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, type } = node;\n  switch (localName) {\n    case 'input': {\n      if (!type || KEY_INPUT_EDIT.includes(type)) {\n        return true;\n      }\n      return false;\n    }\n    case 'textarea': {\n      return true;\n    }\n    default: {\n      return isContentEditable(node);\n    }\n  }\n};\n\n/**\n * is focusable area\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusableArea = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (!node.isConnected) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  if (node instanceof window.HTMLElement) {\n    if (Number.isInteger(parseInt(node.getAttribute('tabindex')))) {\n      return true;\n    }\n    if (isContentEditable(node)) {\n      return true;\n    }\n    const { localName, parentNode } = node;\n    switch (localName) {\n      case 'a': {\n        if (node.href || node.hasAttribute('href')) {\n          return true;\n        }\n        return false;\n      }\n      case 'iframe': {\n        return true;\n      }\n      case 'input': {\n        if (node.disabled || node.hasAttribute('disabled') ||\n            node.hidden || node.hasAttribute('hidden')) {\n          return false;\n        }\n        return true;\n      }\n      case 'summary': {\n        if (parentNode.localName === 'details') {\n          let child = parentNode.firstElementChild;\n          while (child) {\n            if (child.localName === 'summary') {\n              return node === child;\n            }\n            child = child.nextElementSibling;\n          }\n        }\n        return false;\n      }\n      default: {\n        const keys = ['button', 'select', 'textarea'];\n        if (keys.includes(localName) &&\n            !(node.disabled || node.hasAttribute('disabled'))) {\n          return true;\n        }\n        return false;\n      }\n    }\n  } else if (node instanceof window.SVGElement) {\n    if (Number.isInteger(parseInt(node.getAttributeNS(null, 'tabindex')))) {\n      const keys = [\n        'clipPath', 'defs', 'desc', 'linearGradient', 'marker', 'mask',\n        'metadata', 'pattern', 'radialGradient', 'script', 'style', 'symbol',\n        'title'\n      ];\n      const ns = 'http://www.w3.org/2000/svg';\n      let bool;\n      let refNode = node;\n      while (refNode.namespaceURI === ns) {\n        bool = keys.includes(refNode.localName);\n        if (bool) {\n          break;\n        }\n        if (refNode?.parentNode?.namespaceURI === ns) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n      if (bool) {\n        return false;\n      }\n      return true;\n    }\n    if (node.localName === 'a' &&\n        (node.href || node.hasAttributeNS(null, 'href'))) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n};\n\n/**\n * is focusable\n * NOTE: not applied, need fix in jsdom itself\n * @see https://github.com/whatwg/html/pull/8392\n * @see https://phabricator.services.mozilla.com/D156219\n * @see https://github.com/jsdom/jsdom/issues/3029\n * @see https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  let refNode = node;\n  let res = true;\n  while (refNode) {\n    if (refNode.disabled || refNode.hasAttribute('disabled')) {\n      res = false;\n      break;\n    }\n    if (refNode.hidden || refNode.hasAttribute('hidden')) {\n      res = false;\n    }\n    const {\n      contentVisibility, display, visibility\n    } = window.getComputedStyle(refNode);\n    if (display === 'none' || visibility !== 'visible' ||\n        (contentVisibility === 'hidden' && refNode !== node)) {\n      res = false;\n    } else {\n      res = true;\n    }\n    if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n      refNode = refNode.parentNode;\n    } else {\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!ns || node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { attributes } = node;\n  let res;\n  for (const attr of attributes) {\n    const { name, namespaceURI, prefix, value } = attr;\n    if (name === `xmlns:${ns}`) {\n      res = value;\n    } else if (prefix === ns) {\n      res = namespaceURI;\n    }\n    if (res) {\n      break;\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  if (!ns || typeof ns !== 'string' || node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (node.lookupNamespaceURI(ns)) {\n    return true;\n  }\n  const root = node.ownerDocument.documentElement;\n  let parent = node;\n  let res;\n  while (parent) {\n    res = getNamespaceURI(ns, parent);\n    if (res || parent === root) {\n      break;\n    }\n    parent = parent.parentNode;\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  if (nodeA.nodeType !== ELEMENT_NODE || nodeB.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const posBit = nodeB.compareDocumentPosition(nodeA);\n  const res = posBit & DOCUMENT_POSITION_PRECEDING ||\n              posBit & DOCUMENT_POSITION_CONTAINS;\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  // exclude missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // exclude namespaced selectors, escaped selectors, pseudo-element selectors,\n  // selectors containing non-ASCII or control character other than whitespace,\n  // attribute selectors with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // include pseudo-classes that are known to work correctly\n  if (selector.includes(':')) {\n    const { complex, descend } = opt;\n    if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        return !REG_LOGICAL_COMPLEX.test(selector);\n      } else {\n        return !REG_LOGICAL_COMPOUND.test(selector);\n      }\n    } else if (descend) {\n      return false;\n    } else {\n      return !REG_WO_LOGICAL.test(selector);\n    }\n  }\n  return true;\n};\n"],
  "mappings": "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",
  "names": ["utility_exports", "__export", "filterSelector", "getDirectionality", "getNamespaceURI", "getSlottedTextContent", "getType", "initNwsapi", "isContentEditable", "isCustomElement", "isFocusVisible", "isFocusable", "isFocusableArea", "isInShadowTree", "isNamespaceDeclared", "isPreceding", "isVisible", "resolveContent", "sortNodes", "traverseNode", "__toCommonJS", "import_nwsapi", "import_bidi_js", "import_is_potential_custom_element_name", "import_constant", "REG_LOGICAL_COMPLEX", "REG_LOGICAL_COMPOUND", "REG_WO_LOGICAL", "o", "node", "document", "root", "parent", "walker", "refNode", "bool", "opt", "localName", "ownerDocument", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "host", "mode", "nodeType", "parentNode", "nodes", "text", "item", "nodeDir", "getEmbeddingLevels", "bidiFactory", "valueKeys", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "display", "visibility", "type", "child", "keys", "ns", "res", "contentVisibility", "attributes", "name", "namespaceURI", "prefix", "value", "nodeA", "nodeB", "posBit", "arr", "a", "b", "nw", "nwsapi", "selector", "index", "complex", "descend"]
}
