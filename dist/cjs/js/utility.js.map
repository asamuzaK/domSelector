{
  "version": 3,
  "sources": ["../../../src/js/utility.js"],
  "sourcesContent": ["/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, HAS_COMPOUND, KEY_INPUT_BUTTON,\n  KEY_INPUT_EDIT, KEY_INPUT_TEXT, LOGIC_COMPLEX, LOGIC_COMPOUND, N_TH,\n  PSEUDO_CLASS, TARGET_LINEAL, TARGET_SELF, TEXT_NODE, TYPE_FROM, TYPE_TO\n} from './constant.js';\nconst REG_LOGIC_COMPLEX =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPLEX})`);\nconst REG_LOGIC_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPOUND})`);\nconst REG_LOGIC_HAS_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPOUND}|${HAS_COMPOUND})`);\nconst REG_WO_LOGICAL = new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH})`);\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * resolve content document, root node and tree walker, is in shadow\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object|boolean>}\n *   - array of document, root node , tree walker, node is in shadow\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  let shadow;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      const { host, mode, ownerDocument } = node;\n      document = ownerDocument;\n      root = node;\n      shadow = host && (mode === 'close' || mode === 'open');\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let refNode = node;\n      while (refNode) {\n        const { host, mode, nodeType, parentNode } = refNode;\n        if (nodeType === DOCUMENT_FRAGMENT_NODE) {\n          shadow = host && (mode === 'close' || mode === 'open');\n          break;\n        } else if (parentNode) {\n          refNode = parentNode;\n        } else {\n          break;\n        }\n      }\n      root = refNode;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  return [\n    document,\n    root,\n    !!shadow\n  ];\n};\n\n/**\n * traverse node tree\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @param {boolean} force - traverse only to next node\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker, force = false) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!walker) {\n    return null;\n  }\n  let refNode = walker.currentNode;\n  if (refNode === node) {\n    return refNode;\n  } else if (force || refNode.contains(node)) {\n    refNode = walker.nextNode();\n    while (refNode) {\n      if (refNode === node) {\n        break;\n      }\n      refNode = walker.nextNode();\n    }\n    return refNode;\n  } else {\n    if (refNode !== walker.root) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        } else if (refNode === walker.root || refNode.contains(node)) {\n          break;\n        }\n        refNode = walker.parentNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, ownerDocument } = node;\n  const { formAssociated } = opt;\n  const window = ownerDocument.defaultView;\n  let elmConstructor;\n  const attr = node.getAttribute('is');\n  if (attr) {\n    elmConstructor =\n      isCustomElementName(attr) && window.customElements.get(attr);\n  } else {\n    elmConstructor =\n      isCustomElementName(localName) && window.customElements.get(localName);\n  }\n  if (elmConstructor) {\n    if (formAssociated) {\n      return !!elmConstructor.formAssociated;\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (typeof node.assignedNodes !== 'function') {\n    return null;\n  }\n  const nodes = node.assignedNodes();\n  if (nodes.length) {\n    let text;\n    for (const item of nodes) {\n      text = item.textContent.trim();\n      if (text) {\n        break;\n      }\n    }\n    return text;\n  }\n  return node.textContent.trim();\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { dir: dirAttr, localName, parentNode } = node;\n  const { getEmbeddingLevels } = bidiFactory();\n  if (dirAttr === 'ltr' || dirAttr === 'rtl') {\n    return dirAttr;\n  } else if (dirAttr === 'auto') {\n    let text;\n    switch (localName) {\n      case 'input': {\n        const valueKeys = [...KEY_INPUT_BUTTON, ...KEY_INPUT_TEXT, 'hidden'];\n        if (!node.type || valueKeys.includes(node.type)) {\n          text = node.value;\n        } else {\n          const ltrKeys = [\n            'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio',\n            'time'\n          ];\n          if (ltrKeys.includes(node.type)) {\n            return 'ltr';\n          }\n        }\n        break;\n      }\n      case 'slot': {\n        text = getSlottedTextContent(node);\n        break;\n      }\n      case 'textarea': {\n        text = node.value;\n        break;\n      }\n      default: {\n        const items = [].slice.call(node.childNodes);\n        for (const item of items) {\n          const {\n            dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n            textContent: itemTextContent\n          } = item;\n          if (itemNodeType === TEXT_NODE) {\n            text = itemTextContent.trim();\n          } else if (itemNodeType === ELEMENT_NODE) {\n            const keys = ['bdi', 'script', 'style', 'textarea'];\n            if (!keys.includes(itemLocalName) &&\n                (!itemDir || (itemDir !== 'ltr' && itemDir !== 'rtl'))) {\n              if (itemLocalName === 'slot') {\n                text = getSlottedTextContent(item);\n              } else {\n                text = itemTextContent.trim();\n              }\n            }\n          }\n          if (text) {\n            break;\n          }\n        }\n      }\n    }\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    } else if (parentNode) {\n      const { nodeType: parentNodeType } = parentNode;\n      if (parentNodeType === ELEMENT_NODE) {\n        return getDirectionality(parentNode);\n      }\n    }\n  } else if (localName === 'input' && node.type === 'tel') {\n    return 'ltr';\n  } else if (localName === 'bdi') {\n    const text = node.textContent.trim();\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    }\n  } else if (parentNode) {\n    if (localName === 'slot') {\n      const text = getSlottedTextContent(node);\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n    }\n    const { nodeType: parentNodeType } = parentNode;\n    if (parentNodeType === ELEMENT_NODE) {\n      return getDirectionality(parentNode);\n    }\n  }\n  return 'ltr';\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (typeof node.isContentEditable === 'boolean') {\n    return node.isContentEditable;\n  } else if (node.ownerDocument.designMode === 'on') {\n    return true;\n  } else {\n    let attr;\n    if (node.hasAttribute('contenteditable')) {\n      attr = node.getAttribute('contenteditable');\n    } else {\n      attr = 'inherit';\n    }\n    switch (attr) {\n      case '':\n      case 'true': {\n        return true;\n      }\n      case 'plaintext-only': {\n        // FIXME:\n        // @see https://github.com/w3c/editing/issues/470\n        // @see https://github.com/whatwg/html/issues/10651\n        return true;\n      }\n      case 'false': {\n        return false;\n      }\n      default: {\n        if (node?.parentNode?.nodeType === ELEMENT_NODE) {\n          return isContentEditable(node.parentNode);\n        }\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  const { display, visibility } = window.getComputedStyle(node);\n  if (display !== 'none' && visibility === 'visible') {\n    return true;\n  }\n  return false;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, type } = node;\n  switch (localName) {\n    case 'input': {\n      if (!type || KEY_INPUT_EDIT.includes(type)) {\n        return true;\n      }\n      return false;\n    }\n    case 'textarea': {\n      return true;\n    }\n    default: {\n      return isContentEditable(node);\n    }\n  }\n};\n\n/**\n * is focusable area\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusableArea = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (!node.isConnected) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  if (node instanceof window.HTMLElement) {\n    if (Number.isInteger(parseInt(node.getAttribute('tabindex')))) {\n      return true;\n    }\n    if (isContentEditable(node)) {\n      return true;\n    }\n    const { localName, parentNode } = node;\n    switch (localName) {\n      case 'a': {\n        if (node.href || node.hasAttribute('href')) {\n          return true;\n        }\n        return false;\n      }\n      case 'iframe': {\n        return true;\n      }\n      case 'input': {\n        if (node.disabled || node.hasAttribute('disabled') ||\n            node.hidden || node.hasAttribute('hidden')) {\n          return false;\n        }\n        return true;\n      }\n      case 'summary': {\n        if (parentNode.localName === 'details') {\n          let child = parentNode.firstElementChild;\n          let bool = false;\n          while (child) {\n            if (child.localName === 'summary') {\n              bool = child === node;\n              break;\n            }\n            child = child.nextElementSibling;\n          }\n          return bool;\n        }\n        return false;\n      }\n      default: {\n        const keys = ['button', 'select', 'textarea'];\n        if (keys.includes(localName) &&\n            !(node.disabled || node.hasAttribute('disabled'))) {\n          return true;\n        }\n      }\n    }\n  } else if (node instanceof window.SVGElement) {\n    if (Number.isInteger(parseInt(node.getAttributeNS(null, 'tabindex')))) {\n      const keys = [\n        'clipPath', 'defs', 'desc', 'linearGradient', 'marker', 'mask',\n        'metadata', 'pattern', 'radialGradient', 'script', 'style', 'symbol',\n        'title'\n      ];\n      const ns = 'http://www.w3.org/2000/svg';\n      let bool;\n      let refNode = node;\n      while (refNode.namespaceURI === ns) {\n        bool = keys.includes(refNode.localName);\n        if (bool) {\n          break;\n        }\n        if (refNode?.parentNode?.namespaceURI === ns) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n      if (bool) {\n        return false;\n      }\n      return true;\n    }\n    if (node.localName === 'a' &&\n        (node.href || node.hasAttributeNS(null, 'href'))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * is focusable\n * NOTE: not applied, need fix in jsdom itself\n * @see https://github.com/whatwg/html/pull/8392\n * @see https://phabricator.services.mozilla.com/D156219\n * @see https://github.com/jsdom/jsdom/issues/3029\n * @see https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  let refNode = node;\n  let res = true;\n  while (refNode) {\n    if (refNode.disabled || refNode.hasAttribute('disabled')) {\n      res = false;\n      break;\n    }\n    if (refNode.hidden || refNode.hasAttribute('hidden')) {\n      res = false;\n    }\n    const {\n      contentVisibility, display, visibility\n    } = window.getComputedStyle(refNode);\n    if (display === 'none' || visibility !== 'visible' ||\n        (contentVisibility === 'hidden' && refNode !== node)) {\n      res = false;\n    } else {\n      res = true;\n    }\n    if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n      refNode = refNode.parentNode;\n    } else {\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!ns || node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { attributes } = node;\n  let res;\n  for (const attr of attributes) {\n    const { name, namespaceURI, prefix, value } = attr;\n    if (name === `xmlns:${ns}`) {\n      res = value;\n    } else if (prefix === ns) {\n      res = namespaceURI;\n    }\n    if (res) {\n      break;\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  if (!ns || typeof ns !== 'string' || node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (node.lookupNamespaceURI(ns)) {\n    return true;\n  }\n  const root = node.ownerDocument.documentElement;\n  let parent = node;\n  let res;\n  while (parent) {\n    res = getNamespaceURI(ns, parent);\n    if (res || parent === root) {\n      break;\n    }\n    parent = parent.parentNode;\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  if (nodeA.nodeType !== ELEMENT_NODE || nodeB.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const posBit = nodeB.compareDocumentPosition(nodeA);\n  const res = posBit & DOCUMENT_POSITION_PRECEDING ||\n              posBit & DOCUMENT_POSITION_CONTAINS;\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  const { complex, compound, descend, simple, target } = opt;\n  // exclude simple selector and compound selector\n  if (simple || compound) {\n    return false;\n  }\n  // exclude missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // exclude namespaced selectors, escaped selectors, pseudo-element selectors,\n  // selectors containing non-ASCII or control character other than whitespace,\n  // attribute selectors with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // include pseudo-classes that are known to work correctly\n  if (selector.includes(':')) {\n    if (descend) {\n      return false;\n    } else if ((target === TARGET_SELF || target === TARGET_LINEAL) &&\n               /:has\\(/.test(selector)) {\n      return !REG_LOGIC_HAS_COMPOUND.test(selector);\n    } else if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        return !REG_LOGIC_COMPLEX.test(selector);\n      } else {\n        return !REG_LOGIC_COMPOUND.test(selector);\n      }\n    } else {\n      return !REG_WO_LOGICAL.test(selector);\n    }\n  }\n  return true;\n};\n"],
  "mappings": "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",
  "names": ["utility_exports", "__export", "filterSelector", "getDirectionality", "getNamespaceURI", "getSlottedTextContent", "getType", "initNwsapi", "isContentEditable", "isCustomElement", "isFocusVisible", "isFocusable", "isFocusableArea", "isNamespaceDeclared", "isPreceding", "isVisible", "resolveContent", "sortNodes", "traverseNode", "__toCommonJS", "import_nwsapi", "import_bidi_js", "import_is_potential_custom_element_name", "import_constant", "REG_LOGIC_COMPLEX", "REG_LOGIC_COMPOUND", "REG_LOGIC_HAS_COMPOUND", "REG_WO_LOGICAL", "o", "node", "document", "root", "shadow", "host", "mode", "ownerDocument", "refNode", "nodeType", "parentNode", "walker", "force", "bool", "opt", "localName", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "nodes", "text", "item", "dirAttr", "getEmbeddingLevels", "bidiFactory", "valueKeys", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "display", "visibility", "type", "child", "keys", "ns", "res", "contentVisibility", "attributes", "name", "namespaceURI", "prefix", "value", "parent", "nodeA", "nodeB", "posBit", "arr", "a", "b", "nw", "nwsapi", "selector", "complex", "compound", "descend", "simple", "target", "index"]
}
