{
  "version": 3,
  "sources": ["../../../src/js/utility.js"],
  "sourcesContent": ["/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, KEY_INPUT_BUTTON, KEY_INPUT_EDIT,\n  KEY_INPUT_TEXT, LOGICAL_COMPLEX, LOGICAL_COMPOUND, N_TH, PSEUDO_CLASS,\n  TEXT_NODE, TYPE_FROM, TYPE_TO, WALKER_FILTER\n} from './constant.js';\nconst REG_LOGICAL_COMPLEX =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGICAL_COMPLEX})`);\nconst REG_LOGICAL_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGICAL_COMPOUND})`);\nconst REG_WO_LOGICAL = new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH})`);\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * resolve content document, root node and tree walker, is in shadow\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object|boolean>}\n *   - array of document, root node , tree walker, node is in shadow\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  let shadow;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      const { host, mode, ownerDocument } = node;\n      document = ownerDocument;\n      root = node;\n      shadow = host && (mode === 'close' || mode === 'open');\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let refNode = node;\n      while (refNode) {\n        const { host, mode, nodeType, parentNode } = refNode;\n        if (nodeType === DOCUMENT_FRAGMENT_NODE) {\n          shadow = host && (mode === 'close' || mode === 'open');\n          break;\n        } else if (parentNode) {\n          refNode = parentNode;\n        } else {\n          break;\n        }\n      }\n      root = refNode;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  const walker = document.createTreeWalker(root, WALKER_FILTER);\n  return [\n    document,\n    root,\n    walker,\n    !!shadow\n  ];\n};\n\n/**\n * traverse node tree\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!walker) {\n    return null;\n  }\n  let refNode = walker.currentNode;\n  if (refNode === node) {\n    return refNode;\n  } else if (refNode.contains(node)) {\n    refNode = walker.nextNode();\n    while (refNode) {\n      if (refNode === node) {\n        break;\n      }\n      refNode = walker.nextNode();\n    }\n    return refNode;\n  } else {\n    if (refNode !== walker.root) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        } else if (refNode === walker.root) {\n          break;\n        }\n        refNode = walker.parentNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, ownerDocument } = node;\n  const { formAssociated } = opt;\n  const window = ownerDocument.defaultView;\n  let elmConstructor;\n  const attr = node.getAttribute('is');\n  if (attr) {\n    elmConstructor =\n      isCustomElementName(attr) && window.customElements.get(attr);\n  } else {\n    elmConstructor =\n      isCustomElementName(localName) && window.customElements.get(localName);\n  }\n  if (elmConstructor) {\n    if (formAssociated) {\n      return !!elmConstructor.formAssociated;\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (typeof node.assignedNodes !== 'function') {\n    return null;\n  }\n  const nodes = node.assignedNodes();\n  if (nodes.length) {\n    let text;\n    for (const item of nodes) {\n      text = item.textContent.trim();\n      if (text) {\n        break;\n      }\n    }\n    return text;\n  }\n  return node.textContent.trim();\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { dir: dirAttr, localName, parentNode } = node;\n  const { getEmbeddingLevels } = bidiFactory();\n  if (dirAttr === 'ltr' || dirAttr === 'rtl') {\n    return dirAttr;\n  } else if (dirAttr === 'auto') {\n    let text;\n    switch (localName) {\n      case 'input': {\n        const valueKeys = [...KEY_INPUT_BUTTON, ...KEY_INPUT_TEXT, 'hidden'];\n        if (!node.type || valueKeys.includes(node.type)) {\n          text = node.value;\n        } else {\n          const ltrKeys = [\n            'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio',\n            'time'\n          ];\n          if (ltrKeys.includes(node.type)) {\n            return 'ltr';\n          }\n        }\n        break;\n      }\n      case 'slot': {\n        text = getSlottedTextContent(node);\n        break;\n      }\n      case 'textarea': {\n        text = node.value;\n        break;\n      }\n      default: {\n        const items = [].slice.call(node.childNodes);\n        for (const item of items) {\n          const {\n            dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n            textContent: itemTextContent\n          } = item;\n          if (itemNodeType === TEXT_NODE) {\n            text = itemTextContent.trim();\n          } else if (itemNodeType === ELEMENT_NODE) {\n            const keys = ['bdi', 'script', 'style', 'textarea'];\n            if (!keys.includes(itemLocalName) &&\n                (!itemDir || (itemDir !== 'ltr' && itemDir !== 'rtl'))) {\n              if (itemLocalName === 'slot') {\n                text = getSlottedTextContent(item);\n              } else {\n                text = itemTextContent.trim();\n              }\n            }\n          }\n          if (text) {\n            break;\n          }\n        }\n      }\n    }\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    } else if (parentNode) {\n      const { nodeType: parentNodeType } = parentNode;\n      if (parentNodeType === ELEMENT_NODE) {\n        return getDirectionality(parentNode);\n      }\n    }\n  } else if (localName === 'input' && node.type === 'tel') {\n    return 'ltr';\n  } else if (localName === 'bdi') {\n    const text = node.textContent.trim();\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    }\n  } else if (parentNode) {\n    if (localName === 'slot') {\n      const text = getSlottedTextContent(node);\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n    }\n    const { nodeType: parentNodeType } = parentNode;\n    if (parentNodeType === ELEMENT_NODE) {\n      return getDirectionality(parentNode);\n    }\n  }\n  return 'ltr';\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (typeof node.isContentEditable === 'boolean') {\n    return node.isContentEditable;\n  } else if (node.ownerDocument.designMode === 'on') {\n    return true;\n  } else if (node.hasAttribute('contenteditable')) {\n    const attr = node.getAttribute('contenteditable');\n    switch (attr) {\n      case '':\n      case 'true': {\n        return true;\n      }\n      case 'plaintext-only': {\n        // FIXME: the element's raw text is editable,\n        // but rich text formatting is disabled\n        return true;\n      }\n      case 'false': {\n        return false;\n      }\n      default: {\n        let parent = node.parentNode;\n        let bool = false;\n        while (parent) {\n          if (isContentEditable(parent)) {\n            bool = true;\n            break;\n          }\n          parent = parent.parentNode;\n        }\n        return bool;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  const { display, visibility } = window.getComputedStyle(node);\n  if (display !== 'none' && visibility === 'visible') {\n    return true;\n  }\n  return false;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, type } = node;\n  switch (localName) {\n    case 'input': {\n      if (!type || KEY_INPUT_EDIT.includes(type)) {\n        return true;\n      }\n      return false;\n    }\n    case 'textarea': {\n      return true;\n    }\n    default: {\n      return isContentEditable(node);\n    }\n  }\n};\n\n/**\n * is focusable area\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusableArea = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (!node.isConnected) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  if (node instanceof window.HTMLElement) {\n    if (Number.isInteger(parseInt(node.getAttribute('tabindex')))) {\n      return true;\n    }\n    if (isContentEditable(node)) {\n      return true;\n    }\n    const { localName, parentNode } = node;\n    switch (localName) {\n      case 'a': {\n        if (node.href || node.hasAttribute('href')) {\n          return true;\n        }\n        return false;\n      }\n      case 'iframe': {\n        return true;\n      }\n      case 'input': {\n        if (node.disabled || node.hasAttribute('disabled') ||\n            node.hidden || node.hasAttribute('hidden')) {\n          return false;\n        }\n        return true;\n      }\n      case 'summary': {\n        if (parentNode.localName === 'details') {\n          let child = parentNode.firstElementChild;\n          let bool = false;\n          while (child) {\n            if (child.localName === 'summary') {\n              bool = child === node;\n              break;\n            }\n            child = child.nextElementSibling;\n          }\n          return bool;\n        }\n        return false;\n      }\n      default: {\n        const keys = ['button', 'select', 'textarea'];\n        if (keys.includes(localName) &&\n            !(node.disabled || node.hasAttribute('disabled'))) {\n          return true;\n        }\n      }\n    }\n  } else if (node instanceof window.SVGElement) {\n    if (Number.isInteger(parseInt(node.getAttributeNS(null, 'tabindex')))) {\n      const keys = [\n        'clipPath', 'defs', 'desc', 'linearGradient', 'marker', 'mask',\n        'metadata', 'pattern', 'radialGradient', 'script', 'style', 'symbol',\n        'title'\n      ];\n      const ns = 'http://www.w3.org/2000/svg';\n      let bool;\n      let refNode = node;\n      while (refNode.namespaceURI === ns) {\n        bool = keys.includes(refNode.localName);\n        if (bool) {\n          break;\n        }\n        if (refNode?.parentNode?.namespaceURI === ns) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n      if (bool) {\n        return false;\n      }\n      return true;\n    }\n    if (node.localName === 'a' &&\n        (node.href || node.hasAttributeNS(null, 'href'))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * is focusable\n * NOTE: not applied, need fix in jsdom itself\n * @see https://github.com/whatwg/html/pull/8392\n * @see https://phabricator.services.mozilla.com/D156219\n * @see https://github.com/jsdom/jsdom/issues/3029\n * @see https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  let refNode = node;\n  let res = true;\n  while (refNode) {\n    if (refNode.disabled || refNode.hasAttribute('disabled')) {\n      res = false;\n      break;\n    }\n    if (refNode.hidden || refNode.hasAttribute('hidden')) {\n      res = false;\n    }\n    const {\n      contentVisibility, display, visibility\n    } = window.getComputedStyle(refNode);\n    if (display === 'none' || visibility !== 'visible' ||\n        (contentVisibility === 'hidden' && refNode !== node)) {\n      res = false;\n    } else {\n      res = true;\n    }\n    if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n      refNode = refNode.parentNode;\n    } else {\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!ns || node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { attributes } = node;\n  let res;\n  for (const attr of attributes) {\n    const { name, namespaceURI, prefix, value } = attr;\n    if (name === `xmlns:${ns}`) {\n      res = value;\n    } else if (prefix === ns) {\n      res = namespaceURI;\n    }\n    if (res) {\n      break;\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  if (!ns || typeof ns !== 'string' || node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (node.lookupNamespaceURI(ns)) {\n    return true;\n  }\n  const root = node.ownerDocument.documentElement;\n  let parent = node;\n  let res;\n  while (parent) {\n    res = getNamespaceURI(ns, parent);\n    if (res || parent === root) {\n      break;\n    }\n    parent = parent.parentNode;\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  if (nodeA.nodeType !== ELEMENT_NODE || nodeB.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const posBit = nodeB.compareDocumentPosition(nodeA);\n  const res = posBit & DOCUMENT_POSITION_PRECEDING ||\n              posBit & DOCUMENT_POSITION_CONTAINS;\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  // exclude missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // exclude namespaced selectors, escaped selectors, pseudo-element selectors,\n  // selectors containing non-ASCII or control character other than whitespace,\n  // attribute selectors with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // include pseudo-classes that are known to work correctly\n  if (selector.includes(':')) {\n    const { complex, descend } = opt;\n    if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        return !REG_LOGICAL_COMPLEX.test(selector);\n      } else {\n        return !REG_LOGICAL_COMPOUND.test(selector);\n      }\n    } else if (descend) {\n      return false;\n    } else {\n      return !REG_WO_LOGICAL.test(selector);\n    }\n  }\n  return true;\n};\n"],
  "mappings": "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",
  "names": ["utility_exports", "__export", "filterSelector", "getDirectionality", "getNamespaceURI", "getSlottedTextContent", "getType", "initNwsapi", "isContentEditable", "isCustomElement", "isFocusVisible", "isFocusable", "isFocusableArea", "isNamespaceDeclared", "isPreceding", "isVisible", "resolveContent", "sortNodes", "traverseNode", "__toCommonJS", "import_nwsapi", "import_bidi_js", "import_is_potential_custom_element_name", "import_constant", "REG_LOGICAL_COMPLEX", "REG_LOGICAL_COMPOUND", "REG_WO_LOGICAL", "o", "node", "document", "root", "shadow", "host", "mode", "ownerDocument", "refNode", "nodeType", "parentNode", "walker", "bool", "opt", "localName", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "nodes", "text", "item", "dirAttr", "getEmbeddingLevels", "bidiFactory", "valueKeys", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "parent", "display", "visibility", "type", "child", "keys", "ns", "res", "contentVisibility", "attributes", "name", "namespaceURI", "prefix", "value", "nodeA", "nodeB", "posBit", "arr", "a", "b", "nw", "nwsapi", "selector", "index", "complex", "descend"]
}
