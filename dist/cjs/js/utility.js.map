{
  "version": 3,
  "sources": ["../../../src/js/utility.js"],
  "sourcesContent": ["/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, REG_DIR, REG_FILTER_COMPLEX,\n  REG_FILTER_COMPOUND, REG_FILTER_SIMPLE, REG_SHADOW_MODE, REG_TYPE_INPUT,\n  TEXT_NODE, TYPE_FROM, TYPE_TO, WALKER_FILTER\n} from './constant.js';\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * resolve content document, root node and tree walker\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object>} - array of document, root node, tree walker\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      document = node.ownerDocument;\n      root = node;\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let parent = node;\n      while (parent) {\n        if (parent.parentNode) {\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      root = parent;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  const walker = document.createTreeWalker(root, WALKER_FILTER);\n  return [\n    document,\n    root,\n    walker\n  ];\n};\n\n/**\n * traverse node tree\n * @private\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let current;\n  if (walker?.currentNode) {\n    let refNode = walker.currentNode;\n    if (refNode === node) {\n      current = refNode;\n    } else if (refNode.contains(node)) {\n      refNode = walker.nextNode();\n      while (refNode) {\n        if (refNode === node) {\n          current = refNode;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n    } else {\n      if (refNode !== walker.root) {\n        while (refNode) {\n          if (refNode === walker.root || refNode === node) {\n            break;\n          }\n          refNode = walker.parentNode();\n        }\n      }\n      if (node.nodeType === ELEMENT_NODE) {\n        while (refNode) {\n          if (refNode === node) {\n            current = refNode;\n            break;\n          }\n          refNode = walker.nextNode();\n        }\n      } else {\n        current = refNode;\n      }\n    }\n  }\n  return current ?? null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let bool;\n  if (node.nodeType === ELEMENT_NODE) {\n    const { localName, ownerDocument } = node;\n    const { formAssociated } = opt;\n    const window = ownerDocument.defaultView;\n    let elmConstructor;\n    const attr = node.getAttribute('is');\n    if (attr) {\n      elmConstructor =\n        isCustomElementName(attr) && window.customElements.get(attr);\n    } else {\n      elmConstructor =\n        isCustomElementName(localName) && window.customElements.get(localName);\n    }\n    if (elmConstructor) {\n      if (formAssociated) {\n        bool = elmConstructor.formAssociated;\n      } else {\n        bool = true;\n      }\n    }\n  }\n  return !!bool;\n};\n\n/**\n * is in shadow tree\n * @param {object} node - node\n * @returns {boolean} - result;\n */\nexport const isInShadowTree = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let bool;\n  if (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    let refNode = node;\n    while (refNode) {\n      const { host, mode, nodeType, parentNode } = refNode;\n      if (host && mode && nodeType === DOCUMENT_FRAGMENT_NODE &&\n          REG_SHADOW_MODE.test(mode)) {\n        bool = true;\n        break;\n      }\n      refNode = parentNode;\n    }\n  }\n  return !!bool;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (node.localName === 'slot' && isInShadowTree(node)) {\n    const nodes = node.assignedNodes();\n    if (nodes.length) {\n      for (const item of nodes) {\n        res = item.textContent.trim();\n        if (res) {\n          break;\n        }\n      }\n    } else {\n      res = node.textContent.trim();\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (node.nodeType === ELEMENT_NODE) {\n    const { dir: nodeDir, localName, parentNode } = node;\n    const { getEmbeddingLevels } = bidiFactory();\n    if (REG_DIR.test(nodeDir)) {\n      res = nodeDir;\n    } else if (nodeDir === 'auto') {\n      let text;\n      switch (localName) {\n        case 'input': {\n          if (!node.type || /^(?:button|email|hidden|password|reset|search|submit|tel|text|url)$/.test(node.type)) {\n            text = node.value;\n          } else if (/^(?:checkbox|color|date|image|number|radio|range|time)$/.test(node.type)) {\n            res = 'ltr';\n          }\n          break;\n        }\n        case 'slot': {\n          text = getSlottedTextContent(node);\n          break;\n        }\n        case 'textarea': {\n          text = node.value;\n          break;\n        }\n        default: {\n          const items = [].slice.call(node.childNodes);\n          for (const item of items) {\n            const {\n              dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n              textContent: itemTextContent\n            } = item;\n            if (itemNodeType === TEXT_NODE) {\n              text = itemTextContent.trim();\n            } else if (itemNodeType === ELEMENT_NODE) {\n              if (!/^(?:bdi|script|style|textarea)$/.test(itemLocalName) &&\n                  (!itemDir || !REG_DIR.test(itemDir))) {\n                if (itemLocalName === 'slot') {\n                  text = getSlottedTextContent(item);\n                } else {\n                  text = itemTextContent.trim();\n                }\n              }\n            }\n            if (text) {\n              break;\n            }\n          }\n        }\n      }\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          res = 'rtl';\n        } else {\n          res = 'ltr';\n        }\n      }\n      if (!res) {\n        if (parentNode) {\n          const { nodeType: parentNodeType } = parentNode;\n          if (parentNodeType === ELEMENT_NODE) {\n            res = getDirectionality(parentNode);\n          } else if (parentNodeType === DOCUMENT_NODE ||\n                     parentNodeType === DOCUMENT_FRAGMENT_NODE) {\n            res = 'ltr';\n          }\n        } else {\n          res = 'ltr';\n        }\n      }\n    } else if (localName === 'bdi') {\n      const text = node.textContent.trim();\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          res = 'rtl';\n        } else {\n          res = 'ltr';\n        }\n      }\n      if (!(res || parentNode)) {\n        res = 'ltr';\n      }\n    } else if (localName === 'input' && node.type === 'tel') {\n      res = 'ltr';\n    } else if (parentNode) {\n      if (localName === 'slot') {\n        const text = getSlottedTextContent(node);\n        if (text) {\n          const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n          if (level % 2 === 1) {\n            res = 'rtl';\n          } else {\n            res = 'ltr';\n          }\n        }\n      }\n      if (!res) {\n        const { nodeType: parentNodeType } = parentNode;\n        if (parentNodeType === ELEMENT_NODE) {\n          res = getDirectionality(parentNode);\n        } else if (parentNodeType === DOCUMENT_NODE ||\n                   parentNodeType === DOCUMENT_FRAGMENT_NODE) {\n          res = 'ltr';\n        }\n      }\n    } else {\n      res = 'ltr';\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (node.nodeType === ELEMENT_NODE) {\n    if (typeof node.isContentEditable === 'boolean') {\n      res = node.isContentEditable;\n    } else if (node.ownerDocument.designMode === 'on') {\n      res = true;\n    } else if (node.hasAttribute('contenteditable')) {\n      const attr = node.getAttribute('contenteditable');\n      if (attr === '' || /^(?:plaintext-only|true)$/.test(attr)) {\n        res = true;\n      } else if (attr === 'inherit') {\n        let parent = node.parentNode;\n        while (parent) {\n          if (isContentEditable(parent)) {\n            res = true;\n            break;\n          }\n          parent = parent.parentNode;\n        }\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  let res;\n  if (node?.nodeType === ELEMENT_NODE) {\n    const window = node.ownerDocument.defaultView;\n    const { display, visibility } = window.getComputedStyle(node);\n    if (display !== 'none' && visibility === 'visible') {\n      res = true;\n    }\n  }\n  return !!res;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  let res;\n  if (node?.nodeType === ELEMENT_NODE) {\n    const { localName, type } = node;\n    switch (localName) {\n      case 'input': {\n        if (!type || REG_TYPE_INPUT.test(type)) {\n          res = true;\n        }\n        break;\n      }\n      case 'textarea': {\n        res = true;\n        break;\n      }\n      default: {\n        res = isContentEditable(node);\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is focusable\n * NOTE: workaround for jsdom issue: https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  let res;\n  if (node?.nodeType === ELEMENT_NODE) {\n    const window = node.ownerDocument.defaultView;\n    let refNode = node;\n    res = true;\n    while (refNode) {\n      if (refNode.disabled || refNode.hasAttribute('disabled')) {\n        return false;\n      }\n      if (refNode.hidden || refNode.hasAttribute('hidden')) {\n        res = false;\n      }\n      const {\n        contentVisibility, display, visibility\n      } = window.getComputedStyle(refNode);\n      if (display === 'none' || visibility !== 'visible' ||\n          (contentVisibility === 'hidden' && refNode !== node)) {\n        res = false;\n      } else {\n        res = true;\n      }\n      if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n        refNode = refNode.parentNode;\n      } else {\n        break;\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let res;\n  if (ns && node.nodeType === ELEMENT_NODE) {\n    const { attributes } = node;\n    for (const attr of attributes) {\n      const { name, namespaceURI, prefix, value } = attr;\n      if (name === `xmlns:${ns}`) {\n        res = value;\n        break;\n      } else if (prefix === ns) {\n        res = namespaceURI;\n        break;\n      }\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  let res;\n  if (ns && typeof ns === 'string' && node.nodeType === ELEMENT_NODE) {\n    res = node.lookupNamespaceURI(ns);\n    if (!res) {\n      const root = node.ownerDocument.documentElement;\n      let parent = node;\n      while (parent) {\n        res = getNamespaceURI(ns, parent);\n        if (res || parent === root) {\n          break;\n        }\n        parent = parent.parentNode;\n      }\n    }\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  let res;\n  if (nodeA.nodeType === ELEMENT_NODE && nodeB.nodeType === ELEMENT_NODE) {\n    const posBit = nodeB.compareDocumentPosition(nodeA);\n    res = posBit & DOCUMENT_POSITION_PRECEDING ||\n          posBit & DOCUMENT_POSITION_CONTAINS;\n  }\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  // filter missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // filter namespace selector, escaped selector, pseudo-element selector,\n  // selector containing non-ASCII or control character other than whitespace,\n  // attribute selector with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // filter pseudo-classes\n  if (selector.includes(':')) {\n    const { complex, descend } = opt;\n    let reg;\n    if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        reg = REG_FILTER_COMPLEX;\n      } else {\n        reg = REG_FILTER_COMPOUND;\n      }\n    } else {\n      if (descend) {\n        return false;\n      }\n      reg = REG_FILTER_SIMPLE;\n    }\n    if (reg.test(selector)) {\n      return false;\n    }\n  }\n  return true;\n};\n"],
  "mappings": "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",
  "names": ["utility_exports", "__export", "filterSelector", "getDirectionality", "getNamespaceURI", "getSlottedTextContent", "getType", "initNwsapi", "isContentEditable", "isCustomElement", "isFocusVisible", "isFocusable", "isInShadowTree", "isNamespaceDeclared", "isPreceding", "isVisible", "resolveContent", "sortNodes", "traverseNode", "__toCommonJS", "import_nwsapi", "import_bidi_js", "import_is_potential_custom_element_name", "import_constant", "o", "node", "document", "root", "parent", "walker", "current", "refNode", "opt", "bool", "localName", "ownerDocument", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "host", "mode", "nodeType", "parentNode", "res", "nodes", "item", "nodeDir", "getEmbeddingLevels", "bidiFactory", "text", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "display", "visibility", "type", "contentVisibility", "ns", "attributes", "name", "namespaceURI", "prefix", "value", "nodeA", "nodeB", "posBit", "arr", "a", "b", "nw", "nwsapi", "selector", "index", "complex", "descend", "reg"]
}
