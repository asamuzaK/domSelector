{
  "version": 3,
  "sources": ["../../node_modules/source-map-js/lib/base64.js", "../../node_modules/source-map-js/lib/base64-vlq.js", "../../node_modules/source-map-js/lib/util.js", "../../node_modules/source-map-js/lib/array-set.js", "../../node_modules/source-map-js/lib/mapping-list.js", "../../node_modules/source-map-js/lib/source-map-generator.js", "../../node_modules/@asamuzakjp/nwsapi/src/nwsapi.js", "../../node_modules/bidi-js/dist/bidi.js", "../../node_modules/is-potential-custom-element-name/index.js", "../../src/index.js", "../../node_modules/css-tree/lib/tokenizer/char-code-definitions.js", "../../node_modules/css-tree/lib/tokenizer/utils.js", "../../node_modules/css-tree/lib/tokenizer/names.js", "../../node_modules/css-tree/lib/tokenizer/adopt-buffer.js", "../../node_modules/css-tree/lib/tokenizer/OffsetToLocation.js", "../../node_modules/css-tree/lib/tokenizer/TokenStream.js", "../../node_modules/css-tree/lib/tokenizer/index.js", "../../node_modules/css-tree/lib/utils/List.js", "../../node_modules/css-tree/lib/utils/create-custom-error.js", "../../node_modules/css-tree/lib/parser/SyntaxError.js", "../../node_modules/css-tree/lib/parser/sequence.js", "../../node_modules/css-tree/lib/parser/create.js", "../../node_modules/css-tree/lib/generator/sourceMap.js", "../../node_modules/css-tree/lib/generator/token-before.js", "../../node_modules/css-tree/lib/generator/create.js", "../../node_modules/css-tree/lib/convertor/create.js", "../../node_modules/css-tree/lib/walker/create.js", "../../node_modules/css-tree/lib/definition-syntax/generate.js", "../../node_modules/css-tree/lib/lexer/error.js", "../../node_modules/css-tree/lib/utils/names.js", "../../node_modules/css-tree/lib/lexer/generic-const.js", "../../node_modules/css-tree/lib/lexer/generic-an-plus-b.js", "../../node_modules/css-tree/lib/lexer/generic-urange.js", "../../node_modules/css-tree/lib/lexer/generic.js", "../../node_modules/css-tree/lib/lexer/units.js", "../../node_modules/css-tree/lib/definition-syntax/SyntaxError.js", "../../node_modules/css-tree/lib/definition-syntax/scanner.js", "../../node_modules/css-tree/lib/definition-syntax/parse.js", "../../node_modules/css-tree/lib/definition-syntax/walk.js", "../../node_modules/css-tree/lib/lexer/prepare-tokens.js", "../../node_modules/css-tree/lib/lexer/match-graph.js", "../../node_modules/css-tree/lib/lexer/match.js", "../../node_modules/css-tree/lib/lexer/trace.js", "../../node_modules/css-tree/lib/lexer/search.js", "../../node_modules/css-tree/lib/lexer/structure.js", "../../node_modules/css-tree/lib/lexer/Lexer.js", "../../node_modules/css-tree/lib/syntax/config/mix.js", "../../node_modules/css-tree/lib/syntax/create.js", "../../node_modules/css-tree/lib/data.js", "../../node_modules/css-tree/lib/data-patch.js", "../../node_modules/css-tree/lib/syntax/node/index.js", "../../node_modules/css-tree/lib/syntax/node/AnPlusB.js", "../../node_modules/css-tree/lib/syntax/node/Atrule.js", "../../node_modules/css-tree/lib/syntax/node/AtrulePrelude.js", "../../node_modules/css-tree/lib/syntax/node/AttributeSelector.js", "../../node_modules/css-tree/lib/syntax/node/Block.js", "../../node_modules/css-tree/lib/syntax/node/Brackets.js", "../../node_modules/css-tree/lib/syntax/node/CDC.js", "../../node_modules/css-tree/lib/syntax/node/CDO.js", "../../node_modules/css-tree/lib/syntax/node/ClassSelector.js", "../../node_modules/css-tree/lib/syntax/node/Combinator.js", "../../node_modules/css-tree/lib/syntax/node/Comment.js", "../../node_modules/css-tree/lib/syntax/node/Condition.js", "../../node_modules/css-tree/lib/syntax/node/Declaration.js", "../../node_modules/css-tree/lib/syntax/node/DeclarationList.js", "../../node_modules/css-tree/lib/syntax/node/Dimension.js", "../../node_modules/css-tree/lib/syntax/node/Feature.js", "../../node_modules/css-tree/lib/syntax/node/FeatureFunction.js", "../../node_modules/css-tree/lib/syntax/node/FeatureRange.js", "../../node_modules/css-tree/lib/syntax/node/Function.js", "../../node_modules/css-tree/lib/syntax/node/GeneralEnclosed.js", "../../node_modules/css-tree/lib/syntax/node/Hash.js", "../../node_modules/css-tree/lib/syntax/node/Identifier.js", "../../node_modules/css-tree/lib/syntax/node/IdSelector.js", "../../node_modules/css-tree/lib/syntax/node/Layer.js", "../../node_modules/css-tree/lib/syntax/node/LayerList.js", "../../node_modules/css-tree/lib/syntax/node/MediaQuery.js", "../../node_modules/css-tree/lib/syntax/node/MediaQueryList.js", "../../node_modules/css-tree/lib/syntax/node/NestingSelector.js", "../../node_modules/css-tree/lib/syntax/node/Nth.js", "../../node_modules/css-tree/lib/syntax/node/Number.js", "../../node_modules/css-tree/lib/syntax/node/Operator.js", "../../node_modules/css-tree/lib/syntax/node/Parentheses.js", "../../node_modules/css-tree/lib/syntax/node/Percentage.js", "../../node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js", "../../node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js", "../../node_modules/css-tree/lib/syntax/node/Ratio.js", "../../node_modules/css-tree/lib/syntax/node/Raw.js", "../../node_modules/css-tree/lib/syntax/node/Rule.js", "../../node_modules/css-tree/lib/syntax/node/Scope.js", "../../node_modules/css-tree/lib/syntax/node/Selector.js", "../../node_modules/css-tree/lib/syntax/node/SelectorList.js", "../../node_modules/css-tree/lib/syntax/node/String.js", "../../node_modules/css-tree/lib/utils/string.js", "../../node_modules/css-tree/lib/syntax/node/StyleSheet.js", "../../node_modules/css-tree/lib/syntax/node/SupportsDeclaration.js", "../../node_modules/css-tree/lib/syntax/node/TypeSelector.js", "../../node_modules/css-tree/lib/syntax/node/UnicodeRange.js", "../../node_modules/css-tree/lib/syntax/node/Url.js", "../../node_modules/css-tree/lib/utils/url.js", "../../node_modules/css-tree/lib/syntax/node/Value.js", "../../node_modules/css-tree/lib/syntax/node/WhiteSpace.js", "../../node_modules/css-tree/lib/syntax/config/lexer.js", "../../node_modules/css-tree/lib/syntax/scope/index.js", "../../node_modules/css-tree/lib/syntax/scope/default.js", "../../node_modules/css-tree/lib/syntax/scope/atrulePrelude.js", "../../node_modules/css-tree/lib/syntax/scope/selector.js", "../../node_modules/css-tree/lib/syntax/function/expression.js", "../../node_modules/css-tree/lib/syntax/function/var.js", "../../node_modules/css-tree/lib/syntax/scope/value.js", "../../node_modules/css-tree/lib/syntax/atrule/container.js", "../../node_modules/css-tree/lib/syntax/atrule/font-face.js", "../../node_modules/css-tree/lib/syntax/atrule/import.js", "../../node_modules/css-tree/lib/syntax/atrule/layer.js", "../../node_modules/css-tree/lib/syntax/atrule/media.js", "../../node_modules/css-tree/lib/syntax/atrule/nest.js", "../../node_modules/css-tree/lib/syntax/atrule/page.js", "../../node_modules/css-tree/lib/syntax/atrule/scope.js", "../../node_modules/css-tree/lib/syntax/atrule/starting-style.js", "../../node_modules/css-tree/lib/syntax/atrule/supports.js", "../../node_modules/css-tree/lib/syntax/atrule/index.js", "../../node_modules/css-tree/lib/syntax/pseudo/lang.js", "../../node_modules/css-tree/lib/syntax/pseudo/index.js", "../../node_modules/css-tree/lib/syntax/node/index-parse.js", "../../node_modules/css-tree/lib/syntax/config/parser.js", "../../node_modules/css-tree/lib/syntax/config/walker.js", "../../node_modules/css-tree/lib/syntax/index.js", "../../node_modules/css-tree/lib/version.js", "../../node_modules/css-tree/lib/index.js", "../../src/js/utility.js", "../../src/js/constant.js", "../../src/js/parser.js", "../../src/js/matcher.js", "../../src/js/finder.js"],
  "sourcesContent": ["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n\n  return function(input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    var result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    }));\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      if (this._validateMapping(generated, original, source, name) === false) {\n        return;\n      }\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n      var message = 'original.line and original.column are not numbers -- you probably meant to omit ' +\n      'the original mapping entirely and only map the generated position. If so, pass ' +\n      'null for the original mapping instead of an object with empty or null values.'\n\n      if (this._ignoreInvalidMapping) {\n        if (typeof console !== 'undefined' && console.warn) {\n          console.warn(message);\n        }\n        return false;\n      } else {\n        throw new Error(message);\n      }\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      var message = 'Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      });\n\n      if (this._ignoreInvalidMapping) {\n        if (typeof console !== 'undefined' && console.warn) {\n          console.warn(message);\n        }\n        return false;\n      } else {\n        throw new Error(message)\n      }\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/**\n * Forked and modified from nwsapi@2.2.2\n * - Export to cjs only\n * - Remove ./modules directory\n * - Remove unused exported properties\n * - Remove unused pseudo-classes\n * - Use `let` and `const` as much as possible\n * - Use `===` and `!==`\n * - Fix `:nth-of-type()`\n * - Fix function source for :root, :target and :indeterminate pseudo-classes\n * - Fix <ident-token>\n * - Support complex selectors within `:is()` and `:not()`\n * - Add ::slotted() to pseudo-elements list\n * - Add isContentEditable() function\n * - Add createMatchingParensRegex() function from upstream\n * - Optimize some regular expressions\n */\n/*\n * Copyright (C) 2007-2019 Diego Perini\n * All rights reserved.\n *\n * nwsapi.js - Fast CSS Selectors API Engine\n *\n * Author: Diego Perini <diego.perini at gmail com>\n * Version: 2.2.0\n * Created: 20070722\n * Release: 20220901\n *\n * License:\n *  http://javascript.nwbox.com/nwsapi/MIT-LICENSE\n * Download:\n *  http://javascript.nwbox.com/nwsapi/nwsapi.js\n */\n\n(function Export(global, factory) {\n  'use strict';\n  module.exports = factory;\n})(this, function Factory(global, Export) {\n  const version = 'nwsapi-2.2.2';\n\n  let doc = global.document;\n  let root = doc.documentElement;\n  const slice = Array.prototype.slice;\n\n  /**\n   * Generate a regex that matches a balanced set of parentheses.\n   * Outermost parentheses are excluded so any amount of children can be handled.\n   * See https://stackoverflow.com/a/35271017 for reference\n   *\n   * @param {number} depth\n   * @return {string}\n   */\n  function createMatchingParensRegex(depth) {\n    const out = '\\\\([^)(]*?(?:'.repeat(depth) + '\\\\([^)(]*?\\\\)' + '[^)(]*?)*?\\\\)'.repeat(depth);\n    // remove outermost escaped parens\n    return out.slice(2, out.length - 2);\n  }\n\n  const CFG = {\n    // extensions\n    operators: '[~*^$|]=|=',\n    combinators: '[\\\\s>+~](?=[^>+~])'\n  };\n\n  const NOT = {\n    // not enclosed in double/single/parens/square\n    doubleEnc: '(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)',\n    singleEnc: \"(?=(?:[^']*'[^']*')*[^']*$)\",\n    parensEnc: '(?![^\\\\x28]*\\\\x29)',\n    squareEnc: '(?![^\\\\x5b]*\\\\x5d)'\n  };\n\n  const REX = {\n    // regular expressions\n    hasEscapes: /\\\\/,\n    hexNumbers: /^[0-9a-f]/i,\n    escOrQuote: /^\\\\|[\\x22\\x27]/,\n    regExpChar: /(?:(?!\\\\)[\\\\^$.*+?()[\\]{}|/])/g,\n    trimSpaces: /[\\r\\n\\f]|^\\s+|\\s+$/g,\n    commaGroup: RegExp('(\\\\s{0,255},\\\\s{0,255})' + NOT.squareEnc + NOT.parensEnc, 'g'),\n    splitGroup: /((?:\\x28[^\\x29]{0,255}\\x29|\\[[^\\]]{0,255}\\]|\\\\.|[^,])+)/g,\n    fixEscapes: /\\\\([0-9a-f]{1,6}\\s?|.)|([\\x22\\x27])/gi,\n    combineWSP: RegExp('\\\\s{1,255}' + NOT.singleEnc + NOT.doubleEnc, 'g'),\n    tabCharWSP: RegExp('(\\\\s?\\\\t{1,255}\\\\s?)' + NOT.singleEnc + NOT.doubleEnc, 'g'),\n    pseudosWSP: RegExp('\\\\s{1,255}([-+])\\\\s{1,255}' + NOT.squareEnc, 'g')\n  };\n\n  const STD = {\n    combinator: /\\s?([>+~])\\s?/g,\n    apimethods: /^(?:[a-z]+|\\*)\\|/i,\n    namespaces: /(\\*|[a-z]+)\\|[-a-z]+/i\n  };\n\n  const GROUPS = {\n    // pseudo-classes requiring parameters\n    logicalsel: '(is|where|matches|not|has)(?:\\\\x28\\\\s?(' + createMatchingParensRegex(3) + ')\\\\s?\\\\x29)',\n    treestruct: '(nth(?:-last)?(?:-child|-of-type))(?:\\\\x28\\\\s?(even|odd|(?:[-+]?\\\\d*)(?:n\\\\s?[-+]?\\\\s?\\\\d*)?)\\\\s?(?:\\\\x29|$))',\n    // pseudo-classes not requiring parameters\n    locationpc: '(any-link|link|visited|target)\\\\b',\n    structural: '(root|empty|(?:(?:first|last|only)(?:-child|-of-type)))\\\\b',\n    inputstate: '(enabled|disabled|read-(?:only|write)|placeholder-shown|default)\\\\b',\n    inputvalue: '(checked|indeterminate)\\\\b',\n    // pseudo-classes for parsing only selectors\n    pseudoNop: '(autofill|-webkit-autofill)\\\\b',\n    // pseudo-elements starting with single colon (:)\n    pseudoSng: '(after|before|first-letter|first-line)\\\\b',\n    // pseudo-elements starting with double colon (::)\n    pseudoDbl: ':(after|before|first-letter|first-line|selection|placeholder|slotted|-webkit-[-a-z0-9]{2,})\\\\b'\n  };\n\n  const Patterns = {\n    // pseudo-classes\n    treestruct: RegExp('^:(?:' + GROUPS.treestruct + ')(.*)', 'i'),\n    structural: RegExp('^:(?:' + GROUPS.structural + ')(.*)', 'i'),\n    inputstate: RegExp('^:(?:' + GROUPS.inputstate + ')(.*)', 'i'),\n    inputvalue: RegExp('^:(?:' + GROUPS.inputvalue + ')(.*)', 'i'),\n    locationpc: RegExp('^:(?:' + GROUPS.locationpc + ')(.*)', 'i'),\n    logicalsel: RegExp('^:(?:' + GROUPS.logicalsel + ')(.*)', 'i'),\n    pseudoNop: RegExp('^:(?:' + GROUPS.pseudoNop + ')(.*)', 'i'),\n    pseudoSng: RegExp('^:(?:' + GROUPS.pseudoSng + ')(.*)', 'i'),\n    pseudoDbl: RegExp('^:(?:' + GROUPS.pseudoDbl + ')(.*)', 'i'),\n    // combinator symbols\n    children: /^\\s?>\\s?(.*)/,\n    adjacent: /^\\s?\\+\\s?(.*)/,\n    relative: /^\\s?~\\s?(.*)/,\n    ancestor: /^\\s+(.*)/,\n    // universal & namespace\n    universal: /^\\*(.*)/,\n    namespace: /^(\\w+|\\*)?\\|(.*)/\n  };\n\n  // emulate firefox error strings\n  const qsNotArgs = 'Not enough arguments';\n  const qsInvalid = ' is not a valid selector';\n\n  // detect structural pseudo-classes in selectors\n  const reNthElem = /(:nth(?:-last)?-child)/i;\n  const reNthType = /(:nth(?:-last)?-of-type)/i;\n\n  // placeholder for global regexp\n  let reOptimizer;\n  let reValidator;\n\n  // special handling configuration flags\n  const Config = {\n    IDS_DUPES: true,\n    MIXEDCASE: true,\n    LOGERRORS: true,\n    VERBOSITY: true\n  };\n\n  let NAMESPACE;\n  let QUIRKS_MODE;\n  let HTML_DOCUMENT;\n\n  const ATTR_STD_OPS = {\n    '=': 1,\n    '^=': 1,\n    '$=': 1,\n    '|=': 1,\n    '*=': 1,\n    '~=': 1\n  };\n\n  const HTML_TABLE = {\n    accept: 1,\n    'accept-charset': 1,\n    align: 1,\n    alink: 1,\n    axis: 1,\n    bgcolor: 1,\n    charset: 1,\n    checked: 1,\n    clear: 1,\n    codetype: 1,\n    color: 1,\n    compact: 1,\n    declare: 1,\n    defer: 1,\n    dir: 1,\n    direction: 1,\n    disabled: 1,\n    enctype: 1,\n    face: 1,\n    frame: 1,\n    hreflang: 1,\n    'http-equiv': 1,\n    lang: 1,\n    language: 1,\n    link: 1,\n    media: 1,\n    method: 1,\n    multiple: 1,\n    nohref: 1,\n    noresize: 1,\n    noshade: 1,\n    nowrap: 1,\n    readonly: 1,\n    rel: 1,\n    rev: 1,\n    rules: 1,\n    scope: 1,\n    scrolling: 1,\n    selected: 1,\n    shape: 1,\n    target: 1,\n    text: 1,\n    type: 1,\n    valign: 1,\n    valuetype: 1,\n    vlink: 1\n  };\n\n  const Combinators = {};\n\n  const Selectors = {};\n\n  const Operators = {\n    '=': {\n      p1: '^',\n      p2: '$',\n      p3: 'true'\n    },\n    '^=': {\n      p1: '^',\n      p2: '',\n      p3: 'true'\n    },\n    '$=': {\n      p1: '',\n      p2: '$',\n      p3: 'true'\n    },\n    '*=': {\n      p1: '',\n      p2: '',\n      p3: 'true'\n    },\n    '|=': {\n      p1: '^',\n      p2: '(-|$)',\n      p3: 'true'\n    },\n    '~=': {\n      p1: '(^|\\\\s)',\n      p2: '(\\\\s|$)',\n      p3: 'true'\n    }\n  };\n\n  const concatCall = function (nodes, callback) {\n    let i = 0;\n    const l = nodes.length;\n    const list = Array(l);\n    while (l > i) {\n      if (callback(list[i] = nodes[i]) === false) {\n        break;\n      }\n      ++i;\n    }\n    return list;\n  };\n\n  const concatList = function (list, nodes) {\n    let i = -1;\n    let l = nodes.length;\n    while (l--) {\n      list[list.length] = nodes[++i];\n    }\n    return list;\n  };\n\n  let hasDupes = false;\n\n  const documentOrder = function (a, b) {\n    if (!hasDupes && a === b) {\n      hasDupes = true;\n      return 0;\n    }\n    return a.compareDocumentPosition(b) & 4 ? -1 : 1;\n  };\n\n  const unique = function (nodes) {\n    let i = 0;\n    let j = -1;\n    let l = nodes.length + 1;\n    const list = [];\n    while (--l) {\n      if (nodes[i++] === nodes[i]) {\n        continue;\n      }\n      list[++j] = nodes[i - 1];\n    }\n    hasDupes = false;\n    return list;\n  };\n\n  // check context for mixed content\n  const hasMixedCaseTagNames = function (context) {\n    const api = 'getElementsByTagNameNS';\n\n    // current host context (ownerDocument)\n    context = context.ownerDocument || context;\n\n    // documentElement (root) element namespace or default html/xhtml namespace\n    const ns = context.documentElement.namespaceURI || 'http://www.w3.org/1999/xhtml';\n\n    // checking the number of non HTML nodes in the document\n    return (context[api]('*', '*').length - context[api](ns, '*').length) > 0;\n  };\n\n  // check if the document type is HTML\n  const isHTML = function (node) {\n    const doc = node.ownerDocument || node;\n    return doc.nodeType === 9 && doc.contentType === 'text/html';\n  };\n\n  // convert single codepoint to UTF-16 encoding\n  const codePointToUTF16 = function (codePoint) {\n    // out of range, use replacement character\n    if (codePoint < 1 || codePoint > 0x10ffff ||\n        (codePoint > 0xd7ff && codePoint < 0xe000)) {\n      return '\\\\ufffd';\n    }\n    // javascript strings are UTF-16 encoded\n    if (codePoint < 0x10000) {\n      const lowHex = '000' + codePoint.toString(16);\n      return '\\\\u' + lowHex.substr(lowHex.length - 4);\n    }\n    // supplementary high + low surrogates\n    return '\\\\u' + (((codePoint - 0x10000) >> 0x0a) + 0xd800).toString(16) +\n           '\\\\u' + (((codePoint - 0x10000) % 0x400) + 0xdc00).toString(16);\n  };\n\n  // convert single codepoint to string\n  const stringFromCodePoint = function (codePoint) {\n    // out of range, use replacement character\n    if (codePoint < 1 || codePoint > 0x10ffff ||\n        (codePoint > 0xd7ff && codePoint < 0xe000)) {\n      return '\\ufffd';\n    }\n    if (codePoint < 0x10000) {\n      return String.fromCharCode(codePoint);\n    }\n    return String.fromCodePoint(codePoint);\n  };\n\n  // convert escape sequence in a CSS string or identifier\n  // to javascript string with javascript escape sequences\n  const convertEscapes = function (str) {\n    return REX.hasEscapes.test(str)\n      ? str.replace(REX.fixEscapes, function (substring, p1, p2) {\n        // unescaped \" or '\n        return p2\n          ? '\\\\' + p2\n          // javascript strings are UTF-16 encoded\n          : REX.hexNumbers.test(p1)\n            ? codePointToUTF16(parseInt(p1, 16))\n            // \\' \\\"\n            : REX.escOrQuote.test(p1)\n              ? substring\n              // \\g \\h \\. \\# etc\n              : p1;\n      })\n      : str;\n  };\n\n  // convert escape sequence in a CSS string or identifier\n  // to javascript string with characters representations\n  const unescapeIdentifier = function (str) {\n    return REX.hasEscapes.test(str)\n      ? str.replace(REX.fixEscapes, function (substring, p1, p2) {\n        // unescaped \" or '\n        return p2 || (REX.hexNumbers.test(p1)\n          ? stringFromCodePoint(parseInt(p1, 16))\n          // \\' \\\"\n          : REX.escOrQuote.test(p1)\n            ? substring\n            // \\g \\h \\. \\# etc\n            : p1);\n      })\n      : str;\n  };\n\n  // empty set\n  const none = [];\n\n  // cached lambdas\n  const matchLambdas = {};\n  const selectLambdas = {};\n\n  // cached resolvers\n  let matchResolvers = {};\n  let selectResolvers = {};\n\n  const method = {\n    '#': 'getElementById',\n    '*': 'getElementsByTagName',\n    '|': 'getElementsByTagNameNS',\n    '.': 'getElementsByClassName'\n  };\n\n  // find duplicate ids using iterative walk\n  const byIdRaw = function (id, context) {\n    let node = context;\n    const nodes = [];\n    let next = node.firstElementChild;\n    while ((node = next)) {\n      node.id === id && nodes.push(node);\n      if ((next = node.firstElementChild || node.nextElementSibling)) {\n        continue;\n      }\n      while (!next && (node = node.parentElement) && node !== context) {\n        next = node.nextElementSibling;\n      }\n    }\n    return nodes;\n  };\n\n  // context agnostic getElementById\n  const byId = function (id, context) {\n    let e;\n    const api = method['#'];\n\n    // duplicates id allowed\n    if (Config.IDS_DUPES === false) {\n      if (api in context) {\n        e = context[api](id);\n        return e ? [e] : none;\n      }\n    } else if ('all' in context) {\n      if ((e = context.all[id])) {\n        if (e.nodeType === 1) {\n          return e.getAttribute('id') !== id ? [] : [e];\n        } else if (id === 'length') {\n          e = context[api](id);\n          return e ? [e] : none;\n        }\n        const nodes = [];\n        for (let i = 0, l = e.length; l > i; ++i) {\n          if (e[i].id === id) {\n            nodes.push(e[i]);\n          }\n        }\n        return nodes.length ? nodes : none;\n      } else {\n        return none;\n      }\n    }\n\n    return byIdRaw(id, context);\n  };\n\n  // context agnostic getElementsByTagName\n  const byTag = function (tag, context) {\n    let e;\n    let nodes;\n    const api = method['*'];\n\n    // DOCUMENT_NODE (9) & ELEMENT_NODE (1)\n    if (api in context) {\n      return slice.call(context[api](tag));\n    } else {\n      tag = tag.toLowerCase();\n      // DOCUMENT_FRAGMENT_NODE (11)\n      if ((e = context.firstElementChild)) {\n        if (!(e.nextElementSibling || tag === '*' || e.localName === tag)) {\n          return slice.call(e[api](tag));\n        } else {\n          nodes = [];\n          do {\n            if (tag === '*' || e.localName === tag) {\n              nodes.push(e);\n            }\n            concatList(nodes, e[api](tag));\n          } while ((e = e.nextElementSibling));\n        }\n      } else {\n        nodes = none;\n      }\n    }\n    return nodes;\n  };\n\n  // context agnostic getElementsByClassName\n  const byClass = function (cls, context) {\n    let e;\n    let nodes;\n    const api = method['.'];\n    let reCls;\n    // DOCUMENT_NODE (9) & ELEMENT_NODE (1)\n    if (api in context) {\n      return slice.call(context[api](cls));\n    } else {\n      // DOCUMENT_FRAGMENT_NODE (11)\n      if ((e = context.firstElementChild)) {\n        reCls = RegExp('(^|\\\\s)' + cls + '(\\\\s|$)', QUIRKS_MODE ? 'i' : '');\n        if (!(e.nextElementSibling || reCls.test(e.className))) {\n          return slice.call(e[api](cls));\n        } else {\n          nodes = [];\n          do {\n            if (reCls.test(e.className)) {\n              nodes.push(e);\n            }\n            concatList(nodes, e[api](cls));\n          } while ((e = e.nextElementSibling));\n        }\n      } else nodes = none;\n    }\n    return nodes;\n  };\n\n  const compat = {\n    '#': function (c, n) {\n      REX.hasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byId(n, c);\n      };\n    },\n    '*': function (c, n) {\n      REX.hasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byTag(n, c);\n      };\n    },\n    '|': function (c, n) {\n      REX.hasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byTag(n, c);\n      };\n    },\n    '.': function (c, n) {\n      REX.hasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byClass(n, c);\n      };\n    }\n  };\n\n  // namespace aware hasAttribute\n  // helper for XML/XHTML documents\n  const hasAttributeNS = function (e, name) {\n    let i;\n    let l;\n    const attr = e.getAttributeNames();\n    name = RegExp(':?' + name + '$', HTML_DOCUMENT ? 'i' : '');\n    for (i = 0, l = attr.length; l > i; ++i) {\n      if (name.test(attr[i])) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // fast resolver for the :nth-child() and :nth-last-child() pseudo-classes\n  const nthElement = (function () {\n    let idx = 0;\n    let len = 0;\n    let set = 0;\n    let parent;\n    let parents = [];\n    let nodes = [];\n    return function (element, dir) {\n      // ensure caches are emptied after each run, invoking with dir = 2\n      if (dir === 2) {\n        idx = 0; len = 0; set = 0; nodes = []; parents = []; parent = undefined;\n        return -1;\n      }\n      let e, i, j, k, l;\n      if (parent === element.parentElement) {\n        i = set; j = idx; l = len;\n      } else {\n        l = parents.length;\n        parent = element.parentElement;\n        for (i = -1, j = 0, k = l - 1; l > j; ++j, --k) {\n          if (parents[j] === parent) {\n            i = j;\n            break;\n          }\n          if (parents[k] === parent) {\n            i = k;\n            break;\n          }\n        }\n        if (i < 0) {\n          parents[i = l] = parent;\n          l = 0; nodes[i] = [];\n          e = (parent && parent.firstElementChild) || element;\n          while (e) {\n            nodes[i][l] = e;\n            if (e === element) {\n              j = l;\n            }\n            e = e.nextElementSibling;\n            ++l;\n          }\n          set = i; idx = 0; len = l;\n          if (l < 2) {\n            return l;\n          }\n        } else {\n          l = nodes[i].length;\n          set = i;\n        }\n      }\n      if (element !== nodes[i][j] && element !== nodes[i][j = 0]) {\n        for (j = 0, e = nodes[i], k = l - 1; l > j; ++j, --k) {\n          if (e[j] === element) {\n            break;\n          }\n          if (e[k] === element) {\n            j = k;\n            break;\n          }\n        }\n      }\n      idx = j + 1; len = l;\n      return dir ? l - j : idx;\n    };\n  })();\n\n  // fast resolver for the :nth-of-type() and :nth-last-of-type() pseudo-classes\n  const nthOfType = (function () {\n    let idx = 0;\n    let len = 0;\n    let set = 0;\n    let parent;\n    let parents = [];\n    let nodes = [];\n    return function (element, dir) {\n      // ensure caches are emptied after each run, invoking with dir = 2\n      if (dir === 2) {\n        idx = 0; len = 0; set = 0; nodes = []; parents = []; parent = undefined;\n        return -1;\n      }\n      const name = element.localName;\n      const nsURI = element.namespaceURI;\n      if (nsURI !== 'http://www.w3.org/1999/xhtml') {\n        idx = 0; len = 0; set = 0; nodes = []; parents = []; parent = undefined;\n      }\n      let e;\n      let i;\n      let j;\n      let k;\n      let l;\n      if (nodes[set] && nodes[set][name] && parent === element.parentElement) {\n        i = set;\n        j = idx;\n        l = len;\n      } else {\n        l = parents.length;\n        parent = element.parentElement;\n        for (i = -1, j = 0, k = l - 1; l > j; ++j, --k) {\n          if (parents[j] === parent) {\n            i = j;\n            break;\n          }\n          if (parents[k] === parent) {\n            i = k;\n            break;\n          }\n        }\n        if (i < 0 || !nodes[i][name]) {\n          parents[i = l] = parent;\n          nodes[i] || (nodes[i] = Object());\n          l = 0; nodes[i][name] = [];\n          e = (parent && parent.firstElementChild) || element;\n          while (e) {\n            if (e === element) {\n              j = l;\n            }\n            if (e.localName === name && e.namespaceURI === nsURI) {\n              nodes[i][name][l] = e;\n              ++l;\n            }\n            e = e.nextElementSibling;\n          }\n          set = i; idx = j; len = l;\n          if (l < 2) {\n            return l;\n          }\n        } else {\n          l = nodes[i][name].length;\n          set = i;\n        }\n      }\n      if (element !== nodes[i][name][j] && element !== nodes[i][name][j = 0]) {\n        for (j = 0, e = nodes[i][name], k = l - 1; l > j; ++j, --k) {\n          if (e[j] === element) {\n            break;\n          }\n          if (e[k] === element) {\n            j = k;\n            break;\n          }\n        }\n      }\n      idx = j + 1; len = l;\n      return dir ? l - j : idx;\n    };\n  })();\n\n  // check if the node is the target\n  const isTarget = function (node) {\n    const doc = node.ownerDocument || node;\n    const { hash } = new URL(doc.URL);\n    if (node.id && hash === `#${node.id}` && doc.contains(node)) {\n      return true;\n    }\n    return false;\n  };\n\n  // check if node is inderminate\n  const isIndeterminate = function (node) {\n    if ((node.indeterminate && node.localName === 'input' &&\n         node.type === 'checkbox') ||\n        (node.localName === 'progress' && !node.hasAttribute('value'))) {\n      return true;\n    }\n    if (node.localName === 'input' && node.type === 'radio' &&\n        !node.hasAttribute('checked')) {\n      const nodeName = node.name;\n      let parent = node.parentNode;\n      while (parent) {\n        if (parent.localName === 'form') {\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      if (!parent) {\n        const doc = node.ownerDocument;\n        parent = doc.documentElement;\n      }\n      const items = parent.getElementsByTagName('input');\n      const l = items.length;\n      let checked;\n      for (let i = 0; i < l; i++) {\n        const item = items[i];\n        if (item.getAttribute('type') === 'radio') {\n          if (nodeName) {\n            if (item.getAttribute('name') === nodeName) {\n              checked = !!item.checked;\n            }\n          } else if (!item.hasAttribute('name')) {\n            checked = !!item.checked;\n          }\n          if (checked) {\n            break;\n          }\n        }\n      }\n      if (!checked) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // check if node content is editable\n  const isContentEditable = function (node) {\n    let attrValue = 'inherit';\n    if (node.hasAttribute('contenteditable')) {\n      attrValue = node.getAttribute('contenteditable');\n    }\n    switch (attrValue) {\n      case '':\n      case 'plaintext-only':\n      case 'true':\n        return true;\n      case 'false':\n        return false;\n      default:\n        if (node.parentNode && node.parentNode.nodeType === 1) {\n          return isContentEditable(node.parentNode);\n        }\n        return false;\n    }\n  };\n\n  // build validation regexps used by the engine\n  const setIdentifierSyntax = function () {\n    //\n    // NOTE: SPECIAL CASES IN CSS SYNTAX PARSING RULES\n    //\n    // The <EOF-token> https://drafts.csswg.org/css-syntax/#typedef-eof-token\n    // allow mangled|unclosed selector syntax at the end of selectors strings\n    //\n    // Literal equivalent hex representations of the characters: \" ' ` ] )\n    //\n    //     \\\\x22 = \" - double quotes    \\\\x5b = [ - open square bracket\n    //     \\\\x27 = ' - single quote     \\\\x5d = ] - closed square bracket\n    //     \\\\x60 = ` - back tick        \\\\x28 = ( - open round parens\n    //     \\\\x5c = \\ - back slash       \\\\x29 = ) - closed round parens\n    //\n    // using hex format prevents false matches of opened/closed instances\n    // pairs, coloring breakage and other editors highlightning problems.\n    //\n\n    // @see https://drafts.csswg.org/css-syntax-3/#ident-token-diagram\n    const nonascii = '[^\\\\x00-\\\\x9f]';\n    const esctoken = '\\\\\\\\(?:[^\\\\r\\\\n\\\\f\\\\da-f]|[\\\\da-f]{1,6}\\\\s{0,255})';\n    const identifier =\n      '(?:--|-?(?:[a-z_]|' + nonascii + '|' + esctoken + '))' +\n      '(?:[\\\\w-]|' + nonascii + '|' + esctoken + ')*';\n\n    const pseudonames = '[-\\\\w]+';\n    const pseudoparms = '(?:[-+]?\\\\d*)(?:n\\\\s?[-+]?\\\\s?\\\\d*)';\n    const doublequote = '\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(?:\"|$)';\n    const singlequote = \"'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*(?:'|$)\";\n\n    const attrparser = identifier + '|' + doublequote + '|' + singlequote;\n\n    const attrvalues = '([\\\\x22\\\\x27]?)((?!\\\\3)*|(?:\\\\\\\\?.)*?)(?:\\\\3|$)';\n\n    const attributes =\n      '\\\\[' +\n        // attribute presence\n        '(?:\\\\*\\\\|)?\\\\s?(' + identifier + '(?::' + identifier + ')?)\\\\s?' +\n        '(?:(' + CFG.operators + ')\\\\s?(?:' + attrparser + '))?' +\n        // attribute case sensitivity\n        '(?:\\\\s?\\\\b(i))?\\\\s?' +\n      '(?:\\\\]|$)';\n\n    const attrmatcher = attributes.replace(attrparser, attrvalues);\n\n    const pseudoclass =\n      '(?:\\\\x28\\\\s*' +\n        '(?:' + pseudoparms + '?)?|' +\n        // universal * &\n        // namespace *|*\n        '[*|]|' +\n        '(?:' +\n          '(?::' + pseudonames + '(?:\\\\x28' + pseudoparms + '?(?:\\\\x29|$))?)|' +\n          '(?:[.#]?' + identifier + ')|' +\n          '(?:' + attributes + ')' +\n        ')+|' +\n        '\\\\s?[>+~]\\\\s?|' +\n        '\\\\s?,\\\\s?|' +\n        '\\\\s|' +\n        '\\\\x29|$' +\n      ')*';\n\n    const standardValidator =\n      '(?=\\\\s?[^>+~(){}<])' +\n      '(?:' +\n        // universal * &\n        // namespace *|*\n        '\\\\*|\\\\||' +\n        '(?:[.#]?' + identifier + ')+|' +\n        '(?:' + attributes + ')+|' +\n        '(?:::?' + pseudonames + pseudoclass + ')|' +\n        '(?:\\\\s?' + CFG.combinators + '\\\\s?)|' +\n        '\\\\s?,\\\\s?|' +\n        '\\\\s?' +\n      ')+';\n\n    // the following global RE is used to return the\n    // deepest localName in selector strings and then\n    // use it to retrieve all possible matching nodes\n    // that will be filtered by compiled resolvers\n    reOptimizer = RegExp(\n      '(?:([.:#*]?)(' + identifier + ')' +\n        '(?::[-\\\\w]+|\\\\[[^\\\\]]+(?:\\\\]|$)|\\\\x28[^\\\\x29]+(?:\\\\x29|$))*' +\n      ')$', 'i');\n\n    // global\n    reValidator = RegExp(standardValidator, 'gi');\n\n    Patterns.id = RegExp('^#(' + identifier + ')(.*)', 'i');\n    Patterns.tagName = RegExp('^(' + identifier + ')(.*)', 'i');\n    Patterns.className = RegExp('^\\\\.(' + identifier + ')(.*)', 'i');\n    Patterns.attribute = RegExp('^(?:' + attrmatcher + ')(.*)');\n  };\n\n  // configure the engine to use special handling\n  const configure = function (option, clear) {\n    if (typeof option === 'string') {\n      return !!Config[option];\n    }\n    if (typeof option !== 'object') {\n      return Config;\n    }\n    for (const i in option) {\n      Config[i] = !!option[i];\n    }\n    // clear lambda cache\n    if (clear) {\n      matchResolvers = {};\n      selectResolvers = {};\n    }\n    setIdentifierSyntax();\n    return true;\n  };\n\n  // centralized error and exceptions handling\n  const emit = function (message, proto) {\n    let err;\n    if (Config.VERBOSITY) {\n      if (global[proto]) {\n        err = new global[proto](message);\n      } else {\n        err = new global.DOMException(message, 'SyntaxError');\n      }\n      throw err;\n    }\n    if (Config.LOGERRORS && console && console.log) {\n      console.log(message);\n    }\n  };\n\n  // passed to resolvers\n  const Snapshot = {\n    doc: null,\n    from: null,\n    root: null,\n    byTag: null,\n    first: null,\n    match: null,\n    ancestor: null,\n    nthOfType: null,\n    nthElement: null,\n    hasAttributeNS: null,\n    isTarget: null,\n    isIndeterminate: null,\n    isContentEditable: null\n  };\n\n  // context\n  let lastContext;\n\n  const switchContext = function (context, force) {\n    const oldDoc = doc;\n    doc = context.ownerDocument || context;\n    if (force || oldDoc !== doc) {\n      // force a new check for each document change\n      // performed before the next select operation\n      root = doc.documentElement;\n      HTML_DOCUMENT = isHTML(doc);\n      QUIRKS_MODE = HTML_DOCUMENT && doc.compatMode.indexOf('CSS') < 0;\n      NAMESPACE = root && root.namespaceURI;\n      Snapshot.doc = doc;\n      Snapshot.root = root;\n    }\n    Snapshot.from = context;\n    return context;\n  };\n\n  // selector\n  let lastMatched;\n  let lastSelected;\n\n  const F_INIT = '\"use strict\";return function Resolver(c,f,x,r)';\n\n  const S_HEAD = 'var e,n,o,j=r.length-1,k=-1';\n  const M_HEAD = 'var e,n,o';\n\n  const S_LOOP = 'main:while((e=c[++k]))';\n  const N_LOOP = 'main:while((e=c.item(++k)))';\n  const M_LOOP = 'e=c;';\n\n  const S_BODY = 'r[++j]=c[k];';\n  const N_BODY = 'r[++j]=c.item(k);';\n  const M_BODY = '';\n\n  const S_TAIL = 'continue main;';\n  const M_TAIL = 'r=true;';\n\n  const S_TEST = 'if(f(c[k])){break main;}';\n  const N_TEST = 'if(f(c.item(k))){break main;}';\n  const M_TEST = 'f(c);';\n\n  let S_VARS = [];\n  let M_VARS = [];\n\n  // build conditional code to check components of selector strings\n  const compileSelector = function (expression, source, mode, callback) {\n    // N is the negation pseudo-class flag\n    // D is the default inverted negation flag\n    let a;\n    let b;\n    let n;\n    let f;\n    let name;\n    let NS;\n    const N = '';\n    const D = '!';\n    let compat;\n    let expr;\n    let match;\n    let result;\n    let status;\n    let symbol;\n    let test;\n    let type;\n    let selector = expression;\n    let vars;\n\n    // original 'select' or 'match' selector string before normalization\n    const selectorString = mode ? lastSelected : lastMatched;\n\n    // isolate selector combinators/components and normalize whitespace\n    selector = selector.replace(STD.combinator, '$1'); // .replace(STD.whitespace, ' ');\n\n    let selectorRecursion = true;\n    while (selector) {\n      // get namespace prefix if present or get first char of selector\n      symbol = STD.apimethods.test(selector) ? '|' : selector[0];\n\n      switch (symbol) {\n        // universal resolver\n        case '*':\n          match = selector.match(Patterns.universal);\n          if (N === '!') {\n            source = 'if(' + N + 'true' + '){' + source + '}';\n          }\n          break;\n        // id resolver\n        case '#':\n          match = selector.match(Patterns.id);\n          source = 'if(' + N + '(/^' + match[1] + '$/.test(e.getAttribute(\"id\"))' +\n            ')){' + source + '}';\n          break;\n        // class name resolver\n        case '.':\n          match = selector.match(Patterns.className);\n          compat = (QUIRKS_MODE ? 'i' : '') + '.test(e.getAttribute(\"class\"))';\n          source = 'if(' + N + '(/(^|\\\\s)' + match[1] + '(\\\\s|$)/' + compat +\n            ')){' + source + '}';\n          break;\n        // tag name resolver\n        case (/[_a-z]/i.test(symbol) ? symbol : undefined):\n          match = selector.match(Patterns.tagName);\n          source = 'if(' + N + '(e.localName' +\n            (Config.MIXEDCASE || hasMixedCaseTagNames(doc)\n              ? '==\"' + match[1].toLowerCase() + '\"'\n              : '==\"' + match[1].toUpperCase() + '\"') +\n            ')){' + source + '}';\n          break;\n        // namespace resolver\n        case '|':\n          match = selector.match(Patterns.namespace);\n          if (match[1] === '*') {\n            source = 'if(' + N + 'true){' + source + '}';\n          } else if (!match[1]) {\n            source = 'if(' + N + '(!e.namespaceURI)){' + source + '}';\n          } else if (typeof match[1] === 'string' && root.prefix === match[1]) {\n            source = 'if(' + N + '(e.namespaceURI==\"' + NAMESPACE + '\")){' + source + '}';\n          } else {\n            emit('\\'' + selectorString + '\\'' + qsInvalid);\n          }\n          break;\n        // attributes resolver\n        case '[':\n          match = selector.match(Patterns.attribute);\n          NS = match[0].match(STD.namespaces);\n          name = match[1];\n          expr = name.split(':');\n          expr = expr.length === 2 ? expr[1] : expr[0];\n          if (match[2] && !(test = Operators[match[2]])) {\n            emit('\\'' + selectorString + '\\'' + qsInvalid);\n            return '';\n          }\n          if (match[4] === '') {\n            test = match[2] === '~='\n              ? { p1: '^\\\\s', p2: '+$', p3: 'true' }\n              : match[2] in ATTR_STD_OPS && match[2] !== '~='\n                ? { p1: '^', p2: '$', p3: 'true' }\n                : test;\n          } else if (match[2] === '~=' && match[4].includes(' ')) {\n            // whitespace separated list but value contains space\n            source = 'if(' + N + 'false){' + source + '}';\n            break;\n          } else if (match[4]) {\n            match[4] = convertEscapes(match[4]).replace(REX.regExpChar, '\\\\$&');\n          }\n          type = match[5] === 'i' || (HTML_DOCUMENT && HTML_TABLE[expr.toLowerCase()])\n            ? 'i'\n            : '';\n          source =\n            'if(' + N + '(' +\n              (!match[2]\n                ? (NS ? 's.hasAttributeNS(e,\"' + name + '\")' : 'e.hasAttribute&&e.hasAttribute(\"' + name + '\")')\n                : !match[4] && ATTR_STD_OPS[match[2]] && match[2] !== '~='\n                  ? 'e.getAttribute&&e.getAttribute(\"' + name + '\")==\"\"'\n                  : '(/' + test.p1 + match[4] + test.p2 + '/' + type + ').test(e.getAttribute&&e.getAttribute(\"' + name + '\"))==' + test.p3) +\n            ')){' + source + '}';\n          break;\n        // *** General sibling combinator\n        // E ~ F (F relative sibling of E)\n        case '~':\n          match = selector.match(Patterns.relative);\n          source = 'n=e;while((e=e.previousElementSibling)){' + source + '}e=n;';\n          break;\n        // *** Adjacent sibling combinator\n        // E + F (F adiacent sibling of E)\n        case '+':\n          match = selector.match(Patterns.adjacent);\n          source = 'n=e;if((e=e.previousElementSibling)){' + source + '}e=n;';\n          break;\n        // *** Descendant combinator\n        // E F (E ancestor of F)\n        case '\\x09':\n        case '\\x20':\n          match = selector.match(Patterns.ancestor);\n          source = 'n=e;while((e=e.parentElement)){' + source + '}e=n;';\n          break;\n        // *** Child combinator\n        // E > F (F children of E)\n        case '>':\n          match = selector.match(Patterns.children);\n          source = 'n=e;if((e=e.parentElement)){' + source + '}e=n;';\n          break;\n        // *** user supplied combinators extensions\n        case (symbol in Combinators ? symbol : undefined):\n          // for other registered combinators extensions\n          match[match.length - 1] = '*';\n          source = Combinators[symbol](match) + source;\n          break;\n        // *** tree-structural pseudo-classes\n        // :root, :empty, :first-child, :last-child, :only-child, :first-of-type, :last-of-type, :only-of-type\n        case ':':\n          if ((match = selector.match(Patterns.structural))) {\n            match[1] = match[1].toLowerCase();\n            switch (match[1]) {\n              case 'root':\n                // there can only be one :root element, so exit the loop once found\n                source = 'if(' + N + '(e===s.doc.documentElement)){' + source + (mode ? 'break main;' : '') + '}';\n                break;\n              case 'empty':\n                // matches elements that don't contain elements or text nodes\n                source = 'n=e.firstChild;while(n&&!(/1|3/).test(n.nodeType)){n=n.nextSibling}if(' + D + 'n){' + source + '}';\n                break;\n              // *** child-indexed pseudo-classes\n              // :first-child, :last-child, :only-child\n              case 'only-child':\n                source = 'if(' + N + '(!e.nextElementSibling&&!e.previousElementSibling)){' + source + '}';\n                break;\n              case 'last-child':\n                source = 'if(' + N + '(!e.nextElementSibling)){' + source + '}';\n                break;\n              case 'first-child':\n                source = 'if(' + N + '(!e.previousElementSibling)){' + source + '}';\n                break;\n              // *** typed child-indexed pseudo-classes\n              // :only-of-type, :last-of-type, :first-of-type\n              case 'only-of-type':\n                source = 'o=e.localName;' +\n                  'n=e;while((n=n.nextElementSibling)&&n.localName!=o);if(!n){' +\n                  'n=e;while((n=n.previousElementSibling)&&n.localName!=o);}if(' + D + 'n){' + source + '}';\n                break;\n              case 'last-of-type':\n                source = 'n=e;o=e.localName;while((n=n.nextElementSibling)&&n.localName!=o);if(' + D + 'n){' + source + '}';\n                break;\n              case 'first-of-type':\n                source = 'n=e;o=e.localName;while((n=n.previousElementSibling)&&n.localName!=o);if(' + D + 'n){' + source + '}';\n                break;\n              default:\n                emit('\\'' + selectorString + '\\'' + qsInvalid);\n            }\n          // *** child-indexed & typed child-indexed pseudo-classes\n          // :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type\n          } else if ((match = selector.match(Patterns.treestruct))) {\n            match[1] = match[1].toLowerCase();\n            switch (match[1]) {\n              case 'nth-child':\n              case 'nth-of-type':\n              case 'nth-last-child':\n              case 'nth-last-of-type':\n                expr = /-of-type/i.test(match[1]);\n                if (match[1] && match[2]) {\n                  type = /last/i.test(match[1]);\n                  if (match[2] === 'n') {\n                    source = 'if(' + N + 'true){' + source + '}';\n                    break;\n                  } else if (match[2] === '1') {\n                    test = type ? 'next' : 'previous';\n                    source = expr\n                      ? 'n=e;o=e.localName;' +\n                          'while((n=n.' + test + 'ElementSibling)&&n.localName!=o);if(' + D + 'n){' + source + '}'\n                      : 'if(' + N + '!e.' + test + 'ElementSibling){' + source + '}';\n                    break;\n                  } else if (match[2] === 'even' || match[2] === '2n0' || match[2] === '2n+0' || match[2] === '2n') {\n                    test = 'n%2==0';\n                  } else if (match[2] === 'odd' || match[2] === '2n1' || match[2] === '2n+1') {\n                    test = 'n%2==1';\n                  } else {\n                    f = /n/i.test(match[2]);\n                    n = match[2].split('n');\n                    a = parseInt(n[0], 10) || 0;\n                    b = parseInt(n[1], 10) || 0;\n                    if (n[0] === '-') {\n                      a = -1;\n                    }\n                    if (n[0] === '+') {\n                      a = +1;\n                    }\n                    test = (b ? '(n' + (b > 0 ? '-' : '+') + Math.abs(b) + ')' : 'n') + '%' + a + '==0';\n                    test = a >= +1\n                      ? (f\n                          ? 'n>' + (b - 1) + (Math.abs(a) !== 1\n                            ? '&&' + test\n                            : '')\n                          : 'n==' + a)\n                      : a <= -1\n                        ? (f\n                            ? 'n<' + (b + 1) + (Math.abs(a) !== 1\n                              ? '&&' + test\n                              : '')\n                            : 'n==' + a)\n                        : a === 0\n                          ? (n[0]\n                              ? 'n==' + b\n                              : 'n>' + (b - 1))\n                          : 'false';\n                  }\n                  expr = expr ? 'OfType' : 'Element';\n                  type = type ? 'true' : 'false';\n                  source = 'n=s.nth' + expr + '(e,' + type + ');if(' + N + '(' + test + ')){' + source + '}';\n                } else {\n                  emit('\\'' + selectorString + '\\'' + qsInvalid);\n                }\n                break;\n              default:\n                emit('\\'' + selectorString + '\\'' + qsInvalid);\n            }\n          // *** logical combination pseudo-classes\n          // :is( s1, [ s2, ... ]), :not( s1, [ s2, ... ])\n          } else if ((match = selector.match(Patterns.logicalsel))) {\n            match[1] = match[1].toLowerCase();\n            expr = match[2].replace(REX.CommaGroup, ',').replace(REX.TrimSpaces, '');\n            switch (match[1]) {\n              // FIXME:\n              case 'is':\n              case 'where':\n              case 'matches':\n                source = 'if(s.match(\"' + expr.replace(/\\x22/g, '\\\\\"') + '\",e)){' + source + '}';\n                break;\n              // FIXME:\n              case 'not':\n                source = 'if(!s.match(\"' + expr.replace(/\\x22/g, '\\\\\"') + '\",e)){' + source + '}';\n                break;\n              // FIXME:\n              case 'has':\n                // clear cache\n                matchResolvers = {};\n                source = 'if(e.querySelector(\":scope ' + expr.replace(/\\x22/g, '\\\\\"') + '\")){' + source + '}';\n                break;\n              default:\n                emit('\\'' + selectorString + '\\'' + qsInvalid);\n            }\n          // *** location pseudo-classes\n          // :any-link, :link, :visited, :target\n          } else if ((match = selector.match(Patterns.locationpc))) {\n            match[1] = match[1].toLowerCase();\n            switch (match[1]) {\n              case 'any-link':\n                source = 'if(' + N + '(/^a|area$/i.test(e.localName)&&e.hasAttribute(\"href\")||e.visited)){' + source + '}';\n                break;\n              case 'link':\n                source = 'if(' + N + '(/^a|area$/i.test(e.localName)&&e.hasAttribute(\"href\"))){' + source + '}';\n                break;\n              // FIXME:\n              case 'visited':\n                source = 'if(' + N + '(/^a|area$/i.test(e.localName)&&e.hasAttribute(\"href\")&&e.visited)){' + source + '}';\n                break;\n              case 'target':\n                source = 'if(s.isTarget(e)){' + source + '}';\n                break;\n              default:\n                emit('\\'' + selectorString + '\\'' + qsInvalid);\n            }\n          // *** user interface and form pseudo-classes\n          // :enabled, :disabled, :read-only, :read-write, :placeholder-shown, :default\n          } else if ((match = selector.match(Patterns.inputstate))) {\n            match[1] = match[1].toLowerCase();\n            switch (match[1]) {\n              // FIXME: lacks custom element support\n              case 'enabled':\n                source = 'if(((\"form\" in e||/^optgroup$/i.test(e.localName))&&\"disabled\" in e &&e.disabled===false' +\n                  ')){' + source + '}';\n                break;\n              // FIXME: lacks custom element support\n              case 'disabled':\n                // https://html.spec.whatwg.org/#enabling-and-disabling-form-controls:-the-disabled-attribute\n                source = 'if(((\"form\" in e||/^optgroup$/i.test(e.localName))&&\"disabled\" in e)){' +\n                  // F is true if any of the fieldset elements in the ancestry chain has the disabled attribute specified\n                  // L is true if the first legend element of the fieldset contains the element\n                  'var x=0,N=[],F=false,L=false;' +\n                  'if(!(/^(optgroup|option)$/i.test(e.localName))){' +\n                    'n=e.parentElement;' +\n                    'while(n){' +\n                      'if(n.localName===\"fieldset\"){' +\n                        'N[x++]=n;' +\n                        'if(n.disabled===true){' +\n                          'F=true;' +\n                          'break;' +\n                        '}' +\n                      '}' +\n                      'n=n.parentElement;' +\n                    '}' +\n                    'for(var x=0;x<N.length;x++){' +\n                      'if((n=s.first(\"legend\",N[x]))&&n.contains(e)){' +\n                        'L=true;' +\n                        'break;' +\n                      '}' +\n                    '}' +\n                  '}' +\n                  'if(e.disabled===true||(F&&!L)){' + source + '}}';\n                break;\n              case 'read-only':\n                source =\n                  'if((' +\n                    '(/^textarea$/i.test(e.localName)&&(e.readOnly||e.disabled))||' +\n                    '(\"|date|datetime-local|email|month|number|password|search|tel|text|time|url|week|\".includes(\"|\"+e.type+\"|\")&&(e.readOnly||e.disabled))||' +\n                    '!s.isContentEditable(e)' +\n                  ')&&s.doc.designMode===\"off\"){' + source + '}';\n                break;\n              case 'read-write':\n                source =\n                  'if(' +\n                    '(/^textarea$/i.test(e.localName)&&!e.readOnly&&!e.disabled)||' +\n                    '(\"|date|datetime-local|email|month|number|password|search|tel|text|time|url|week|\".includes(\"|\"+e.type+\"|\")&&!e.readOnly&&!e.disabled)||' +\n                    's.isContentEditable(e)||s.doc.designMode===\"on\"' +\n                  '){' + source + '}';\n                break;\n              // FIXME:\n              case 'placeholder-shown':\n                source =\n                  'if((' +\n                    '(/^input|textarea$/i.test(e.localName))&&e.hasAttribute(\"placeholder\")&&' +\n                    '(\"|textarea|password|number|search|email|text|tel|url|\".includes(\"|\"+e.type+\"|\"))&&' +\n                    '(!s.match(\":focus\",e))' +\n                  ')){' + source + '}';\n                break;\n              // FIXME:\n              case 'default':\n                source =\n                  'if((\"form\" in e && e.form)){' +\n                    'var x=0;n=[];' +\n                    'if(e.type==\"image\")n=e.form.getElementsByTagName(\"input\");' +\n                    'if(e.type==\"submit\")n=e.form.elements;' +\n                    'while(n[x]&&e!==n[x]){' +\n                      'if(n[x].type==\"image\")break;' +\n                      'if(n[x].type==\"submit\")break;' +\n                      'x++;' +\n                    '}' +\n                  '}' +\n                  'if((e.form&&(e===n[x]&&\"|image|submit|\".includes(\"|\"+e.type+\"|\"))||' +\n                    '((/^option$/i.test(e.localName))&&e.defaultSelected)||' +\n                    '((\"|radio|checkbox|\".includes(\"|\"+e.type+\"|\"))&&e.defaultChecked)' +\n                  ')){' + source + '}';\n                break;\n              default:\n                emit('\\'' + selector_string + '\\'' + qsInvalid);\n                break;\n            }\n          // *** input pseudo-classes (for form validation)\n          // :checked, :indeterminate, :valid, :invalid, :in-range, :out-of-range, :required, :optional\n          } else if ((match = selector.match(Patterns.inputvalue))) {\n            match[1] = match[1].toLowerCase();\n            switch (match[1]) {\n              case 'checked':\n                source = 'if(' + N + '(/^input$/i.test(e.localName)&&' +\n                  '(\"|radio|checkbox|\".includes(\"|\"+e.type+\"|\")&&e.checked)||' +\n                  '(/^option$/i.test(e.localName)&&(e.selected||e.checked))' +\n                  ')){' + source + '}';\n                break;\n              case 'indeterminate':\n                source = 'if(s.isIndeterminate(e)){' + source + '}';\n                break;\n              // FIXME:\n              case 'required':\n                source =\n                  'if(' + N +\n                    '(/^input|select|textarea$/i.test(e.localName)&&e.required)' +\n                  '){' + source + '}';\n                break;\n              // FIXME:\n              case 'optional':\n                source =\n                  'if(' + N +\n                    '(/^input|select|textarea$/i.test(e.localName)&&!e.required)' +\n                  '){' + source + '}';\n                break;\n              // FIXME:\n              case 'invalid':\n                source =\n                  'if(' + N + '((' +\n                    '(/^form$/i.test(e.localName)&&!e.noValidate)||' +\n                    '(e.willValidate&&!e.formNoValidate))&&!e.checkValidity())||' +\n                    '(/^fieldset$/i.test(e.localName)&&s.first(\":invalid\",e))' +\n                  '){' + source + '}';\n                break;\n              // FIXME:\n              case 'valid':\n                source =\n                  'if(' + N + '((' +\n                    '(/^form$/i.test(e.localName)&&!e.noValidate)||' +\n                    '(e.willValidate&&!e.formNoValidate))&&e.checkValidity())||' +\n                    '(/^fieldset$/i.test(e.localName)&&s.first(\":valid\",e))' +\n                  '){' + source + '}';\n                break;\n              // FIXME:\n              case 'in-range':\n                source =\n                  'if(' + N +\n                    '(/^input$/i.test(e.localName))&&' +\n                    '(e.willValidate&&!e.formNoValidate)&&' +\n                    '(!e.validity.rangeUnderflow&&!e.validity.rangeOverflow)&&' +\n                    '(\"|date|datetime-local|month|number|range|time|week|\".includes(\"|\"+e.type+\"|\"))&&' +\n                    '(\"range\"==e.type||e.getAttribute(\"min\")||e.getAttribute(\"max\"))' +\n                  '){' + source + '}';\n                break;\n              // FIXME:\n              case 'out-of-range':\n                source =\n                  'if(' + N +\n                    '(/^input$/i.test(e.localName))&&' +\n                    '(e.willValidate&&!e.formNoValidate)&&' +\n                    '(e.validity.rangeUnderflow||e.validity.rangeOverflow)&&' +\n                    '(\"|date|datetime-local|month|number|range|time|week|\".includes(\"|\"+e.type+\"|\"))&&' +\n                    '(\"range\"==e.type||e.getAttribute(\"min\")||e.getAttribute(\"max\"))' +\n                  '){' + source + '}';\n                break;\n              default:\n                emit('\\'' + selectorString + '\\'' + qsInvalid);\n            }\n          // allow pseudo-elements starting with single colon (:)\n          // :after, :before, :first-letter, :first-line\n          // assert: e.type is in double-colon format, like ::after\n          } else if ((match = selector.match(Patterns.pseudoSng))) {\n            source = 'if(e.element&&e.type.toLowerCase()==\"' +\n              ':' + match[0].toLowerCase() + '\"){e=e.element;' + source + '}';\n          // allow pseudo-elements starting with double colon (::)\n          // ::after, ::before, ::marker, ::placeholder, ::inactive-selection, ::selection, ::-webkit-<foo-bar>\n          // assert: e.type is in double-colon format, like ::after\n          } else if ((match = selector.match(Patterns.pseudoDbl))) {\n            source = 'if(e.element&&e.type.toLowerCase()==\"' +\n              match[0].toLowerCase() + '\"){e=e.element;' + source + '}';\n          // placeholder for parsed only no-op selectors\n          } else if ((match = selector.match(Patterns.pseudoNop))) {\n            source = 'if(' + N + 'false' + '){' + source + '}';\n          } else {\n            // reset\n            expr = false;\n            status = false;\n            // process registered selector extensions\n            for (expr in Selectors) {\n              if ((match = selector.match(Selectors[expr].Expression))) {\n                result = Selectors[expr].Callback(match, source, mode, callback);\n                if ('match' in result) {\n                  match = result.match;\n                }\n                vars = result.modvar;\n                if (mode) {\n                  // add extra select() vars\n                  vars && !S_VARS.includes(vars) && S_VARS.push(vars);\n                } else {\n                  // add extra match() vars\n                  vars && M_VARS.includes(vars) && M_VARS.push(vars);\n                }\n                // extension source code\n                source = result.source;\n                // extension status code\n                status = result.status;\n                // break on status error\n                if (status) { break; }\n              }\n            }\n            if (!status) {\n              emit('unknown pseudo-class selector \\'' + selector + '\\'');\n              return '';\n            }\n            if (!expr) {\n              emit('unknown token in selector \\'' + selector + '\\'');\n              return '';\n            }\n          }\n          break;\n        default:\n          selectorRecursion = false;\n          emit('\\'' + selectorString + '\\'' + qsInvalid);\n      }\n      // end of switch symbol\n      if (!selectorRecursion) {\n        break;\n      }\n      if (!match) {\n        emit('\\'' + selectorString + '\\'' + qsInvalid);\n        return '';\n      }\n\n      // pop last component\n      selector = match.pop();\n    }\n    // end of while selector\n\n    return source;\n  };\n\n  // compile groups or single selector strings into\n  // executable functions for matching or selecting\n  const compile = function (selector, mode, callback) {\n    let head = ''; let loop = ''; let macro = ''; let source = ''; let vars = '';\n\n    // 'mode' can be boolean or null\n    // true = select / false = match\n    // null to use collection.item()\n    switch (mode) {\n      case true:\n        if (selectLambdas[selector]) {\n          return selectLambdas[selector];\n        }\n        macro = S_BODY + (callback ? S_TEST : '') + S_TAIL;\n        head = S_HEAD;\n        loop = S_LOOP;\n        break;\n      case false:\n        if (matchLambdas[selector]) {\n          return matchLambdas[selector];\n        }\n        macro = M_BODY + (callback ? M_TEST : '') + M_TAIL;\n        head = M_HEAD;\n        loop = M_LOOP;\n        break;\n      case null:\n        if (selectLambdas[selector]) {\n          return selectLambdas[selector];\n        }\n        macro = N_BODY + (callback ? N_TEST : '') + S_TAIL;\n        head = S_HEAD;\n        loop = N_LOOP;\n        break;\n      default:\n    }\n\n    source = compileSelector(selector, macro, mode, callback);\n\n    loop += (mode || mode === null) ? '{' + source + '}' : source;\n\n    if ((mode || mode === null) && selector.includes(':nth')) {\n      loop += reNthElem.test(selector) ? 's.nthElement(null, 2);' : '';\n      loop += reNthType.test(selector) ? 's.nthOfType(null, 2);' : '';\n    }\n\n    if (S_VARS[0] || M_VARS[0]) {\n      vars = ',' + (S_VARS.join(',') || M_VARS.join(','));\n      S_VARS = [];\n      M_VARS = [];\n    }\n\n    const factory = Function('s', F_INIT + '{' + head + vars + ';' + loop + 'return r;}')(Snapshot);\n\n    return mode || mode === null ? (selectLambdas[selector] = factory) : (matchLambdas[selector] = factory);\n  };\n\n  // optimize selectors avoiding duplicated checks\n  const optimize = function (selector, token) {\n    const index = token.index;\n    const length = token[1].length + token[2].length;\n    return selector.slice(0, index) +\n      (' >+~'.indexOf(selector.charAt(index - 1)) > -1\n        ? (':['.indexOf(selector.charAt(index + length + 1)) > -1\n            ? '*'\n            : '')\n        : '') + selector.slice(index + length - (token[1] === '*' ? 1 : 0));\n  };\n\n  // prepare factory resolvers and closure collections\n  const collect = function (selectors, context, callback) {\n    let i;\n    let l;\n    const seen = { };\n    let token = ['', '*', '*'];\n    const optimized = selectors;\n    const factory = [];\n    const htmlset = [];\n    const nodeset = [];\n    let results = [];\n    let type;\n\n    for (i = 0, l = selectors.length; l > i; ++i) {\n      if (!seen[selectors[i]] && (seen[selectors[i]] = true)) {\n        type = selectors[i].match(reOptimizer);\n        if (type && type[1] !== ':' && (token = type)) {\n          token[1] || (token[1] = '*');\n          optimized[i] = optimize(optimized[i], token);\n        } else {\n          token = ['', '*', '*'];\n        }\n      }\n\n      nodeset[i] = token[1] + token[2];\n      htmlset[i] = compat[token[1]](context, token[2]);\n      factory[i] = compile(optimized[i], true, null);\n\n      factory[i]\n        ? factory[i](htmlset[i](), callback, context, results)\n        : results.concat(htmlset[i]());\n    }\n\n    if (l > 1) {\n      results.sort(documentOrder);\n      hasDupes && (results = unique(results));\n    }\n\n    return {\n      callback,\n      context,\n      factory,\n      htmlset,\n      nodeset,\n      results\n    };\n  };\n\n  // replace ':scope' pseudo-class with element references\n  const makeref = function (selectors, element) {\n    // DOCUMENT_NODE (9)\n    if (element.nodeType === 9) {\n      element = element.documentElement;\n    }\n\n    return selectors.replace(/:scope/gi,\n      element.localName +\n        (element.id ? '#' + element.id : '') +\n        (element.className ? '.' + element.classList[0] : ''));\n  };\n\n  const matchAssert = function (f, element, callback) {\n    let r = false;\n    for (let i = 0, l = f.length; l > i; ++i) {\n      f[i](element, callback, null, false) && (r = true);\n    }\n    return r;\n  };\n\n  const matchCollect = function (selectors, callback) {\n    const f = [];\n    for (let i = 0, l = selectors.length; l > i; ++i) {\n      f[i] = compile(selectors[i], false, callback);\n    }\n    return { factory: f };\n  };\n\n  // equivalent of w3c 'matches' method\n  const match = function _matches(selectors, element, callback) {\n    let expressions;\n\n    if (element && matchResolvers[selectors]) {\n      return matchAssert(matchResolvers[selectors].factory, element, callback);\n    }\n\n    lastMatched = selectors;\n\n    // arguments validation\n    if (arguments.length === 0) {\n      emit(qsNotArgs, 'TypeError');\n      return Config.VERBOSITY ? undefined : false;\n    } else if (arguments[0] === '') {\n      emit('\\'\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : false;\n    }\n\n    // input NULL or UNDEFINED\n    if (typeof selectors !== 'string') {\n      selectors = '' + selectors;\n    }\n\n    if ((/:scope/i).test(selectors)) {\n      selectors = makeref(selectors, element);\n    }\n\n    // normalize input string\n    const parsed = selectors\n      .replace(/\\0|\\\\$/g, '\\ufffd')\n      .replace(REX.combineWSP, '\\x20')\n      .replace(REX.pseudosWSP, '$1')\n      .replace(REX.tabCharWSP, '\\t')\n      .replace(REX.commaGroup, ',')\n      .replace(REX.trimSpaces, '');\n\n    // parse, validate and split possible compound selectors\n    if ((expressions = parsed.match(reValidator)) && expressions.join('') === parsed) {\n      expressions = parsed.match(REX.splitGroup);\n      if (parsed[parsed.length - 1] === ',') {\n        emit(qsInvalid);\n        return Config.VERBOSITY ? undefined : false;\n      }\n    } else {\n      emit('\\'' + selectors + '\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : false;\n    }\n\n    matchResolvers[selectors] = matchCollect(expressions, callback);\n\n    return matchAssert(matchResolvers[selectors].factory, element, callback);\n  };\n\n  // equivalent of w3c 'closest' method\n  const ancestor = function _closest(selectors, element, callback) {\n    if ((/:scope/i).test(selectors)) {\n      selectors = makeref(selectors, element);\n    }\n\n    while (element) {\n      if (match(selectors, element, callback)) break;\n      element = element.parentElement;\n    }\n    return element;\n  };\n\n  // equivalent of w3c 'querySelectorAll' method\n  const select = function _querySelectorAll(selectors, context, callback) {\n    let expressions; let nodes = []; let resolver;\n\n    context || (context = doc);\n\n    if (selectors) {\n      if ((resolver = selectResolvers[selectors])) {\n        if (resolver.context === context && resolver.callback === callback) {\n          const f = resolver.factory;\n          const h = resolver.htmlset;\n          const n = resolver.nodeset;\n          if (n.length > 1) {\n            const l = n.length;\n            for (let i = 0, l = n.length, list; l > i; ++i) {\n              list = compat[n[i][0]](context, n[i].slice(1))();\n              if (f[i] !== null) {\n                f[i](list, callback, context, nodes);\n              } else {\n                nodes = nodes.concat(list);\n              }\n            }\n            if (l > 1 && nodes.length > 1) {\n              nodes.sort(documentOrder);\n              hasDupes && (nodes = unique(nodes));\n            }\n          } else {\n            if (f[0]) {\n              nodes = f[0](h[0](), callback, context, nodes);\n            } else {\n              nodes = h[0]();\n            }\n          }\n          return typeof callback === 'function'\n            ? concatCall(nodes, callback)\n            : nodes;\n        }\n      }\n    }\n\n    lastSelected = selectors;\n\n    // arguments validation\n    if (arguments.length === 0) {\n      emit(qsNotArgs, 'TypeError');\n      return Config.VERBOSITY ? undefined : none;\n    } else if (arguments[0] === '') {\n      emit('\\'\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : none;\n    } else if (lastContext !== context) {\n      lastContext = switchContext(context);\n    }\n\n    // input NULL or UNDEFINED\n    if (typeof selectors !== 'string') {\n      selectors = '' + selectors;\n    }\n\n    if ((/:scope/i).test(selectors)) {\n      selectors = makeref(selectors, context);\n    }\n\n    // normalize input string\n    const parsed = selectors\n      .replace(/\\0|\\\\$/g, '\\ufffd')\n      .replace(REX.combineWSP, '\\x20')\n      .replace(REX.pseudosWSP, '$1')\n      .replace(REX.tabCharWSP, '\\t')\n      .replace(REX.commaGroup, ',')\n      .replace(REX.trimSpaces, '');\n\n    // parse, validate and split possible compound selectors\n    if ((expressions = parsed.match(reValidator)) && expressions.join('') === parsed) {\n      expressions = parsed.match(REX.splitGroup);\n      if (parsed[parsed.length - 1] === ',') {\n        emit(qsInvalid);\n        return Config.VERBOSITY ? undefined : false;\n      }\n    } else {\n      emit('\\'' + selectors + '\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : false;\n    }\n\n    // save/reuse factory and closure collection\n    selectResolvers[selectors] = collect(expressions, context, callback);\n\n    nodes = selectResolvers[selectors].results;\n\n    return typeof callback === 'function'\n      ? concatCall(nodes, callback)\n      : nodes;\n  };\n\n  // equivalent of w3c 'querySelector' method\n  const first = function _querySelector(selectors, context, callback) {\n    if (arguments.length === 0) {\n      emit(qsNotArgs, 'TypeError');\n    }\n    return select(selectors, context, typeof callback === 'function'\n      ? function firstMatch(element) {\n        callback(element);\n        return false;\n      }\n      : function firstMatch() {\n        return false;\n      }\n    )[0] || null;\n  };\n\n  // execute the engine initialization code\n  const initialize = function (d) {\n    setIdentifierSyntax();\n    lastContext = switchContext(d, true);\n    Snapshot.doc = doc;\n    Snapshot.from = doc;\n    Snapshot.root = root;\n    Snapshot.byTag = byTag;\n    Snapshot.first = first;\n    Snapshot.match = match;\n    Snapshot.ancestor = ancestor;\n    Snapshot.nthOfType = nthOfType;\n    Snapshot.nthElement = nthElement;\n    Snapshot.hasAttributeNS = hasAttributeNS;\n    Snapshot.isTarget = isTarget;\n    Snapshot.isIndeterminate = isIndeterminate;\n    Snapshot.isContentEditable = isContentEditable;\n  };\n\n  initialize(doc);\n\n  // public exported methods/objects\n  const Dom = {\n    // exported engine methods\n    Version: version,\n    configure,\n    match,\n    closest: ancestor,\n    first,\n    select\n  };\n\n  return Dom;\n});\n", "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bidi_js = factory());\n}(this, (function () { 'use strict';\n\n  function bidiFactory() {\n  var bidi = (function (exports) {\n\n    // Bidi character types data, auto generated\n    var DATA = {\n      \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n      \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n      \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n      \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n      \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n      \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n      \"B\": \"a,3,f+2,2v,690\",\n      \"S\": \"9,2,k\",\n      \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n      \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n      \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n      \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n      \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n      \"LRO\": \"6ct\",\n      \"RLO\": \"6cu\",\n      \"LRE\": \"6cq\",\n      \"RLE\": \"6cr\",\n      \"PDF\": \"6cs\",\n      \"LRI\": \"6ee\",\n      \"RLI\": \"6ef\",\n      \"FSI\": \"6eg\",\n      \"PDI\": \"6eh\"\n    };\n\n    var TYPES = {};\n    var TYPES_TO_NAMES = {};\n    TYPES.L = 1; //L is the default\n    TYPES_TO_NAMES[1] = 'L';\n    Object.keys(DATA).forEach(function (type, i) {\n      TYPES[type] = 1 << (i + 1);\n      TYPES_TO_NAMES[TYPES[type]] = type;\n    });\n    Object.freeze(TYPES);\n\n    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n    var map = null;\n\n    function parseData () {\n      if (!map) {\n        //const start = performance.now()\n        map = new Map();\n        var loop = function ( type ) {\n          if (DATA.hasOwnProperty(type)) {\n            var lastCode = 0;\n            DATA[type].split(',').forEach(function (range) {\n              var ref = range.split('+');\n              var skip = ref[0];\n              var step = ref[1];\n              skip = parseInt(skip, 36);\n              step = step ? parseInt(step, 36) : 0;\n              map.set(lastCode += skip, TYPES[type]);\n              for (var i = 0; i < step; i++) {\n                map.set(++lastCode, TYPES[type]);\n              }\n            });\n          }\n        };\n\n        for (var type in DATA) loop( type );\n        //console.log(`char types parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    /**\n     * @param {string} char\n     * @return {number}\n     */\n    function getBidiCharType (char) {\n      parseData();\n      return map.get(char.codePointAt(0)) || TYPES.L\n    }\n\n    function getBidiCharTypeName(char) {\n      return TYPES_TO_NAMES[getBidiCharType(char)]\n    }\n\n    // Bidi bracket pairs data, auto generated\n    var data$1 = {\n      \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n      \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n    };\n\n    /**\n     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n     * @param {string} encodedString\n     * @param {boolean} includeReverse - true if you want reverseMap in the output\n     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n     */\n    function parseCharacterMap (encodedString, includeReverse) {\n      var radix = 36;\n      var lastCode = 0;\n      var map = new Map();\n      var reverseMap = includeReverse && new Map();\n      var prevPair;\n      encodedString.split(',').forEach(function visit(entry) {\n        if (entry.indexOf('+') !== -1) {\n          for (var i = +entry; i--;) {\n            visit(prevPair);\n          }\n        } else {\n          prevPair = entry;\n          var ref = entry.split('>');\n          var a = ref[0];\n          var b = ref[1];\n          a = String.fromCodePoint(lastCode += parseInt(a, radix));\n          b = String.fromCodePoint(lastCode += parseInt(b, radix));\n          map.set(a, b);\n          includeReverse && reverseMap.set(b, a);\n        }\n      });\n      return { map: map, reverseMap: reverseMap }\n    }\n\n    var openToClose, closeToOpen, canonical;\n\n    function parse$1 () {\n      if (!openToClose) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data$1.pairs, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap;\n        openToClose = map;\n        closeToOpen = reverseMap;\n        canonical = parseCharacterMap(data$1.canonical, false).map;\n        //console.log(`brackets parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function openingToClosingBracket (char) {\n      parse$1();\n      return openToClose.get(char) || null\n    }\n\n    function closingToOpeningBracket (char) {\n      parse$1();\n      return closeToOpen.get(char) || null\n    }\n\n    function getCanonicalBracket (char) {\n      parse$1();\n      return canonical.get(char) || null\n    }\n\n    // Local type aliases\n    var TYPE_L = TYPES.L;\n    var TYPE_R = TYPES.R;\n    var TYPE_EN = TYPES.EN;\n    var TYPE_ES = TYPES.ES;\n    var TYPE_ET = TYPES.ET;\n    var TYPE_AN = TYPES.AN;\n    var TYPE_CS = TYPES.CS;\n    var TYPE_B = TYPES.B;\n    var TYPE_S = TYPES.S;\n    var TYPE_ON = TYPES.ON;\n    var TYPE_BN = TYPES.BN;\n    var TYPE_NSM = TYPES.NSM;\n    var TYPE_AL = TYPES.AL;\n    var TYPE_LRO = TYPES.LRO;\n    var TYPE_RLO = TYPES.RLO;\n    var TYPE_LRE = TYPES.LRE;\n    var TYPE_RLE = TYPES.RLE;\n    var TYPE_PDF = TYPES.PDF;\n    var TYPE_LRI = TYPES.LRI;\n    var TYPE_RLI = TYPES.RLI;\n    var TYPE_FSI = TYPES.FSI;\n    var TYPE_PDI = TYPES.PDI;\n\n    /**\n     * @typedef {object} GetEmbeddingLevelsResult\n     * @property {{start, end, level}[]} paragraphs\n     * @property {Uint8Array} levels\n     */\n\n    /**\n     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n     * base embedding level.\n     *\n     * @param {string} string - The input string\n     * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n     *        otherwise a direction will be chosen automatically from each paragraph's contents.\n     * @return {GetEmbeddingLevelsResult}\n     */\n    function getEmbeddingLevels (string, baseDirection) {\n      var MAX_DEPTH = 125;\n\n      // Start by mapping all characters to their unicode type, as a bitmask integer\n      var charTypes = new Uint32Array(string.length);\n      for (var i = 0; i < string.length; i++) {\n        charTypes[i] = getBidiCharType(string[i]);\n      }\n\n      var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n      function changeCharType(i, type) {\n        var oldType = charTypes[i];\n        charTypes[i] = type;\n        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n        if (oldType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n        }\n        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n        if (type & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n      }\n\n      var embedLevels = new Uint8Array(string.length);\n      var isolationPairs = new Map(); //init->pdi and pdi->init\n\n      // === 3.3.1 The Paragraph Level ===\n      // 3.3.1 P1: Split the text into paragraphs\n      var paragraphs = []; // [{start, end, level}, ...]\n      var paragraph = null;\n      for (var i$1 = 0; i$1 < string.length; i$1++) {\n        if (!paragraph) {\n          paragraphs.push(paragraph = {\n            start: i$1,\n            end: string.length - 1,\n            // 3.3.1 P2-P3: Determine the paragraph level\n            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n          });\n        }\n        if (charTypes[i$1] & TYPE_B) {\n          paragraph.end = i$1;\n          paragraph = null;\n        }\n      }\n\n      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n      var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n      var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n      // Everything from here on will operate per paragraph.\n      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n        paragraph = paragraphs[paraIdx];\n        var statusStack = [{\n          _level: paragraph.level,\n          _override: 0, //0=neutral, 1=L, 2=R\n          _isolate: 0 //bool\n        }];\n        var stackTop = (void 0);\n        var overflowIsolateCount = 0;\n        var overflowEmbeddingCount = 0;\n        var validIsolateCount = 0;\n        charTypeCounts.clear();\n\n        // === 3.3.2 Explicit Levels and Directions ===\n        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n          var charType = charTypes[i$2];\n          stackTop = statusStack[statusStack.length - 1];\n\n          // Set initial counts\n          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n          if (charType & NEUTRAL_ISOLATE_TYPES) {\n            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n          }\n\n          // Explicit Embeddings: 3.3.2 X2 - X3\n          if (charType & FORMATTING_TYPES) { //prefilter all formatters\n            if (charType & (TYPE_RLE | TYPE_LRE)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level,\n                  _override: 0,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            }\n\n            // Explicit Overrides: 3.3.2 X4 - X5\n            else if (charType & (TYPE_RLO | TYPE_LRO)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level$1,\n                  _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            }\n\n            // Isolates: 3.3.2 X5a - X5c\n            else if (charType & ISOLATE_INIT_TYPES) {\n              // X5c - FSI becomes either RLI or LRI\n              if (charType & TYPE_FSI) {\n                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n              }\n\n              embedLevels[i$2] = stackTop._level;\n              if (stackTop._override) {\n                changeCharType(i$2, stackTop._override);\n              }\n              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n                validIsolateCount++;\n                statusStack.push({\n                  _level: level$2,\n                  _override: 0,\n                  _isolate: 1,\n                  _isolInitIndex: i$2\n                });\n              } else {\n                overflowIsolateCount++;\n              }\n            }\n\n            // Terminating Isolates: 3.3.2 X6a\n            else if (charType & TYPE_PDI) {\n              if (overflowIsolateCount > 0) {\n                overflowIsolateCount--;\n              } else if (validIsolateCount > 0) {\n                overflowEmbeddingCount = 0;\n                while (!statusStack[statusStack.length - 1]._isolate) {\n                  statusStack.pop();\n                }\n                // Add to isolation pairs bidirectional mapping:\n                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n                if (isolInitIndex != null) {\n                  isolationPairs.set(isolInitIndex, i$2);\n                  isolationPairs.set(i$2, isolInitIndex);\n                }\n                statusStack.pop();\n                validIsolateCount--;\n              }\n              stackTop = statusStack[statusStack.length - 1];\n              embedLevels[i$2] = stackTop._level;\n              if (stackTop._override) {\n                changeCharType(i$2, stackTop._override);\n              }\n            }\n\n\n            // Terminating Embeddings and Overrides: 3.3.2 X7\n            else if (charType & TYPE_PDF) {\n              if (overflowIsolateCount === 0) {\n                if (overflowEmbeddingCount > 0) {\n                  overflowEmbeddingCount--;\n                } else if (!stackTop._isolate && statusStack.length > 1) {\n                  statusStack.pop();\n                  stackTop = statusStack[statusStack.length - 1];\n                }\n              }\n              embedLevels[i$2] = stackTop._level; // 5.2\n            }\n\n            // End of Paragraph: 3.3.2 X8\n            else if (charType & TYPE_B) {\n              embedLevels[i$2] = paragraph.level;\n            }\n          }\n\n          // Non-formatting characters: 3.3.2 X6\n          else {\n            embedLevels[i$2] = stackTop._level;\n            // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n            if (stackTop._override && charType !== TYPE_BN) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n        }\n\n        // === 3.3.3 Preparations for Implicit Processing ===\n\n        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n        // easily ignore them all from here on out.\n\n        // 3.3.3 X10\n        // Compute the set of isolating run sequences as specified by BD13\n        var levelRuns = [];\n        var currentRun = null;\n        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n          var charType$1 = charTypes[i$3];\n          if (!(charType$1 & BN_LIKE_TYPES)) {\n            var lvl = embedLevels[i$3];\n            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n            var isPDI = charType$1 === TYPE_PDI;\n            if (currentRun && lvl === currentRun._level) {\n              currentRun._end = i$3;\n              currentRun._endsWithIsolInit = isIsolInit;\n            } else {\n              levelRuns.push(currentRun = {\n                _start: i$3,\n                _end: i$3,\n                _level: lvl,\n                _startsWithPDI: isPDI,\n                _endsWithIsolInit: isIsolInit\n              });\n            }\n          }\n        }\n        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n          var run = levelRuns[runIdx];\n          if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n            var seqRuns = [currentRun = run];\n            for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n                if (levelRuns[i$4]._start === pdiIndex) {\n                  seqRuns.push(currentRun = levelRuns[i$4]);\n                  break\n                }\n              }\n            }\n            // build flat list of indices across all runs:\n            var seqIndices = [];\n            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n              var run$1 = seqRuns[i$5];\n              for (var j = run$1._start; j <= run$1._end; j++) {\n                seqIndices.push(j);\n              }\n            }\n            // determine the sos/eos types:\n            var firstLevel = embedLevels[seqIndices[0]];\n            var prevLevel = paragraph.level;\n            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n              if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n                prevLevel = embedLevels[i$6];\n                break\n              }\n            }\n            var lastIndex = seqIndices[seqIndices.length - 1];\n            var lastLevel = embedLevels[lastIndex];\n            var nextLevel = paragraph.level;\n            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n                if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                  nextLevel = embedLevels[i$7];\n                  break\n                }\n              }\n            }\n            isolatingRunSeqs.push({\n              _seqIndices: seqIndices,\n              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n            });\n          }\n        }\n\n        // The next steps are done per isolating run sequence\n        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n          var ref = isolatingRunSeqs[seqIdx];\n          var seqIndices$1 = ref._seqIndices;\n          var sosType = ref._sosType;\n          var eosType = ref._eosType;\n          /**\n           * All the level runs in an isolating run sequence have the same embedding level.\n           * \n           * DO NOT change any `embedLevels[i]` within the current scope.\n           */\n          var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n          // === 3.3.4 Resolving Weak Types ===\n\n          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n          if (charTypeCounts.get(TYPE_NSM)) {\n            for (var si = 0; si < seqIndices$1.length; si++) {\n              var i$8 = seqIndices$1[si];\n              if (charTypes[i$8] & TYPE_NSM) {\n                var prevType = sosType;\n                for (var sj = si - 1; sj >= 0; sj--) {\n                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                    prevType = charTypes[seqIndices$1[sj]];\n                    break\n                  }\n                }\n                changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n              }\n            }\n          }\n\n          // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n          // is found. If an AL is found, change the type of the European number to Arabic number.\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n              var i$9 = seqIndices$1[si$1];\n              if (charTypes[i$9] & TYPE_EN) {\n                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                  if (prevCharType & STRONG_TYPES) {\n                    if (prevCharType === TYPE_AL) {\n                      changeCharType(i$9, TYPE_AN);\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // W3. Change all ALs to R\n          if (charTypeCounts.get(TYPE_AL)) {\n            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n              var i$10 = seqIndices$1[si$2];\n              if (charTypes[i$10] & TYPE_AL) {\n                changeCharType(i$10, TYPE_R);\n              }\n            }\n          }\n\n          // W4. A single European separator between two European numbers changes to a European number. A single common\n          // separator between two numbers of the same type changes to that type.\n          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n              var i$11 = seqIndices$1[si$3];\n              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n                var prevType$1 = 0, nextType = 0;\n                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                  prevType$1 = charTypes[seqIndices$1[sj$2]];\n                  if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                    break\n                  }\n                }\n                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                  nextType = charTypes[seqIndices$1[sj$3]];\n                  if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                    break\n                  }\n                }\n                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                  changeCharType(i$11, prevType$1);\n                }\n              }\n            }\n          }\n\n          // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n              var i$12 = seqIndices$1[si$4];\n              if (charTypes[i$12] & TYPE_EN) {\n                for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                  changeCharType(seqIndices$1[sj$4], TYPE_EN);\n                }\n                for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                    changeCharType(seqIndices$1[si$4], TYPE_EN);\n                  }\n                }\n              }\n            }\n          }\n\n          // W6. Otherwise, separators and terminators change to Other Neutral.\n          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n              var i$13 = seqIndices$1[si$5];\n              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n                changeCharType(i$13, TYPE_ON);\n                // 5.2 transform adjacent BNs too:\n                for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                  changeCharType(seqIndices$1[sj$5], TYPE_ON);\n                }\n                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                  changeCharType(seqIndices$1[sj$6], TYPE_ON);\n                }\n              }\n            }\n          }\n\n          // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n          // is found. If an L is found, then change the type of the European number to L.\n          // NOTE: implemented in single forward pass for efficiency\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n              var i$14 = seqIndices$1[si$6];\n              var type = charTypes[i$14];\n              if (type & TYPE_EN) {\n                if (prevStrongType === TYPE_L) {\n                  changeCharType(i$14, TYPE_L);\n                }\n              } else if (type & STRONG_TYPES) {\n                prevStrongType = type;\n              }\n            }\n          }\n\n          // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n            // types EN and AN are treated as R.\n            var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n            // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n            var bracketPairs = [];\n            {\n              var openerStack = [];\n              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n                // NOTE: for any potential bracket character we also test that it still carries a NI\n                // type, as that may have been changed earlier. This doesn't seem to be explicitly\n                // called out in the spec, but is required for passage of certain tests.\n                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                  var char = string[seqIndices$1[si$7]];\n                  var oppositeBracket = (void 0);\n                  // Opening bracket\n                  if (openingToClosingBracket(char) !== null) {\n                    if (openerStack.length < 63) {\n                      openerStack.push({ char: char, seqIndex: si$7 });\n                    } else {\n                      break\n                    }\n                  }\n                  // Closing bracket\n                  else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                      var stackChar = openerStack[stackIdx].char;\n                      if (stackChar === oppositeBracket ||\n                        stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                        openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                      ) {\n                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                        openerStack.length = stackIdx; //pop the matching bracket and all following\n                        break\n                      }\n                    }\n                  }\n                }\n              }\n              bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n            }\n            // * For each bracket-pair element in the list of pairs of text positions\n            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n              var ref$1 = bracketPairs[pairIdx];\n              var openSeqIdx = ref$1[0];\n              var closeSeqIdx = ref$1[1];\n              // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n              // brackets in the pair to match the embedding direction.\n              var foundStrongType = false;\n              var useStrongType = 0;\n              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n                var i$15 = seqIndices$1[si$8];\n                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                  foundStrongType = true;\n                  var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr === embedDirection) {\n                    useStrongType = lr;\n                    break\n                  }\n                }\n              }\n              // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n              // for an established context with a preceding strong type by checking backwards before the opening paired\n              // bracket until the first strong type (L, R, or sos) is found.\n              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n              //    set the type for both brackets in the pair to that direction.\n              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n              if (foundStrongType && !useStrongType) {\n                useStrongType = sosType;\n                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                  var i$16 = seqIndices$1[si$9];\n                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                    var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                    if (lr$1 !== embedDirection) {\n                      useStrongType = lr$1;\n                    } else {\n                      useStrongType = embedDirection;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType) {\n                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n                // * Any number of characters that had original bidirectional character type NSM prior to the application\n                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n                // the type of their preceding bracket.\n                if (useStrongType !== embedDirection) {\n                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$10]] = useStrongType;\n                      }\n                      break\n                    }\n                  }\n                }\n                if (useStrongType !== embedDirection) {\n                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$11]] = useStrongType;\n                      }\n                      break\n                    }\n                  }\n                }\n              }\n            }\n\n            // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n            // same direction.\n            // N2. Any remaining NIs take the embedding direction.\n            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n                var niRunStart = si$12, niRunEnd = si$12;\n                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n                for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                  } else {\n                    prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                    break\n                  }\n                }\n                var nextType$1 = eosType;\n                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                    niRunEnd = si2$1;\n                  } else {\n                    nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                    break\n                  }\n                }\n                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n                }\n                si$12 = niRunEnd;\n              }\n            }\n          }\n        }\n\n        // === 3.3.6 Resolving Implicit Levels ===\n\n        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n          var level$3 = embedLevels[i$17];\n          var type$1 = charTypes[i$17];\n          // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n          if (level$3 & 1) {\n            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n              embedLevels[i$17]++;\n            }\n          }\n            // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n          // and those of type AN or EN go up two levels.\n          else {\n            if (type$1 & TYPE_R) {\n              embedLevels[i$17]++;\n            } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n              embedLevels[i$17] += 2;\n            }\n          }\n\n          // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n          // and otherwise to the base level.\n          if (type$1 & BN_LIKE_TYPES) {\n            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n          }\n\n          // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n            for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n              embedLevels[j$1] = paragraph.level;\n            }\n          }\n        }\n      }\n\n      // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n      // according to section 3.4 Reordering Resolved Levels\n      return {\n        levels: embedLevels,\n        paragraphs: paragraphs\n      }\n\n      function determineAutoEmbedLevel (start, isFSI) {\n        // 3.3.1 P2 - P3\n        for (var i = start; i < string.length; i++) {\n          var charType = charTypes[i];\n          if (charType & (TYPE_R | TYPE_AL)) {\n            return 1\n          }\n          if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n            return 0\n          }\n          if (charType & ISOLATE_INIT_TYPES) {\n            var pdi = indexOfMatchingPDI(i);\n            i = pdi === -1 ? string.length : pdi;\n          }\n        }\n        return 0\n      }\n\n      function indexOfMatchingPDI (isolateStart) {\n        // 3.1.2 BD9\n        var isolationLevel = 1;\n        for (var i = isolateStart + 1; i < string.length; i++) {\n          var charType = charTypes[i];\n          if (charType & TYPE_B) {\n            break\n          }\n          if (charType & TYPE_PDI) {\n            if (--isolationLevel === 0) {\n              return i\n            }\n          } else if (charType & ISOLATE_INIT_TYPES) {\n            isolationLevel++;\n          }\n        }\n        return -1\n      }\n    }\n\n    // Bidi mirrored chars data, auto generated\n    var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n    var mirrorMap;\n\n    function parse () {\n      if (!mirrorMap) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap;\n        // Combine both maps into one\n        reverseMap.forEach(function (value, key) {\n          map.set(key, value);\n        });\n        mirrorMap = map;\n        //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function getMirroredCharacter (char) {\n      parse();\n      return mirrorMap.get(char) || null\n    }\n\n    /**\n     * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n     * for any characters in right-to-left segments that have defined mirrored characters.\n     * @param string\n     * @param embeddingLevels\n     * @param [start]\n     * @param [end]\n     * @return {Map<number, string>}\n     */\n    function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n      var map = new Map();\n      for (var i = start; i <= end; i++) {\n        if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n          var mirror = getMirroredCharacter(string[i]);\n          if (mirror !== null) {\n            map.set(i, mirror);\n          }\n        }\n      }\n      return map\n    }\n\n    /**\n     * Given a start and end denoting a single line within a string, and a set of precalculated\n     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n     * @param {string} string - the full input string\n     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n     * @param {number} [start] - first character in a subset of the full string\n     * @param {number} [end] - last character in a subset of the full string\n     * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n     */\n    function getReorderSegments(string, embeddingLevelsResult, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n      var segments = [];\n      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n        var lineStart = Math.max(start, paragraph.start);\n        var lineEnd = Math.min(end, paragraph.end);\n        if (lineStart < lineEnd) {\n          // Local slice for mutation\n          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n          // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n          // end of the line to the paragraph level.\n          for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n            lineLevels[i] = paragraph.level;\n          }\n\n          // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n          var maxLevel = paragraph.level;\n          var minOddLevel = Infinity;\n          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n            var level = lineLevels[i$1];\n            if (level > maxLevel) { maxLevel = level; }\n            if (level < minOddLevel) { minOddLevel = level | 1; }\n          }\n          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n              if (lineLevels[i$2] >= lvl) {\n                var segStart = i$2;\n                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                  i$2++;\n                }\n                if (i$2 > segStart) {\n                  segments.push([segStart + lineStart, i$2 + lineStart]);\n                }\n              }\n            }\n          }\n        }\n      });\n      return segments\n    }\n\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {string} the new string with bidi segments reordered\n     */\n    function getReorderedString(string, embedLevelsResult, start, end) {\n      var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n      var chars = [].concat( string );\n      indices.forEach(function (charIndex, i) {\n        chars[i] = (\n          (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n        ) || string[charIndex];\n      });\n      return chars.join('')\n    }\n\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {number[]} an array with character indices in their new bidi order\n     */\n    function getReorderedIndices(string, embedLevelsResult, start, end) {\n      var segments = getReorderSegments(string, embedLevelsResult, start, end);\n      // Fill an array with indices\n      var indices = [];\n      for (var i = 0; i < string.length; i++) {\n        indices[i] = i;\n      }\n      // Reverse each segment in order\n      segments.forEach(function (ref) {\n        var start = ref[0];\n        var end = ref[1];\n\n        var slice = indices.slice(start, end + 1);\n        for (var i = slice.length; i--;) {\n          indices[end - i] = slice[i];\n        }\n      });\n      return indices\n    }\n\n    exports.closingToOpeningBracket = closingToOpeningBracket;\n    exports.getBidiCharType = getBidiCharType;\n    exports.getBidiCharTypeName = getBidiCharTypeName;\n    exports.getCanonicalBracket = getCanonicalBracket;\n    exports.getEmbeddingLevels = getEmbeddingLevels;\n    exports.getMirroredCharacter = getMirroredCharacter;\n    exports.getMirroredCharactersMap = getMirroredCharactersMap;\n    exports.getReorderSegments = getReorderSegments;\n    exports.getReorderedIndices = getReorderedIndices;\n    exports.getReorderedString = getReorderedString;\n    exports.openingToClosingBracket = openingToClosingBracket;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n    return exports;\n\n  }({}));\n  return bidi}\n\n  return bidiFactory;\n\n})));\n", "// Generated using `npm run build`. Do not edit.\n\nvar regex = /^[a-z](?:[\\.0-9_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*-(?:[\\x2D\\.0-9_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n\nvar isPotentialCustomElementName = function(string) {\n\treturn regex.test(string);\n};\n\nmodule.exports = isPotentialCustomElementName;\n", "/*!\n * DOM Selector - A CSS selector engine.\n * @license MIT\n * @copyright asamuzaK (Kazz)\n * @see {@link https://github.com/asamuzaK/domSelector/blob/main/LICENSE}\n */\n\n/* import */\nimport { Finder } from './js/finder.js';\nimport { filterSelector, getType, initNwsapi } from './js/utility.js';\n\n/* constants */\nimport {\n  COMBO, COMPOUND_I, DESCEND, DOCUMENT_NODE, ELEMENT_NODE, TAG_ID_CLASS,\n  TARGET_ALL, TARGET_FIRST, TARGET_LINEAL, TARGET_SELF\n} from './js/constant.js';\nconst REG_COMPLEX = new RegExp(`${COMPOUND_I}${COMBO}${COMPOUND_I}`, 'i');\nconst REG_DESCEND = new RegExp(`${COMPOUND_I}${DESCEND}${COMPOUND_I}`, 'i');\nconst REG_SIMPLE = new RegExp(`^${TAG_ID_CLASS}$`);\n\n/* DOMSelector */\nexport class DOMSelector {\n  /* private fields */\n  #window;\n  #document;\n  #finder;\n  #nwsapi;\n\n  /**\n   * construct\n   * @param {object} window - window\n   * @param {object} document - document\n   */\n  constructor(window, document) {\n    this.#window = window;\n    this.#document = document ?? window.document;\n    this.#finder = new Finder(window);\n    this.#nwsapi = initNwsapi(window, document);\n  }\n\n  /**\n   * matches\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - `true` if matched `false` otherwise\n   */\n  matches(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    } else if (node.nodeType !== ELEMENT_NODE) {\n      const e = new this.#window.TypeError(`Unexpected node ${node.nodeName}`);\n      this.#finder.onError(e, opt);\n    }\n    const document = node.ownerDocument;\n    if (document === this.#document && document.contentType === 'text/html' &&\n        node.parentNode) {\n      const filterOpt = {\n        complex: REG_COMPLEX.test(selector),\n        compound: false,\n        descend: false,\n        simple: false,\n        target: TARGET_SELF\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.match(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_SELF);\n      res = nodes.size;\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return !!res;\n  }\n\n  /**\n   * closest\n   * @param {string} selector - CSS selector\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  closest(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    } else if (node.nodeType !== ELEMENT_NODE) {\n      const e = new this.#window.TypeError(`Unexpected node ${node.nodeName}`);\n      this.#finder.onError(e, opt);\n    }\n    const document = node.ownerDocument;\n    if (document === this.#document && document.contentType === 'text/html' &&\n        node.parentNode) {\n      const filterOpt = {\n        complex: REG_COMPLEX.test(selector),\n        compound: false,\n        descend: false,\n        simple: false,\n        target: TARGET_LINEAL\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.closest(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_LINEAL);\n      if (nodes.size) {\n        let refNode = node;\n        while (refNode) {\n          if (nodes.has(refNode)) {\n            res = refNode;\n            break;\n          }\n          refNode = refNode.parentNode;\n        }\n      }\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  querySelector(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    }\n    let document;\n    if (node.nodeType === DOCUMENT_NODE) {\n      document = node;\n    } else {\n      document = node.ownerDocument;\n    }\n    if (document === this.#document && document.contentType === 'text/html') {\n      const filterOpt = {\n        complex: false,\n        compound: !(REG_SIMPLE.test(selector) || REG_COMPLEX.test(selector)),\n        descend: REG_DESCEND.test(selector),\n        simple: REG_SIMPLE.test(selector),\n        target: TARGET_FIRST\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.first(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_FIRST);\n      if (nodes.size) {\n        [res] = nodes;\n      }\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return res ?? null;\n  }\n\n  /**\n   * query selector all\n   * NOTE: returns Array, not NodeList\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @returns {Array.<object|undefined>} - collection of matched nodes\n   */\n  querySelectorAll(selector, node, opt) {\n    if (!node?.nodeType) {\n      const e = new this.#window.TypeError(`Unexpected type ${getType(node)}`);\n      this.#finder.onError(e, opt);\n    }\n    let document;\n    if (node.nodeType === DOCUMENT_NODE) {\n      document = node;\n    } else {\n      document = node.ownerDocument;\n    }\n    if (document === this.#document && document.contentType === 'text/html') {\n      const filterOpt = {\n        complex: false,\n        compound: false,\n        descend: REG_DESCEND.test(selector),\n        simple: false,\n        target: TARGET_ALL\n      };\n      if (filterSelector(selector, filterOpt)) {\n        try {\n          const res = this.#nwsapi.select(selector, node);\n          return res;\n        } catch (e) {\n          // fall through\n        }\n      }\n    }\n    let res;\n    try {\n      this.#finder.setup(selector, node, opt);\n      const nodes = this.#finder.find(TARGET_ALL);\n      if (nodes.size) {\n        res = [...nodes];\n      }\n    } catch (e) {\n      this.#finder.onError(e, opt);\n    }\n    return res ?? [];\n  }\n}\n", "const EOF = 0;\n\n// https://drafts.csswg.org/css-syntax-3/\n// \u00A7 4.2. Definitions\n\n// digit\n// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\nexport function isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n\n// hex digit\n// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\nexport function isHexDigit(code) {\n    return (\n        isDigit(code) || // 0 .. 9\n        (code >= 0x0041 && code <= 0x0046) || // A .. F\n        (code >= 0x0061 && code <= 0x0066)    // a .. f\n    );\n}\n\n// uppercase letter\n// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\nexport function isUppercaseLetter(code) {\n    return code >= 0x0041 && code <= 0x005A;\n}\n\n// lowercase letter\n// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\nexport function isLowercaseLetter(code) {\n    return code >= 0x0061 && code <= 0x007A;\n}\n\n// letter\n// An uppercase letter or a lowercase letter.\nexport function isLetter(code) {\n    return isUppercaseLetter(code) || isLowercaseLetter(code);\n}\n\n// non-ASCII code point\n// A code point with a value equal to or greater than U+0080 <control>.\n//\n// 2024-09-02: The latest spec narrows the range for non-ASCII characters (see https://github.com/csstree/csstree/issues/188).\n// However, all modern browsers support a wider range, and strictly following the latest spec could result\n// in some CSS being parsed incorrectly, even though it works in the browser. Therefore, this function adheres\n// to the previous, broader definition of non-ASCII characters.\nexport function isNonAscii(code) {\n    return code >= 0x0080;\n}\n\n// name-start code point\n// A letter, a non-ASCII code point, or U+005F LOW LINE (_).\nexport function isNameStart(code) {\n    return isLetter(code) || isNonAscii(code) || code === 0x005F;\n}\n\n// name code point\n// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\nexport function isName(code) {\n    return isNameStart(code) || isDigit(code) || code === 0x002D;\n}\n\n// non-printable code point\n// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\nexport function isNonPrintable(code) {\n    return (\n        (code >= 0x0000 && code <= 0x0008) ||\n        (code === 0x000B) ||\n        (code >= 0x000E && code <= 0x001F) ||\n        (code === 0x007F)\n    );\n}\n\n// newline\n// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n// as they are converted to U+000A LINE FEED during preprocessing.\n// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\nexport function isNewline(code) {\n    return code === 0x000A || code === 0x000D || code === 0x000C;\n}\n\n// whitespace\n// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\nexport function isWhiteSpace(code) {\n    return isNewline(code) || code === 0x0020 || code === 0x0009;\n}\n\n// \u00A7 4.3.8. Check if two code points are a valid escape\nexport function isValidEscape(first, second) {\n    // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n    if (first !== 0x005C) {\n        return false;\n    }\n\n    // Otherwise, if the second code point is a newline or EOF, return false.\n    if (isNewline(second) || second === EOF) {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}\n\n// \u00A7 4.3.9. Check if three code points would start an identifier\nexport function isIdentifierStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002D HYPHEN-MINUS\n    if (first === 0x002D) {\n        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n        // or the second and third code points are a valid escape, return true. Otherwise, return false.\n        return (\n            isNameStart(second) ||\n            second === 0x002D ||\n            isValidEscape(second, third)\n        );\n    }\n\n    // name-start code point\n    if (isNameStart(first)) {\n        // Return true.\n        return true;\n    }\n\n    // U+005C REVERSE SOLIDUS (\\)\n    if (first === 0x005C) {\n        // If the first and second code points are a valid escape, return true. Otherwise, return false.\n        return isValidEscape(first, second);\n    }\n\n    // anything else\n    // Return false.\n    return false;\n}\n\n// \u00A7 4.3.10. Check if three code points would start a number\nexport function isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (first === 0x002B || first === 0x002D) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    if (first === 0x002E) {\n        // If the second code point is a digit, return true. Otherwise, return false.\n        return isDigit(second) ? 2 : 0;\n    }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\n//\n// Misc\n//\n\n// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\nexport function isBOM(code) {\n    // UTF-16BE\n    if (code === 0xFEFF) {\n        return 1;\n    }\n\n    // UTF-16LE\n    if (code === 0xFFFE) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Fast code category\n// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only\nconst CATEGORY = new Array(0x80);\nexport const EofCategory = 0x80;\nexport const WhiteSpaceCategory = 0x82;\nexport const DigitCategory = 0x83;\nexport const NameStartCategory = 0x84;\nexport const NonPrintableCategory = 0x85;\n\nfor (let i = 0; i < CATEGORY.length; i++) {\n    CATEGORY[i] =\n        isWhiteSpace(i) && WhiteSpaceCategory ||\n        isDigit(i) && DigitCategory ||\n        isNameStart(i) && NameStartCategory ||\n        isNonPrintable(i) && NonPrintableCategory ||\n        i || EofCategory;\n}\n\nexport function charCodeCategory(code) {\n    return code < 0x80 ? CATEGORY[code] : NameStartCategory;\n}\n", "import {\n    isDigit,\n    isHexDigit,\n    isUppercaseLetter,\n    isName,\n    isWhiteSpace,\n    isValidEscape\n} from './char-code-definitions.js';\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nexport function getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nexport function cmpChar(testStr, offset, referenceCode) {\n    let code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nexport function cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (let i = start; i < end; i++) {\n        const referenceCode = referenceStr.charCodeAt(i - start);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nexport function findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nexport function findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// \u00A7 4.3.7. Consume an escaped code point\nexport function consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        const code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// \u00A74.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nexport function consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// \u00A74.3.12. Consume a number\nexport function consumeNumber(source, offset) {\n    let code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        offset += 2;\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        let sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// \u00A7 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nexport function consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\n// \u00A7 4.3.7. Consume an escaped code point\n// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\\)\nexport function decodeEscaped(escaped) {\n    // Single char escaped that's not a hex digit\n    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {\n        return escaped[0];\n    }\n\n    // Interpret the hex digits as a hexadecimal number.\n    let code = parseInt(escaped, 16);\n\n    if (\n        (code === 0) ||                       // If this number is zero,\n        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,\n        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point\n    ) {\n        // ... return U+FFFD REPLACEMENT CHARACTER\n        code = 0xFFFD;\n    }\n\n    // Otherwise, return the code point with that value.\n    return String.fromCodePoint(code);\n}\n", "export default [\n    'EOF-token',\n    'ident-token',\n    'function-token',\n    'at-keyword-token',\n    'hash-token',\n    'string-token',\n    'bad-string-token',\n    'url-token',\n    'bad-url-token',\n    'delim-token',\n    'number-token',\n    'percentage-token',\n    'dimension-token',\n    'whitespace-token',\n    'CDO-token',\n    'CDC-token',\n    'colon-token',\n    'semicolon-token',\n    'comma-token',\n    '[-token',\n    ']-token',\n    '(-token',\n    ')-token',\n    '{-token',\n    '}-token',\n    'comment-token'\n];\n", "const MIN_SIZE = 16 * 1024;\n\nexport function adoptBuffer(buffer = null, size) {\n    if (buffer === null || buffer.length < size) {\n        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));\n    }\n\n    return buffer;\n};\n", "import { adoptBuffer } from './adopt-buffer.js';\nimport { isBOM } from './char-code-definitions.js';\n\nconst N = 10;\nconst F = 12;\nconst R = 13;\n\nfunction computeLinesAndColumns(host) {\n    const source = host.source;\n    const sourceLength = source.length;\n    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;\n    const lines = adoptBuffer(host.lines, sourceLength);\n    const columns = adoptBuffer(host.columns, sourceLength);\n    let line = host.startLine;\n    let column = host.startColumn;\n\n    for (let i = startOffset; i < sourceLength; i++) {\n        const code = source.charCodeAt(i);\n\n        lines[i] = line;\n        columns[i] = column++;\n\n        if (code === N || code === R || code === F) {\n            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {\n                i++;\n                lines[i] = line;\n                columns[i] = column;\n            }\n\n            line++;\n            column = 1;\n        }\n    }\n\n    lines[sourceLength] = line;\n    columns[sourceLength] = column;\n\n    host.lines = lines;\n    host.columns = columns;\n    host.computed = true;\n}\n\nexport class OffsetToLocation {\n    constructor(source, startOffset, startLine, startColumn) {\n        this.setSource(source, startOffset, startLine, startColumn);\n        this.lines = null;\n        this.columns = null;\n    }\n    setSource(source = '', startOffset = 0, startLine = 1, startColumn = 1) {\n        this.source = source;\n        this.startOffset = startOffset;\n        this.startLine = startLine;\n        this.startColumn = startColumn;\n        this.computed = false;\n    }\n    getLocation(offset, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            offset: this.startOffset + offset,\n            line: this.lines[offset],\n            column: this.columns[offset]\n        };\n    }\n    getLocationRange(start, end, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            start: {\n                offset: this.startOffset + start,\n                line: this.lines[start],\n                column: this.columns[start]\n            },\n            end: {\n                offset: this.startOffset + end,\n                line: this.lines[end],\n                column: this.columns[end]\n            }\n        };\n    }\n};\n", "import { adoptBuffer } from './adopt-buffer.js';\nimport { cmpStr } from './utils.js';\nimport tokenNames from './names.js';\nimport {\n    WhiteSpace,\n    Comment,\n    Delim,\n    EOF,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    LeftSquareBracket,\n    RightSquareBracket,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from './types.js';\n\nconst OFFSET_MASK = 0x00FFFFFF;\nconst TYPE_SHIFT = 24;\nconst balancePair = new Uint8Array(32); // 32b of memory ought to be enough for anyone (any number of tokens)\nbalancePair[FunctionToken] = RightParenthesis;\nbalancePair[LeftParenthesis] = RightParenthesis;\nbalancePair[LeftSquareBracket] = RightSquareBracket;\nbalancePair[LeftCurlyBracket] = RightCurlyBracket;\n\nfunction isBlockOpenerToken(tokenType) {\n    return balancePair[tokenType] !== 0;\n}\n\nexport class TokenStream {\n    constructor(source, tokenize) {\n        this.setSource(source, tokenize);\n    }\n    reset() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    }\n    setSource(source = '', tokenize = () => {}) {\n        source = String(source || '');\n\n        const sourceLength = source.length;\n        const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token\n        const balance = adoptBuffer(this.balance, source.length + 1);\n        let tokenCount = 0;\n        let firstCharOffset = -1;\n        let balanceCloseType = 0;\n        let balanceStart = source.length;\n\n        // capture buffers\n        this.offsetAndType = null;\n        this.balance = null;\n        balance.fill(0);\n\n        tokenize(source, (type, start, end) => {\n            const index = tokenCount++;\n\n            // type & offset\n            offsetAndType[index] = (type << TYPE_SHIFT) | end;\n\n            if (firstCharOffset === -1) {\n                firstCharOffset = start;\n            }\n\n            // balance\n            balance[index] = balanceStart;\n\n            if (type === balanceCloseType) {\n                const prevBalanceStart = balance[balanceStart];\n\n                // set reference to balance end for a block opener\n                balance[balanceStart] = index;\n\n                // pop state\n                balanceStart = prevBalanceStart;\n                balanceCloseType = balancePair[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];\n            } else if (isBlockOpenerToken(type)) { // check for FunctionToken, <(-token>, <[-token> and <{-token>\n                // push state\n                balanceStart = index;\n                balanceCloseType = balancePair[type];\n            }\n        });\n\n        // finalize buffers\n        offsetAndType[tokenCount] = (EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>\n        balance[tokenCount] = tokenCount; // prevents false positive balance match with any token\n\n        // reverse references from balance start to end\n        // tokens\n        //   token:   a ( [ b c ] d e ) {\n        //   index:   0 1 2 3 4 5 6 7 8 9\n        // before\n        //   balance: 0 8 5 2 2 2 1 1 1 0\n        //            - > > < < < < < < -\n        // after\n        //   balance: 9 8 5 5 5 2 8 8 1 9\n        //            > > > > > < > > < >\n        for (let i = 0; i < tokenCount; i++) {\n            const balanceStart = balance[i];\n\n            if (balanceStart <= i) {\n                const balanceEnd = balance[balanceStart];\n\n                if (balanceEnd !== i) {\n                    balance[i] = balanceEnd;\n                }\n            } else if (balanceStart > tokenCount) {\n                balance[i] = tokenCount;\n            }\n        }\n\n        // balance[0] = tokenCount;\n\n        this.source = source;\n        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;\n        this.tokenCount = tokenCount;\n        this.offsetAndType = offsetAndType;\n        this.balance = balance;\n\n        this.reset();\n        this.next();\n    }\n\n    lookupType(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    }\n    lookupTypeNonSC(idx) {\n        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {\n            const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n            if (tokenType !== WhiteSpace && tokenType !== Comment) {\n                if (idx-- === 0) {\n                    return tokenType;\n                }\n            }\n        }\n\n        return EOF;\n    }\n    lookupOffset(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    }\n    lookupOffsetNonSC(idx) {\n        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {\n            const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n            if (tokenType !== WhiteSpace && tokenType !== Comment) {\n                if (idx-- === 0) {\n                    return offset - this.tokenIndex;\n                }\n            }\n        }\n\n        return EOF;\n    }\n    lookupValue(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    }\n    getTokenStart(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    }\n    substrToCursor(start) {\n        return this.source.substring(start, this.tokenStart);\n    }\n\n    isBalanceEdge(pos) {\n        return this.balance[this.tokenIndex] < pos;\n        // return this.balance[this.balance[pos]] !== this.tokenIndex;\n    }\n    isDelim(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    }\n\n    skip(tokenCount) {\n        let next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    }\n    next() {\n        let next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.eof = true;\n            this.tokenIndex = this.tokenCount;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    }\n    skipSC() {\n        while (this.tokenType === WhiteSpace || this.tokenType === Comment) {\n            this.next();\n        }\n    }\n    skipUntilBalanced(startToken, stopConsume) {\n        let cursor = startToken;\n        let balanceEnd = 0;\n        let offset = 0;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;\n\n            // check stop condition\n            switch (stopConsume(this.source.charCodeAt(offset))) {\n                case 1: // just stop\n                    break loop;\n\n                case 2: // stop & included\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block for an open block tokens\n                    if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {\n                        cursor = balanceEnd;\n                    }\n            }\n        }\n\n        this.skip(cursor - this.tokenIndex);\n    }\n\n    forEachToken(fn) {\n        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            const start = offset;\n            const item = this.offsetAndType[i];\n            const end = item & OFFSET_MASK;\n            const type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    }\n    dump() {\n        const tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: tokenNames[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n", "import * as TYPE from './types.js';\nimport {\n    isNewline,\n    isName,\n    isValidEscape,\n    isNumberStart,\n    isIdentifierStart,\n    isBOM,\n    charCodeCategory,\n    WhiteSpaceCategory,\n    DigitCategory,\n    NameStartCategory,\n    NonPrintableCategory\n} from './char-code-definitions.js';\nimport {\n    cmpStr,\n    getNewlineLength,\n    findWhiteSpaceEnd,\n    consumeEscaped,\n    consumeName,\n    consumeNumber,\n    consumeBadUrlRemnants\n} from './utils.js';\n\nexport function tokenize(source, onToken) {\n    function getCharCode(offset) {\n        return offset < sourceLength ? source.charCodeAt(offset) : 0;\n    }\n\n    // \u00A7 4.3.3. Consume a numeric token\n    function consumeNumericToken() {\n        // Consume a number and let number be the result.\n        offset = consumeNumber(source, offset);\n\n        // If the next 3 input code points would start an identifier, then:\n        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n            // Consume a name. Set the <dimension-token>\u2019s unit to the returned value.\n            // Return the <dimension-token>.\n            type = TYPE.Dimension;\n            offset = consumeName(source, offset);\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n        if (getCharCode(offset) === 0x0025) {\n            // Create a <percentage-token> with the same value as number, and return it.\n            type = TYPE.Percentage;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n        type = TYPE.Number;\n    }\n\n    // \u00A7 4.3.4. Consume an ident-like token\n    function consumeIdentLikeToken() {\n        const nameStartOffset = offset;\n\n        // Consume a name, and let string be the result.\n        offset = consumeName(source, offset);\n\n        // If string\u2019s value is an ASCII case-insensitive match for \"url\",\n        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n            // While the next two input code points are whitespace, consume the next input code point.\n            offset = findWhiteSpaceEnd(source, offset + 1);\n\n            // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n            // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n            // then create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0022 ||\n                getCharCode(offset) === 0x0027) {\n                type = TYPE.Function;\n                offset = nameStartOffset + 4;\n                return;\n            }\n\n            // Otherwise, consume a url token, and return it.\n            consumeUrlToken();\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        // Create a <function-token> with its value set to string and return it.\n        if (getCharCode(offset) === 0x0028) {\n            type = TYPE.Function;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create an <ident-token> with its value set to string and return it.\n        type = TYPE.Ident;\n    }\n\n    // \u00A7 4.3.5. Consume a string token\n    function consumeStringToken(endingCodePoint) {\n        // This algorithm may be called with an ending code point, which denotes the code point\n        // that ends the string. If an ending code point is not specified,\n        // the current input code point is used.\n        if (!endingCodePoint) {\n            endingCodePoint = getCharCode(offset++);\n        }\n\n        // Initially create a <string-token> with its value set to the empty string.\n        type = TYPE.String;\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // ending code point\n                case endingCodePoint:\n                    // Return the <string-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <string-token>.\n                    // return;\n\n                // newline\n                case WhiteSpaceCategory:\n                    if (isNewline(code)) {\n                        // This is a parse error. Reconsume the current input code point,\n                        // create a <bad-string-token>, and return it.\n                        offset += getNewlineLength(source, offset, code);\n                        type = TYPE.BadString;\n                        return;\n                    }\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the next input code point is EOF, do nothing.\n                    if (offset === source.length - 1) {\n                        break;\n                    }\n\n                    const nextCode = getCharCode(offset + 1);\n\n                    // Otherwise, if the next input code point is a newline, consume it.\n                    if (isNewline(nextCode)) {\n                        offset += getNewlineLength(source, offset + 1, nextCode);\n                    } else if (isValidEscape(code, nextCode)) {\n                        // Otherwise, (the stream starts with a valid escape) consume\n                        // an escaped code point and append the returned code point to\n                        // the <string-token>\u2019s value.\n                        offset = consumeEscaped(source, offset) - 1;\n                    }\n                    break;\n\n                // anything else\n                // Append the current input code point to the <string-token>\u2019s value.\n            }\n        }\n    }\n\n    // \u00A7 4.3.6. Consume a url token\n    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n    // This algorithm also assumes that it\u2019s being called to consume an \"unquoted\" value, like url(foo).\n    // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n    // automatically handles this distinction; this algorithm shouldn\u2019t be called directly otherwise.\n    function consumeUrlToken() {\n        // Initially create a <url-token> with its value set to the empty string.\n        type = TYPE.Url;\n\n        // Consume as much whitespace as possible.\n        offset = findWhiteSpaceEnd(source, offset);\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return the <url-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <url-token>.\n                    // return;\n\n                // whitespace\n                case WhiteSpaceCategory:\n                    // Consume as much whitespace as possible.\n                    offset = findWhiteSpaceEnd(source, offset);\n\n                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                    // consume it and return the <url-token>\n                    // (if EOF was encountered, this is a parse error);\n                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                        if (offset < source.length) {\n                            offset++;\n                        }\n                        return;\n                    }\n\n                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                    // and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+0022 QUOTATION MARK (\")\n                // U+0027 APOSTROPHE (')\n                // U+0028 LEFT PARENTHESIS (()\n                // non-printable code point\n                case 0x0022:\n                case 0x0027:\n                case 0x0028:\n                case NonPrintableCategory:\n                    // This is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the stream starts with a valid escape, consume an escaped code point and\n                    // append the returned code point to the <url-token>\u2019s value.\n                    if (isValidEscape(code, getCharCode(offset + 1))) {\n                        offset = consumeEscaped(source, offset) - 1;\n                        break;\n                    }\n\n                    // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // anything else\n                // Append the current input code point to the <url-token>\u2019s value.\n            }\n        }\n    }\n\n    // ensure source is a string\n    source = String(source || '');\n\n    const sourceLength = source.length;\n    let start = isBOM(getCharCode(0));\n    let offset = start;\n    let type;\n\n    // https://drafts.csswg.org/css-syntax-3/#consume-token\n    // \u00A7 4.3.1. Consume a token\n    while (offset < sourceLength) {\n        const code = source.charCodeAt(offset);\n\n        switch (charCodeCategory(code)) {\n            // whitespace\n            case WhiteSpaceCategory:\n                // Consume as much whitespace as possible. Return a <whitespace-token>.\n                type = TYPE.WhiteSpace;\n                offset = findWhiteSpaceEnd(source, offset + 1);\n                break;\n\n            // U+0022 QUOTATION MARK (\")\n            case 0x0022:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0023 NUMBER SIGN (#)\n            case 0x0023:\n                // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // Create a <hash-token>.\n                    type = TYPE.Hash;\n\n                    // If the next 3 input code points would start an identifier, set the <hash-token>\u2019s type flag to \"id\".\n                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    //     // TODO: set id flag\n                    // }\n\n                    // Consume a name, and set the <hash-token>\u2019s value to the returned string.\n                    offset = consumeName(source, offset + 1);\n\n                    // Return the <hash-token>.\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0027 APOSTROPHE (')\n            case 0x0027:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0028 LEFT PARENTHESIS (()\n            case 0x0028:\n                // Return a <(-token>.\n                type = TYPE.LeftParenthesis;\n                offset++;\n                break;\n\n            // U+0029 RIGHT PARENTHESIS ())\n            case 0x0029:\n                // Return a <)-token>.\n                type = TYPE.RightParenthesis;\n                offset++;\n                break;\n\n            // U+002B PLUS SIGN (+)\n            case 0x002B:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+002C COMMA (,)\n            case 0x002C:\n                // Return a <comma-token>.\n                type = TYPE.Comma;\n                offset++;\n                break;\n\n            // U+002D HYPHEN-MINUS (-)\n            case 0x002D:\n                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                    if (getCharCode(offset + 1) === 0x002D &&\n                        getCharCode(offset + 2) === 0x003E) {\n                        type = TYPE.CDC;\n                        offset = offset + 3;\n                    } else {\n                        // Otherwise, if the input stream starts with an identifier, ...\n                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                            // ... reconsume the current input code point, consume an ident-like token, and return it.\n                            consumeIdentLikeToken();\n                        } else {\n                            // Otherwise, return a <delim-token> with its value set to the current input code point.\n                            type = TYPE.Delim;\n                            offset++;\n                        }\n                    }\n                }\n                break;\n\n            // U+002E FULL STOP (.)\n            case 0x002E:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+002F SOLIDUS (/)\n            case 0x002F:\n                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                if (getCharCode(offset + 1) === 0x002A) {\n                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                    type = TYPE.Comment;\n                    offset = source.indexOf('*/', offset + 2);\n                    offset = offset === -1 ? source.length : offset + 2;\n                } else {\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+003A COLON (:)\n            case 0x003A:\n                // Return a <colon-token>.\n                type = TYPE.Colon;\n                offset++;\n                break;\n\n            // U+003B SEMICOLON (;)\n            case 0x003B:\n                // Return a <semicolon-token>.\n                type = TYPE.Semicolon;\n                offset++;\n                break;\n\n            // U+003C LESS-THAN SIGN (<)\n            case 0x003C:\n                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                if (getCharCode(offset + 1) === 0x0021 &&\n                    getCharCode(offset + 2) === 0x002D &&\n                    getCharCode(offset + 3) === 0x002D) {\n                    // ... consume them and return a <CDO-token>.\n                    type = TYPE.CDO;\n                    offset = offset + 4;\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0040 COMMERCIAL AT (@)\n            case 0x0040:\n                // If the next 3 input code points would start an identifier, ...\n                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                    type = TYPE.AtKeyword;\n                    offset = consumeName(source, offset + 1);\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+005B LEFT SQUARE BRACKET ([)\n            case 0x005B:\n                // Return a <[-token>.\n                type = TYPE.LeftSquareBracket;\n                offset++;\n                break;\n\n            // U+005C REVERSE SOLIDUS (\\)\n            case 0x005C:\n                // If the input stream starts with a valid escape, ...\n                if (isValidEscape(code, getCharCode(offset + 1))) {\n                    // ... reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                } else {\n                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+005D RIGHT SQUARE BRACKET (])\n            case 0x005D:\n                // Return a <]-token>.\n                type = TYPE.RightSquareBracket;\n                offset++;\n                break;\n\n            // U+007B LEFT CURLY BRACKET ({)\n            case 0x007B:\n                // Return a <{-token>.\n                type = TYPE.LeftCurlyBracket;\n                offset++;\n                break;\n\n            // U+007D RIGHT CURLY BRACKET (})\n            case 0x007D:\n                // Return a <}-token>.\n                type = TYPE.RightCurlyBracket;\n                offset++;\n                break;\n\n            // digit\n            case DigitCategory:\n                // Reconsume the current input code point, consume a numeric token, and return it.\n                consumeNumericToken();\n                break;\n\n            // name-start code point\n            case NameStartCategory:\n                // Reconsume the current input code point, consume an ident-like token, and return it.\n                consumeIdentLikeToken();\n                break;\n\n                // EOF\n                // case EofCategory:\n                // Return an <EOF-token>.\n                // break;\n\n            // anything else\n            default:\n                // Return a <delim-token> with its value set to the current input code point.\n                type = TYPE.Delim;\n                offset++;\n        }\n\n        // put token to stream\n        onToken(type, start, start = offset);\n    }\n}\n\nexport * from './types.js';\nexport * as tokenTypes from './types.js';\nexport { default as tokenNames } from './names.js';\nexport * from './char-code-definitions.js';\nexport * from './utils.js';\nexport * from './OffsetToLocation.js';\nexport * from './TokenStream.js';\n", "//\n//                              list\n//                            \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//             \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500head \u2502\n//             \u2502              \u2502 tail\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//             \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n//             \u25BC                                    \u25BC\n//            item        item        item        item\n//          \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//  null \u25C0\u2500\u2500\u253C\u2500prev \u2502\u25C0\u2500\u2500\u2500\u253C\u2500prev \u2502\u25C0\u2500\u2500\u2500\u253C\u2500prev \u2502\u25C0\u2500\u2500\u2500\u253C\u2500prev \u2502\n//          \u2502 next\u2500\u253C\u2500\u2500\u2500\u25B6\u2502 next\u2500\u253C\u2500\u2500\u2500\u25B6\u2502 next\u2500\u253C\u2500\u2500\u2500\u25B6\u2502 next\u2500\u253C\u2500\u2500\u25B6 null\n//          \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n//          \u2502 data \u2502    \u2502 data \u2502    \u2502 data \u2502    \u2502 data \u2502\n//          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//\n\nlet releasedCursors = null;\n\nexport class List {\n    static createItem(data) {\n        return {\n            prev: null,\n            next: null,\n            data\n        };\n    }\n\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.cursor = null;\n    }\n    createItem(data) {\n        return List.createItem(data);\n    }\n\n    // cursor helpers\n    allocateCursor(prev, next) {\n        let cursor;\n\n        if (releasedCursors !== null) {\n            cursor = releasedCursors;\n            releasedCursors = releasedCursors.cursor;\n            cursor.prev = prev;\n            cursor.next = next;\n            cursor.cursor = this.cursor;\n        } else {\n            cursor = {\n                prev,\n                next,\n                cursor: this.cursor\n            };\n        }\n\n        this.cursor = cursor;\n\n        return cursor;\n    }\n    releaseCursor() {\n        const { cursor } = this;\n\n        this.cursor = cursor.cursor;\n        cursor.prev = null;\n        cursor.next = null;\n        cursor.cursor = releasedCursors;\n        releasedCursors = cursor;\n    }\n    updateCursors(prevOld, prevNew, nextOld, nextNew) {\n        let { cursor } = this;\n\n        while (cursor !== null) {\n            if (cursor.prev === prevOld) {\n                cursor.prev = prevNew;\n            }\n\n            if (cursor.next === nextOld) {\n                cursor.next = nextNew;\n            }\n\n            cursor = cursor.cursor;\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            yield cursor.data;\n        }\n    }\n\n    // getters\n    get size() {\n        let size = 0;\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            size++;\n        }\n\n        return size;\n    }\n    get isEmpty() {\n        return this.head === null;\n    }\n    get first() {\n        return this.head && this.head.data;\n    }\n    get last() {\n        return this.tail && this.tail.data;\n    }\n\n    // convertors\n    fromArray(array) {\n        let cursor = null;\n        this.head = null;\n\n        for (let data of array) {\n            const item = List.createItem(data);\n\n            if (cursor !== null) {\n                cursor.next = item;\n            } else {\n                this.head = item;\n            }\n\n            item.prev = cursor;\n            cursor = item;\n        }\n\n        this.tail = cursor;\n        return this;\n    }\n    toArray() {\n        return [...this];\n    }\n    toJSON() {\n        return [...this];\n    }\n\n    // array-like methods\n    forEach(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(null, this.head);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    forEachRight(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(this.tail, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    reduce(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(null, this.head);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.next !== null) {\n            item = cursor.next;\n            cursor.next = item.next;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    reduceRight(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(this.tail, null);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.prev !== null) {\n            item = cursor.prev;\n            cursor.prev = item.prev;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    some(fn, thisArg = this) {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    map(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            result.appendData(fn.call(thisArg, cursor.data, cursor, this));\n        }\n\n        return result;\n    }\n    filter(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                result.appendData(cursor.data);\n            }\n        }\n\n        return result;\n    }\n\n    nextUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(null, start);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    prevUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(start, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n\n    // mutation\n    clear() {\n        this.head = null;\n        this.tail = null;\n    }\n    copy() {\n        const result = new List();\n\n        for (let data of this) {\n            result.appendData(data);\n        }\n\n        return result;\n    }\n    prepend(item) {\n        //      head\n        //    ^\n        // item\n        this.updateCursors(null, item, this.head, item);\n\n        // insert to the beginning of the list\n        if (this.head !== null) {\n            // new item <- first item\n            this.head.prev = item;\n            // new item -> first item\n            item.next = this.head;\n        } else {\n            // if list has no head, then it also has no tail\n            // in this case tail points to the new item\n            this.tail = item;\n        }\n\n        // head always points to new item\n        this.head = item;\n        return this;\n    }\n    prependData(data) {\n        return this.prepend(List.createItem(data));\n    }\n    append(item) {\n        return this.insert(item);\n    }\n    appendData(data) {\n        return this.insert(List.createItem(data));\n    }\n    insert(item, before = null) {\n        if (before !== null) {\n            // prev   before\n            //      ^\n            //     item\n            this.updateCursors(before.prev, item, before, item);\n\n            if (before.prev === null) {\n                // insert to the beginning of list\n                if (this.head !== before) {\n                    throw new Error('before doesn\\'t belong to list');\n                }\n                // since head points to before therefore list doesn't empty\n                // no need to check tail\n                this.head = item;\n                before.prev = item;\n                item.next = before;\n                this.updateCursors(null, item);\n            } else {\n                // insert between two items\n                before.prev.next = item;\n                item.prev = before.prev;\n                before.prev = item;\n                item.next = before;\n            }\n        } else {\n            // tail\n            //      ^\n            //      item\n            this.updateCursors(this.tail, item, null, item);\n\n            // insert to the ending of the list\n            if (this.tail !== null) {\n                // last item -> new item\n                this.tail.next = item;\n                // last item <- new item\n                item.prev = this.tail;\n            } else {\n                // if list has no tail, then it also has no head\n                // in this case head points to new item\n                this.head = item;\n            }\n\n            // tail always points to new item\n            this.tail = item;\n        }\n\n        return this;\n    }\n    insertData(data, before) {\n        return this.insert(List.createItem(data), before);\n    }\n    remove(item) {\n        //      item\n        //       ^\n        // prev     next\n        this.updateCursors(item, item.prev, item, item.next);\n\n        if (item.prev !== null) {\n            item.prev.next = item.next;\n        } else {\n            if (this.head !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.head = item.next;\n        }\n\n        if (item.next !== null) {\n            item.next.prev = item.prev;\n        } else {\n            if (this.tail !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.tail = item.prev;\n        }\n\n        item.prev = null;\n        item.next = null;\n\n        return item;\n    }\n    push(data) {\n        this.insert(List.createItem(data));\n    }\n    pop() {\n        return this.tail !== null ? this.remove(this.tail) : null;\n    }\n    unshift(data) {\n        this.prepend(List.createItem(data));\n    }\n    shift() {\n        return this.head !== null ? this.remove(this.head) : null;\n    }\n    prependList(list) {\n        return this.insertList(list, this.head);\n    }\n    appendList(list) {\n        return this.insertList(list);\n    }\n    insertList(list, before) {\n        // ignore empty lists\n        if (list.head === null) {\n            return this;\n        }\n\n        if (before !== undefined && before !== null) {\n            this.updateCursors(before.prev, list.tail, before, list.head);\n\n            // insert in the middle of dist list\n            if (before.prev !== null) {\n                // before.prev <-> list.head\n                before.prev.next = list.head;\n                list.head.prev = before.prev;\n            } else {\n                this.head = list.head;\n            }\n\n            before.prev = list.tail;\n            list.tail.next = before;\n        } else {\n            this.updateCursors(this.tail, list.tail, null, list.head);\n\n            // insert to end of the list\n            if (this.tail !== null) {\n                // if destination list has a tail, then it also has a head,\n                // but head doesn't change\n                // dest tail -> source head\n                this.tail.next = list.head;\n                // dest tail <- source head\n                list.head.prev = this.tail;\n            } else {\n                // if list has no a tail, then it also has no a head\n                // in this case points head to new item\n                this.head = list.head;\n            }\n\n            // tail always start point to new item\n            this.tail = list.tail;\n        }\n\n        list.head = null;\n        list.tail = null;\n        return this;\n    }\n    replace(oldItem, newItemOrList) {\n        if ('head' in newItemOrList) {\n            this.insertList(newItemOrList, oldItem);\n        } else {\n            this.insert(newItemOrList, oldItem);\n        }\n\n        this.remove(oldItem);\n    }\n}\n", "export function createCustomError(name, message) {\n    // use Object.create(), because some VMs prevent setting line/column otherwise\n    // (iOS Safari 10 even throws an exception)\n    const error = Object.create(SyntaxError.prototype);\n    const errorStack = new Error();\n\n    return Object.assign(error, {\n        name,\n        message,\n        get stack() {\n            return (errorStack.stack || '').replace(/^(.+\\n){1,3}/, `${name}: ${message}\\n`);\n        }\n    });\n};\n", "import { createCustomError } from '../utils/create-custom-error.js';\n\nconst MAX_LINE_LENGTH = 100;\nconst OFFSET_CORRECTION = 60;\nconst TAB_REPLACEMENT = '    ';\n\nfunction sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {\n    function processLines(start, end) {\n        return lines\n            .slice(start, end)\n            .map((line, idx) =>\n                String(start + idx + 1).padStart(maxNumLength) + ' |' + line\n            ).join('\\n');\n    }\n\n    const prelines = '\\n'.repeat(Math.max(baseLine - 1, 0));\n    const precolumns = ' '.repeat(Math.max(baseColumn - 1, 0));\n    const lines = (prelines + precolumns + source).split(/\\r\\n?|\\n|\\f/);\n    const startLine = Math.max(1, line - extraLines) - 1;\n    const endLine = Math.min(line + extraLines, lines.length + 1);\n    const maxNumLength = Math.max(4, String(endLine).length) + 1;\n    let cutLeft = 0;\n\n    // column correction according to replaced tab before column\n    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n    if (column > MAX_LINE_LENGTH) {\n        cutLeft = column - OFFSET_CORRECTION + 3;\n        column = OFFSET_CORRECTION - 2;\n    }\n\n    for (let i = startLine; i <= endLine; i++) {\n        if (i >= 0 && i < lines.length) {\n            lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n            lines[i] =\n                (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n        }\n    }\n\n    return [\n        processLines(startLine, line),\n        new Array(column + maxNumLength + 2).join('-') + '^',\n        processLines(line, endLine)\n    ].filter(Boolean)\n        .join('\\n')\n        .replace(/^(\\s+\\d+\\s+\\|\\n)+/, '')\n        .replace(/\\n(\\s+\\d+\\s+\\|)+$/, '');\n}\n\nexport function SyntaxError(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {\n    const error = Object.assign(createCustomError('SyntaxError', message), {\n        source,\n        offset,\n        line,\n        column,\n        sourceFragment(extraLines) {\n            return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);\n        },\n        get formattedMessage() {\n            return (\n                `Parse error: ${message}\\n` +\n                sourceFragment({ source, line, column, baseLine, baseColumn }, 2)\n            );\n        }\n    });\n\n    return error;\n}\n", "import { WhiteSpace, Comment } from '../tokenizer/index.js';\n\nexport function readSequence(recognizer) {\n    const children = this.createList();\n    let space = false;\n    const context = {\n        recognizer\n    };\n\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case Comment:\n                this.next();\n                continue;\n\n            case WhiteSpace:\n                space = true;\n                this.next();\n                continue;\n        }\n\n        let child = recognizer.getNode.call(this, context);\n\n        if (child === undefined) {\n            break;\n        }\n\n        if (space) {\n            if (recognizer.onWhiteSpace) {\n                recognizer.onWhiteSpace.call(this, child, children, context);\n            }\n            space = false;\n        }\n\n        children.push(child);\n    }\n\n    if (space && recognizer.onWhiteSpace) {\n        recognizer.onWhiteSpace.call(this, null, children, context);\n    }\n\n    return children;\n};\n", "import { List } from '../utils/List.js';\nimport { SyntaxError } from './SyntaxError.js';\nimport {\n    tokenize,\n    OffsetToLocation,\n    TokenStream,\n    tokenNames,\n\n    consumeNumber,\n    findWhiteSpaceStart,\n    cmpChar,\n    cmpStr,\n\n    WhiteSpace,\n    Comment,\n    Ident,\n    Function as FunctionToken,\n    Url,\n    Hash,\n    Percentage,\n    Number as NumberToken\n} from '../tokenizer/index.js';\nimport { readSequence } from './sequence.js';\n\nconst NOOP = () => {};\nconst EXCLAMATIONMARK = 0x0021;  // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;       // U+0023 NUMBER SIGN (#)\nconst SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)\nconst LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)\nconst NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction fetchParseValues(dict) {\n    const result = Object.create(null);\n\n    for (const name of Object.keys(dict)) {\n        const item = dict[name];\n        const fn = item.parse || item;\n\n        if (fn) {\n            result[name] = fn;\n        }\n    }\n\n    return result;\n}\n\nfunction processConfig(config) {\n    const parseConfig = {\n        context: Object.create(null),\n        features: Object.assign(Object.create(null), config.features),\n        scope: Object.assign(Object.create(null), config.scope),\n        atrule: fetchParseValues(config.atrule),\n        pseudo: fetchParseValues(config.pseudo),\n        node: fetchParseValues(config.node)\n    };\n\n    for (const [name, context] of Object.entries(config.parseContext)) {\n        switch (typeof context) {\n            case 'function':\n                parseConfig.context[name] = context;\n                break;\n\n            case 'string':\n                parseConfig.context[name] = createParseContext(context);\n                break;\n        }\n    }\n\n    return {\n        config: parseConfig,\n        ...parseConfig,\n        ...parseConfig.node\n    };\n}\n\nexport function createParser(config) {\n    let source = '';\n    let filename = '<unknown>';\n    let needPositions = false;\n    let onParseError = NOOP;\n    let onParseErrorThrow = false;\n\n    const locationMap = new OffsetToLocation();\n    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence,\n\n        consumeUntilBalanceEnd: () => 0,\n        consumeUntilLeftCurlyBracket(code) {\n            return code === LEFTCURLYBRACKET ? 1 : 0;\n        },\n        consumeUntilLeftCurlyBracketOrSemicolon(code) {\n            return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilExclamationMarkOrSemicolon(code) {\n            return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilSemicolonIncluded(code) {\n            return code === SEMICOLON ? 2 : 0;\n        },\n\n        createList() {\n            return new List();\n        },\n        createSingleNodeList(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode(list) {\n            return list && list.first;\n        },\n        getLastListNode(list) {\n            return list && list.last;\n        },\n\n        parseWithFallback(consumer, fallback) {\n            const startIndex = this.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (onParseErrorThrow) {\n                    throw e;\n                }\n\n                this.skip(startIndex - this.tokenIndex);\n                const fallbackNode = fallback.call(this);\n\n                onParseErrorThrow = true;\n                onParseError(e, fallbackNode);\n                onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType(offset) {\n            let type;\n\n            do {\n                type = this.lookupType(offset++);\n                if (type !== WhiteSpace && type !== Comment) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        charCodeAt(offset) {\n            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;\n        },\n        substring(offsetStart, offsetEnd) {\n            return source.substring(offsetStart, offsetEnd);\n        },\n        substrToCursor(start) {\n            return this.source.substring(start, this.tokenStart);\n        },\n\n        cmpChar(offset, charCode) {\n            return cmpChar(source, offset, charCode);\n        },\n        cmpStr(offsetStart, offsetEnd, str) {\n            return cmpStr(source, offsetStart, offsetEnd, str);\n        },\n\n        consume(tokenType) {\n            const start = this.tokenStart;\n\n            this.eat(tokenType);\n\n            return this.substrToCursor(start);\n        },\n        consumeFunctionName() {\n            const name = source.substring(this.tokenStart, this.tokenEnd - 1);\n\n            this.eat(FunctionToken);\n\n            return name;\n        },\n        consumeNumber(type) {\n            const number = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));\n\n            this.eat(type);\n\n            return number;\n        },\n\n        eat(tokenType) {\n            if (this.tokenType !== tokenType) {\n                const tokenName = tokenNames[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());\n                let message = `${/[[\\](){}]/.test(tokenName) ? `\"${tokenName}\"` : tokenName} is expected`;\n                let offset = this.tokenStart;\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case Ident:\n                        // when identifier is expected but there is a function or url\n                        if (this.tokenType === FunctionToken || this.tokenType === Url) {\n                            offset = this.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case Hash:\n                        if (this.isDelim(NUMBERSIGN)) {\n                            this.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case Percentage:\n                        if (this.tokenType === NumberToken) {\n                            offset = this.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n                }\n\n                this.error(message, offset);\n            }\n\n            this.next();\n        },\n        eatIdent(name) {\n            if (this.tokenType !== Ident || this.lookupValue(0, name) === false) {\n                this.error(`Identifier \"${name}\" is expected`);\n            }\n\n            this.next();\n        },\n        eatDelim(code) {\n            if (!this.isDelim(code)) {\n                this.error(`Delim \"${String.fromCharCode(code)}\" is expected`);\n            }\n\n            this.next();\n        },\n\n        getLocation(start, end) {\n            if (needPositions) {\n                return locationMap.getLocationRange(\n                    start,\n                    end,\n                    filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList(list) {\n            if (needPositions) {\n                const head = this.getFirstListNode(list);\n                const tail = this.getLastListNode(list);\n                return locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,\n                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,\n                    filename\n                );\n            }\n\n            return null;\n        },\n\n        error(message, offset) {\n            const location = typeof offset !== 'undefined' && offset < source.length\n                ? locationMap.getLocation(offset)\n                : this.eof\n                    ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1))\n                    : locationMap.getLocation(this.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                source,\n                location.offset,\n                location.line,\n                location.column,\n                locationMap.startLine,\n                locationMap.startColumn\n            );\n        }\n    });\n\n    const parse = function(source_, options) {\n        source = source_;\n        options = options || {};\n\n        parser.setSource(source, tokenize);\n        locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        filename = options.filename || '<unknown>';\n        needPositions = Boolean(options.positions);\n        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;\n        onParseErrorThrow = false;\n\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        const { context = 'default', onComment } = options;\n\n        if (context in parser.context === false) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.forEachToken((type, start, end) => {\n                if (type === Comment) {\n                    const loc = parser.getLocation(start, end);\n                    const value = cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        const ast = parser.context[context].call(parser, options);\n\n        if (!parser.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n\n    return Object.assign(parse, {\n        SyntaxError,\n        config: parser.config\n    });\n};\n", "import { SourceMapGenerator } from 'source-map-js/lib/source-map-generator.js';\n\nconst trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);\n\nexport function generateSourceMap(handlers) {\n    const map = new SourceMapGenerator();\n    const generated = {\n        line: 1,\n        column: 0\n    };\n    const original = {\n        line: 0, // should be zero to add first mapping\n        column: 0\n    };\n    const activatedGenerated = {\n        line: 1,\n        column: 0\n    };\n    const activatedMapping = {\n        generated: activatedGenerated\n    };\n    let line = 1;\n    let column = 0;\n    let sourceMappingActive = false;\n\n    const origHandlersNode = handlers.node;\n    handlers.node = function(node) {\n        if (node.loc && node.loc.start && trackNodes.has(node.type)) {\n            const nodeLine = node.loc.start.line;\n            const nodeColumn = node.loc.start.column - 1;\n\n            if (original.line !== nodeLine ||\n                original.column !== nodeColumn) {\n                original.line = nodeLine;\n                original.column = nodeColumn;\n\n                generated.line = line;\n                generated.column = column;\n\n                if (sourceMappingActive) {\n                    sourceMappingActive = false;\n                    if (generated.line !== activatedGenerated.line ||\n                        generated.column !== activatedGenerated.column) {\n                        map.addMapping(activatedMapping);\n                    }\n                }\n\n                sourceMappingActive = true;\n                map.addMapping({\n                    source: node.loc.source,\n                    original,\n                    generated\n                });\n            }\n        }\n\n        origHandlersNode.call(this, node);\n\n        if (sourceMappingActive && trackNodes.has(node.type)) {\n            activatedGenerated.line = line;\n            activatedGenerated.column = column;\n        }\n    };\n\n    const origHandlersEmit = handlers.emit;\n    handlers.emit = function(value, type, auto) {\n        for (let i = 0; i < value.length; i++) {\n            if (value.charCodeAt(i) === 10) { // \\n\n                line++;\n                column = 0;\n            } else {\n                column++;\n            }\n        }\n\n        origHandlersEmit(value, type, auto);\n    };\n\n    const origHandlersResult = handlers.result;\n    handlers.result = function() {\n        if (sourceMappingActive) {\n            map.addMapping(activatedMapping);\n        }\n\n        return {\n            css: origHandlersResult(),\n            map\n        };\n    };\n\n    return handlers;\n};\n", "import {\n    WhiteSpace,\n    Delim,\n    Ident,\n    Function as FunctionToken,\n    Url,\n    BadUrl,\n    AtKeyword,\n    Hash,\n    Percentage,\n    Dimension,\n    Number as NumberToken,\n    String as StringToken,\n    Colon,\n    LeftParenthesis,\n    RightParenthesis,\n    CDC\n} from '../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\n\nconst code = (type, value) => {\n    if (type === Delim) {\n        type = value;\n    }\n\n    if (typeof type === 'string') {\n        const charCode = type.charCodeAt(0);\n        return charCode > 0x7F ? 0x8000 : charCode << 8;\n    }\n\n    return type;\n};\n\n// https://www.w3.org/TR/css-syntax-3/#serialization\n// The only requirement for serialization is that it must \"round-trip\" with parsing,\n// that is, parsing the stylesheet must produce the same data structures as parsing,\n// serializing, and parsing again, except for consecutive <whitespace-token>s,\n// which may be collapsed into a single token.\n\nconst specPairs = [\n    [Ident, Ident],\n    [Ident, FunctionToken],\n    [Ident, Url],\n    [Ident, BadUrl],\n    [Ident, '-'],\n    [Ident, NumberToken],\n    [Ident, Percentage],\n    [Ident, Dimension],\n    [Ident, CDC],\n    [Ident, LeftParenthesis],\n\n    [AtKeyword, Ident],\n    [AtKeyword, FunctionToken],\n    [AtKeyword, Url],\n    [AtKeyword, BadUrl],\n    [AtKeyword, '-'],\n    [AtKeyword, NumberToken],\n    [AtKeyword, Percentage],\n    [AtKeyword, Dimension],\n    [AtKeyword, CDC],\n\n    [Hash, Ident],\n    [Hash, FunctionToken],\n    [Hash, Url],\n    [Hash, BadUrl],\n    [Hash, '-'],\n    [Hash, NumberToken],\n    [Hash, Percentage],\n    [Hash, Dimension],\n    [Hash, CDC],\n\n    [Dimension, Ident],\n    [Dimension, FunctionToken],\n    [Dimension, Url],\n    [Dimension, BadUrl],\n    [Dimension, '-'],\n    [Dimension, NumberToken],\n    [Dimension, Percentage],\n    [Dimension, Dimension],\n    [Dimension, CDC],\n\n    ['#', Ident],\n    ['#', FunctionToken],\n    ['#', Url],\n    ['#', BadUrl],\n    ['#', '-'],\n    ['#', NumberToken],\n    ['#', Percentage],\n    ['#', Dimension],\n    ['#', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['-', Ident],\n    ['-', FunctionToken],\n    ['-', Url],\n    ['-', BadUrl],\n    ['-', '-'],\n    ['-', NumberToken],\n    ['-', Percentage],\n    ['-', Dimension],\n    ['-', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    [NumberToken, Ident],\n    [NumberToken, FunctionToken],\n    [NumberToken, Url],\n    [NumberToken, BadUrl],\n    [NumberToken, NumberToken],\n    [NumberToken, Percentage],\n    [NumberToken, Dimension],\n    [NumberToken, '%'],\n    [NumberToken, CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['@', Ident],\n    ['@', FunctionToken],\n    ['@', Url],\n    ['@', BadUrl],\n    ['@', '-'],\n    ['@', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['.', NumberToken],\n    ['.', Percentage],\n    ['.', Dimension],\n\n    ['+', NumberToken],\n    ['+', Percentage],\n    ['+', Dimension],\n\n    ['/', '*']\n];\n// validate with scripts/generate-safe\nconst safePairs = specPairs.concat([\n    [Ident, Hash],\n\n    [Dimension, Hash],\n\n    [Hash, Hash],\n\n    [AtKeyword, LeftParenthesis],\n    [AtKeyword, StringToken],\n    [AtKeyword, Colon],\n\n    [Percentage, Percentage],\n    [Percentage, Dimension],\n    [Percentage, FunctionToken],\n    [Percentage, '-'],\n\n    [RightParenthesis, Ident],\n    [RightParenthesis, FunctionToken],\n    [RightParenthesis, Percentage],\n    [RightParenthesis, Dimension],\n    [RightParenthesis, Hash],\n    [RightParenthesis, '-']\n]);\n\nfunction createMap(pairs) {\n    const isWhiteSpaceRequired = new Set(\n        pairs.map(([prev, next]) => (code(prev) << 16 | code(next)))\n    );\n\n    return function(prevCode, type, value) {\n        const nextCode = code(type, value);\n        const nextCharCode = value.charCodeAt(0);\n        const emitWs =\n            (nextCharCode === HYPHENMINUS &&\n                type !== Ident &&\n                type !== FunctionToken &&\n                type !== CDC) ||\n            (nextCharCode === PLUSSIGN)\n                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)\n                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);\n\n        if (emitWs) {\n            this.emit(' ', WhiteSpace, true);\n        }\n\n        return nextCode;\n    };\n}\n\nexport const spec = createMap(specPairs);\nexport const safe = createMap(safePairs);\n", "import { tokenize, Delim, WhiteSpace } from '../tokenizer/index.js';\nimport { generateSourceMap } from './sourceMap.js';\nimport * as tokenBefore from './token-before.js';\n\nconst REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\n\nfunction processChildren(node, delimeter) {\n    if (typeof delimeter === 'function') {\n        let prev = null;\n\n        node.children.forEach(node => {\n            if (prev !== null) {\n                delimeter.call(this, prev);\n            }\n\n            this.node(node);\n            prev = node;\n        });\n\n        return;\n    }\n\n    node.children.forEach(this.node, this);\n}\n\nfunction processChunk(chunk) {\n    tokenize(chunk, (type, start, end) => {\n        this.token(type, chunk.slice(start, end));\n    });\n}\n\nexport function createGenerator(config) {\n    const types = new Map();\n\n    for (let [name, item] of Object.entries(config.node)) {\n        const fn = item.generate || item;\n\n        if (typeof fn === 'function') {\n            types.set(name, item.generate || item);\n        }\n    }\n\n    return function(node, options) {\n        let buffer = '';\n        let prevCode = 0;\n        let handlers = {\n            node(node) {\n                if (types.has(node.type)) {\n                    types.get(node.type).call(publicApi, node);\n                } else {\n                    throw new Error('Unknown node type: ' + node.type);\n                }\n            },\n            tokenBefore: tokenBefore.safe,\n            token(type, value) {\n                prevCode = this.tokenBefore(prevCode, type, value);\n\n                this.emit(value, type, false);\n\n                if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {\n                    this.emit('\\n', WhiteSpace, true);\n                }\n            },\n            emit(value) {\n                buffer += value;\n            },\n            result() {\n                return buffer;\n            }\n        };\n\n        if (options) {\n            if (typeof options.decorator === 'function') {\n                handlers = options.decorator(handlers);\n            }\n\n            if (options.sourceMap) {\n                handlers = generateSourceMap(handlers);\n            }\n\n            if (options.mode in tokenBefore) {\n                handlers.tokenBefore = tokenBefore[options.mode];\n            }\n        }\n\n        const publicApi = {\n            node: (node) => handlers.node(node),\n            children: processChildren,\n            token: (type, value) => handlers.token(type, value),\n            tokenize: processChunk\n        };\n\n        handlers.node(node);\n\n        return handlers.result();\n    };\n};\n", "import { List } from '../utils/List.js';\n\nexport function createConvertor(walk) {\n    return {\n        fromPlainObject(ast) {\n            walk(ast, {\n                enter(node) {\n                    if (node.children && node.children instanceof List === false) {\n                        node.children = new List().fromArray(node.children);\n                    }\n                }\n            });\n\n            return ast;\n        },\n        toPlainObject(ast) {\n            walk(ast, {\n                leave(node) {\n                    if (node.children && node.children instanceof List) {\n                        node.children = node.children.toArray();\n                    }\n                }\n            });\n\n            return ast;\n        }\n    };\n};\n", "const { hasOwnProperty } = Object.prototype;\nconst noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nfunction invokeForType(fn, type) {\n    return function(node, item, list) {\n        if (node.type === type) {\n            fn.call(this, node, item, list);\n        }\n    };\n}\n\nfunction getWalkersFromStructure(name, nodeType) {\n    const structure = nodeType.structure;\n    const walkers = [];\n\n    for (const key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        let fieldTypes = structure[key];\n        const walker = {\n            name: key,\n            type: false,\n            nullable: false\n        };\n\n        if (!Array.isArray(fieldTypes)) {\n            fieldTypes = [fieldTypes];\n        }\n\n        for (const fieldType of fieldTypes) {\n            if (fieldType === null) {\n                walker.nullable = true;\n            } else if (typeof fieldType === 'string') {\n                walker.type = 'node';\n            } else if (Array.isArray(fieldType)) {\n                walker.type = 'list';\n            }\n        }\n\n        if (walker.type) {\n            walkers.push(walker);\n        }\n    }\n\n    if (walkers.length) {\n        return {\n            context: nodeType.walkContext,\n            fields: walkers\n        };\n    }\n\n    return null;\n}\n\nfunction getTypesFromConfig(config) {\n    const types = {};\n\n    for (const name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n            const nodeType = config.node[name];\n\n            if (!nodeType.structure) {\n                throw new Error('Missed `structure` field in `' + name + '` node type definition');\n            }\n\n            types[name] = getWalkersFromStructure(name, nodeType);\n        }\n    }\n\n    return types;\n}\n\nfunction createTypeIterator(config, reverse) {\n    const fields = config.fields.slice();\n    const contextName = config.context;\n    const useContext = typeof contextName === 'string';\n\n    if (reverse) {\n        fields.reverse();\n    }\n\n    return function(node, context, walk, walkReducer) {\n        let prevContextValue;\n\n        if (useContext) {\n            prevContextValue = context[contextName];\n            context[contextName] = node;\n        }\n\n        for (const field of fields) {\n            const ref = node[field.name];\n\n            if (!field.nullable || ref) {\n                if (field.type === 'list') {\n                    const breakWalk = reverse\n                        ? ref.reduceRight(walkReducer, false)\n                        : ref.reduce(walkReducer, false);\n\n                    if (breakWalk) {\n                        return true;\n                    }\n                } else if (walk(ref)) {\n                    return true;\n                }\n            }\n        }\n\n        if (useContext) {\n            context[contextName] = prevContextValue;\n        }\n    };\n}\n\nfunction createFastTraveralMap({\n    StyleSheet,\n    Atrule,\n    Rule,\n    Block,\n    DeclarationList\n}) {\n    return {\n        Atrule: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block\n        },\n        Rule: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block\n        },\n        Declaration: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block,\n            DeclarationList\n        }\n    };\n}\n\nexport function createWalker(config) {\n    const types = getTypesFromConfig(config);\n    const iteratorsNatural = {};\n    const iteratorsReverse = {};\n    const breakWalk = Symbol('break-walk');\n    const skipNode = Symbol('skip-node');\n\n    for (const name in types) {\n        if (hasOwnProperty.call(types, name) && types[name] !== null) {\n            iteratorsNatural[name] = createTypeIterator(types[name], false);\n            iteratorsReverse[name] = createTypeIterator(types[name], true);\n        }\n    }\n\n    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n\n    const walk = function(root, options) {\n        function walkNode(node, item, list) {\n            const enterRet = enter.call(context, node, item, list);\n\n            if (enterRet === breakWalk) {\n                return true;\n            }\n\n            if (enterRet === skipNode) {\n                return false;\n            }\n\n            if (iterators.hasOwnProperty(node.type)) {\n                if (iterators[node.type](node, context, walkNode, walkReducer)) {\n                    return true;\n                }\n            }\n\n            if (leave.call(context, node, item, list) === breakWalk) {\n                return true;\n            }\n\n            return false;\n        }\n\n        let enter = noop;\n        let leave = noop;\n        let iterators = iteratorsNatural;\n        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);\n        const context = {\n            break: breakWalk,\n            skip: skipNode,\n\n            root,\n            stylesheet: null,\n            atrule: null,\n            atrulePrelude: null,\n            rule: null,\n            selector: null,\n            block: null,\n            declaration: null,\n            function: null\n        };\n\n        if (typeof options === 'function') {\n            enter = options;\n        } else if (options) {\n            enter = ensureFunction(options.enter);\n            leave = ensureFunction(options.leave);\n\n            if (options.reverse) {\n                iterators = iteratorsReverse;\n            }\n\n            if (options.visit) {\n                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n                    iterators = options.reverse\n                        ? fastTraversalIteratorsReverse[options.visit]\n                        : fastTraversalIteratorsNatural[options.visit];\n                } else if (!types.hasOwnProperty(options.visit)) {\n                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');\n                }\n\n                enter = invokeForType(enter, options.visit);\n                leave = invokeForType(leave, options.visit);\n            }\n        }\n\n        if (enter === noop && leave === noop) {\n            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n        }\n\n        walkNode(root);\n    };\n\n    walk.break = breakWalk;\n    walk.skip = skipNode;\n\n    walk.find = function(ast, fn) {\n        let found = null;\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found = node;\n                return breakWalk;\n            }\n        });\n\n        return found;\n    };\n\n    walk.findLast = function(ast, fn) {\n        let found = null;\n\n        walk(ast, {\n            reverse: true,\n            enter(node, item, list) {\n                if (fn.call(this, node, item, list)) {\n                    found = node;\n                    return breakWalk;\n                }\n            }\n        });\n\n        return found;\n    };\n\n    walk.findAll = function(ast, fn) {\n        const found = [];\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found.push(node);\n            }\n        });\n\n        return found;\n    };\n\n    return walk;\n};\n", "function noop(value) {\n    return value;\n}\n\nfunction generateMultiplier(multiplier) {\n    const { min, max, comma } = multiplier;\n\n    if (min === 0 && max === 0) {\n        return comma ? '#?' : '*';\n    }\n\n    if (min === 0 && max === 1) {\n        return '?';\n    }\n\n    if (min === 1 && max === 0) {\n        return comma ? '#' : '+';\n    }\n\n    if (min === 1 && max === 1) {\n        return '';\n    }\n\n    return (\n        (comma ? '#' : '') +\n        (min === max\n            ? '{' + min + '}'\n            : '{' + min + ',' + (max !== 0 ? max : '') + '}'\n        )\n    );\n}\n\nfunction generateTypeOpts(node) {\n    switch (node.type) {\n        case 'Range':\n            return (\n                ' [' +\n                (node.min === null ? '-\u221E' : node.min) +\n                ',' +\n                (node.max === null ? '\u221E' : node.max) +\n                ']'\n            );\n\n        default:\n            throw new Error('Unknown node type `' + node.type + '`');\n    }\n}\n\nfunction generateSequence(node, decorate, forceBraces, compact) {\n    const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';\n    const result = node.terms\n        .map(term => internalGenerate(term, decorate, forceBraces, compact))\n        .join(combinator);\n\n    if (node.explicit || forceBraces) {\n        return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');\n    }\n\n    return result;\n}\n\nfunction internalGenerate(node, decorate, forceBraces, compact) {\n    let result;\n\n    switch (node.type) {\n        case 'Group':\n            result =\n                generateSequence(node, decorate, forceBraces, compact) +\n                (node.disallowEmpty ? '!' : '');\n            break;\n\n        case 'Multiplier':\n            // return since node is a composition\n            return (\n                internalGenerate(node.term, decorate, forceBraces, compact) +\n                decorate(generateMultiplier(node), node)\n            );\n\n        case 'Boolean':\n            result = '<boolean-expr[' + internalGenerate(node.term, decorate, forceBraces, compact) + ']>';\n            break;\n\n        case 'Type':\n            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';\n            break;\n\n        case 'Property':\n            result = '<\\'' + node.name + '\\'>';\n            break;\n\n        case 'Keyword':\n            result = node.name;\n            break;\n\n        case 'AtKeyword':\n            result = '@' + node.name;\n            break;\n\n        case 'Function':\n            result = node.name + '(';\n            break;\n\n        case 'String':\n        case 'Token':\n            result = node.value;\n            break;\n\n        case 'Comma':\n            result = ',';\n            break;\n\n        default:\n            throw new Error('Unknown node type `' + node.type + '`');\n    }\n\n    return decorate(result, node);\n}\n\nexport function generate(node, options) {\n    let decorate = noop;\n    let forceBraces = false;\n    let compact = false;\n\n    if (typeof options === 'function') {\n        decorate = options;\n    } else if (options) {\n        forceBraces = Boolean(options.forceBraces);\n        compact = Boolean(options.compact);\n        if (typeof options.decorate === 'function') {\n            decorate = options.decorate;\n        }\n    }\n\n    return internalGenerate(node, decorate, forceBraces, compact);\n};\n", "import { createCustomError } from '../utils/create-custom-error.js';\nimport { generate } from '../definition-syntax/generate.js';\n\nconst defaultLoc = { offset: 0, line: 1, column: 1 };\n\nfunction locateMismatch(matchResult, node) {\n    const tokens = matchResult.tokens;\n    const longestMatch = matchResult.longestMatch;\n    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n    const badNode = mismatchNode !== node ? mismatchNode : null;\n    let mismatchOffset = 0;\n    let mismatchLength = 0;\n    let entries = 0;\n    let css = '';\n    let start;\n    let end;\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i].value;\n\n        if (i === longestMatch) {\n            mismatchLength = token.length;\n            mismatchOffset = css.length;\n        }\n\n        if (badNode !== null && tokens[i].node === badNode) {\n            if (i <= longestMatch) {\n                entries++;\n            } else {\n                entries = 0;\n            }\n        }\n\n        css += token;\n    }\n\n    if (longestMatch === tokens.length || entries > 1) { // last\n        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n        end = buildLoc(start);\n    } else {\n        start = fromLoc(badNode, 'start') ||\n            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n        end = fromLoc(badNode, 'end') ||\n            buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n    }\n\n    return {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    };\n}\n\nfunction fromLoc(node, point) {\n    const value = node && node.loc && node.loc[point];\n\n    if (value) {\n        return 'line' in value ? buildLoc(value) : value;\n    }\n\n    return null;\n}\n\nfunction buildLoc({ offset, line, column }, extra) {\n    const loc = {\n        offset,\n        line,\n        column\n    };\n\n    if (extra) {\n        const lines = extra.split(/\\n|\\r\\n?|\\f/);\n\n        loc.offset += extra.length;\n        loc.line += lines.length - 1;\n        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n    }\n\n    return loc;\n}\n\nexport const SyntaxReferenceError = function(type, referenceName) {\n    const error = createCustomError(\n        'SyntaxReferenceError',\n        type + (referenceName ? ' `' + referenceName + '`' : '')\n    );\n\n    error.reference = referenceName;\n\n    return error;\n};\n\nexport const SyntaxMatchError = function(message, syntax, node, matchResult) {\n    const error = createCustomError('SyntaxMatchError', message);\n    const {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    } = locateMismatch(matchResult, node);\n\n    error.rawMessage = message;\n    error.syntax = syntax ? generate(syntax) : '<generic>';\n    error.css = css;\n    error.mismatchOffset = mismatchOffset;\n    error.mismatchLength = mismatchLength;\n    error.message = message + '\\n' +\n        '  syntax: ' + error.syntax + '\\n' +\n        '   value: ' + (css || '<empty string>') + '\\n' +\n        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n    Object.assign(error, start);\n    error.loc = {\n        source: (node && node.loc && node.loc.source) || '<unknown>',\n        start,\n        end\n    };\n\n    return error;\n};\n", "const keywords = new Map();\nconst properties = new Map();\nconst HYPHENMINUS = 45; // '-'.charCodeAt()\n\nexport const keyword = getKeywordDescriptor;\nexport const property = getPropertyDescriptor;\nexport const vendorPrefix = getVendorPrefix;\nexport function isCustomProperty(str, offset) {\n    offset = offset || 0;\n\n    return str.length - offset >= 2 &&\n           str.charCodeAt(offset) === HYPHENMINUS &&\n           str.charCodeAt(offset + 1) === HYPHENMINUS;\n}\n\nfunction getVendorPrefix(str, offset) {\n    offset = offset || 0;\n\n    // verdor prefix should be at least 3 chars length\n    if (str.length - offset >= 3) {\n        // vendor prefix starts with hyper minus following non-hyper minus\n        if (str.charCodeAt(offset) === HYPHENMINUS &&\n            str.charCodeAt(offset + 1) !== HYPHENMINUS) {\n            // vendor prefix should contain a hyper minus at the ending\n            const secondDashIndex = str.indexOf('-', offset + 2);\n\n            if (secondDashIndex !== -1) {\n                return str.substring(offset, secondDashIndex + 1);\n            }\n        }\n    }\n\n    return '';\n}\n\nfunction getKeywordDescriptor(keyword) {\n    if (keywords.has(keyword)) {\n        return keywords.get(keyword);\n    }\n\n    const name = keyword.toLowerCase();\n    let descriptor = keywords.get(name);\n\n    if (descriptor === undefined) {\n        const custom = isCustomProperty(name, 0);\n        const vendor = !custom ? getVendorPrefix(name, 0) : '';\n        descriptor = Object.freeze({\n            basename: name.substr(vendor.length),\n            name,\n            prefix: vendor,\n            vendor,\n            custom\n        });\n    }\n\n    keywords.set(keyword, descriptor);\n\n    return descriptor;\n}\n\nfunction getPropertyDescriptor(property) {\n    if (properties.has(property)) {\n        return properties.get(property);\n    }\n\n    let name = property;\n    let hack = property[0];\n\n    if (hack === '/') {\n        hack = property[1] === '/' ? '//' : '/';\n    } else if (hack !== '_' &&\n               hack !== '*' &&\n               hack !== '$' &&\n               hack !== '#' &&\n               hack !== '+' &&\n               hack !== '&') {\n        hack = '';\n    }\n\n    const custom = isCustomProperty(name, hack.length);\n\n    // re-use result when possible (the same as for lower case)\n    if (!custom) {\n        name = name.toLowerCase();\n        if (properties.has(name)) {\n            const descriptor = properties.get(name);\n            properties.set(property, descriptor);\n            return descriptor;\n        }\n    }\n\n    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';\n    const prefix = name.substr(0, hack.length + vendor.length);\n    const descriptor = Object.freeze({\n        basename: name.substr(prefix.length),\n        name: name.substr(hack.length),\n        hack,\n        vendor,\n        prefix,\n        custom\n    });\n\n    properties.set(property, descriptor);\n\n    return descriptor;\n}\n", "// https://drafts.csswg.org/css-cascade-5/\nexport const cssWideKeywords = [\n    'initial',\n    'inherit',\n    'unset',\n    'revert',\n    'revert-layer'\n];\n", "import {\n    isDigit,\n    cmpChar,\n    Delim,\n    WhiteSpace,\n    Comment,\n    Ident,\n    Number as NumberToken,\n    Dimension\n} from '../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\n\nfunction isDelim(token, code) {\n    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code;\n}\n\nfunction skipSC(token, offset, getNextToken) {\n    while (token !== null && (token.type === WhiteSpace || token.type === Comment)) {\n        token = getNextToken(++offset);\n    }\n\n    return offset;\n}\n\nfunction checkInteger(token, valueOffset, disallowSign, offset) {\n    if (!token) {\n        return 0;\n    }\n\n    const code = token.value.charCodeAt(valueOffset);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            // Number sign is not allowed\n            return 0;\n        }\n        valueOffset++;\n    }\n\n    for (; valueOffset < token.value.length; valueOffset++) {\n        if (!isDigit(token.value.charCodeAt(valueOffset))) {\n            // Integer is expected\n            return 0;\n        }\n    }\n\n    return offset + 1;\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB(token, offset_, getNextToken) {\n    let sign = false;\n    let offset = skipSC(token, offset_, getNextToken);\n\n    token = getNextToken(offset);\n\n    if (token === null) {\n        return offset_;\n    }\n\n    if (token.type !== NumberToken) {\n        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {\n            sign = true;\n            offset = skipSC(getNextToken(++offset), offset, getNextToken);\n            token = getNextToken(offset);\n\n            if (token === null || token.type !== NumberToken) {\n                return 0;\n            }\n        } else {\n            return offset_;\n        }\n    }\n\n    if (!sign) {\n        const code = token.value.charCodeAt(0);\n        if (code !== PLUSSIGN && code !== HYPHENMINUS) {\n            // Number sign is expected\n            return 0;\n        }\n    }\n\n    return checkInteger(token, sign ? 0 : 1, sign, offset);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nexport default function anPlusB(token, getNextToken) {\n    /* eslint-disable brace-style*/\n    let offset = 0;\n\n    if (!token) {\n        return 0;\n    }\n\n    // <integer>\n    if (token.type === NumberToken) {\n        return checkInteger(token, 0, ALLOW_SIGN, offset); // b\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS) {\n        // expect 1st char is N\n        if (!cmpChar(token.value, 1, N)) {\n            return 0;\n        }\n\n        switch (token.value.length) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n\n            // -n- <signless-integer>\n            case 3:\n                if (token.value.charCodeAt(2) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n            // <dashndashdigit-ident>\n            default:\n                if (token.value.charCodeAt(2) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                return checkInteger(token, 3, DISALLOW_SIGN, offset);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (token.type === Ident || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === Ident)) {\n        // just ignore a plus\n        if (token.type !== Ident) {\n            token = getNextToken(++offset);\n        }\n\n        if (token === null || !cmpChar(token.value, 0, N)) {\n            return 0;\n        }\n\n        switch (token.value.length) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n\n            // '+'? n- <signless-integer>\n            case 2:\n                if (token.value.charCodeAt(1) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n            // '+'? <ndashdigit-ident>\n            default:\n                if (token.value.charCodeAt(1) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                return checkInteger(token, 2, DISALLOW_SIGN, offset);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (token.type === Dimension) {\n        let code = token.value.charCodeAt(0);\n        let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;\n        let i = sign;\n\n        for (; i < token.value.length; i++) {\n            if (!isDigit(token.value.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === sign) {\n            // Integer is expected\n            return 0;\n        }\n\n        if (!cmpChar(token.value, i, N)) {\n            return 0;\n        }\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === token.value.length) {\n            return consumeB(getNextToken(++offset), offset, getNextToken);\n        } else {\n            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {\n                return 0;\n            }\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === token.value.length) {\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n            }\n            // <ndashdigit-dimension>\n            else {\n                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);\n            }\n        }\n    }\n\n    return 0;\n};\n", "import {\n    isHexDigit,\n    cmpChar,\n    Ident,\n    Delim,\n    Number as NumberToken,\n    Dimension\n} from '../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\nconst U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)\n\nfunction isDelim(token, code) {\n    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code;\n}\n\nfunction startsWith(token, code) {\n    return token.value.charCodeAt(0) === code;\n}\n\nfunction hexSequence(token, offset, allowDash) {\n    let hexlen = 0;\n\n    for (let pos = offset; pos < token.value.length; pos++) {\n        const code = token.value.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {\n            hexSequence(token, offset + hexlen + 1, false);\n            return 6; // dissallow following question marks\n        }\n\n        if (!isHexDigit(code)) {\n            return 0; // not a hex digit\n        }\n\n        if (++hexlen > 6) {\n            return 0; // too many hex digits\n        };\n    }\n\n    return hexlen;\n}\n\nfunction withQuestionMarkSequence(consumed, length, getNextToken) {\n    if (!consumed) {\n        return 0; // nothing consumed\n    }\n\n    while (isDelim(getNextToken(length), QUESTIONMARK)) {\n        if (++consumed > 6) {\n            return 0; // too many question marks\n        }\n\n        length++;\n    }\n\n    return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nexport default function urange(token, getNextToken) {\n    let length = 0;\n\n    // should start with `u` or `U`\n    if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U)) {\n        return 0;\n    }\n\n    token = getNextToken(++length);\n    if (token === null) {\n        return 0;\n    }\n\n    // u '+' <ident-token> '?'*\n    // u '+' '?'+\n    if (isDelim(token, PLUSSIGN)) {\n        token = getNextToken(++length);\n        if (token === null) {\n            return 0;\n        }\n\n        if (token.type === Ident) {\n            // u '+' <ident-token> '?'*\n            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);\n        }\n\n        if (isDelim(token, QUESTIONMARK)) {\n            // u '+' '?'+\n            return withQuestionMarkSequence(1, ++length, getNextToken);\n        }\n\n        // Hex digit or question mark is expected\n        return 0;\n    }\n\n    // u <number-token> '?'*\n    // u <number-token> <dimension-token>\n    // u <number-token> <number-token>\n    if (token.type === NumberToken) {\n        const consumedHexLength = hexSequence(token, 1, true);\n        if (consumedHexLength === 0) {\n            return 0;\n        }\n\n        token = getNextToken(++length);\n        if (token === null) {\n            // u <number-token> <eof>\n            return length;\n        }\n\n        if (token.type === Dimension || token.type === NumberToken) {\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {\n                return 0;\n            }\n\n            return length + 1;\n        }\n\n        // u <number-token> '?'*\n        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);\n    }\n\n    // u <dimension-token> '?'*\n    if (token.type === Dimension) {\n        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);\n    }\n\n    return 0;\n};\n", "import { cssWideKeywords } from './generic-const.js';\nimport anPlusB from './generic-an-plus-b.js';\nimport urange from './generic-urange.js';\nimport {\n    isIdentifierStart,\n    isHexDigit,\n    isDigit,\n    cmpStr,\n    consumeNumber,\n\n    Ident,\n    Function as FunctionToken,\n    AtKeyword,\n    Hash,\n    String as StringToken,\n    BadString,\n    Url,\n    BadUrl,\n    Delim,\n    Number as NumberToken,\n    Percentage,\n    Dimension,\n    WhiteSpace,\n    CDO,\n    CDC,\n    Colon,\n    Semicolon,\n    Comma,\n    LeftSquareBracket,\n    RightSquareBracket,\n    LeftParenthesis,\n    RightParenthesis,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from '../tokenizer/index.js';\n\nconst calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];\nconst balancePair = new Map([\n    [FunctionToken, RightParenthesis],\n    [LeftParenthesis, RightParenthesis],\n    [LeftSquareBracket, RightSquareBracket],\n    [LeftCurlyBracket, RightCurlyBracket]\n]);\n\n// safe char code getter\nfunction charCodeAt(str, index) {\n    return index < str.length ? str.charCodeAt(index) : 0;\n}\n\nfunction eqStr(actual, expected) {\n    return cmpStr(actual, 0, actual.length, expected);\n}\n\nfunction eqStrAny(actual, expected) {\n    for (let i = 0; i < expected.length; i++) {\n        if (eqStr(actual, expected[i])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// IE postfix hack, i.e. 123\\0 or 123px\\9\nfunction isPostfixIeHack(str, offset) {\n    if (offset !== str.length - 2) {\n        return false;\n    }\n\n    return (\n        charCodeAt(str, offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\\)\n        isDigit(charCodeAt(str, offset + 1))\n    );\n}\n\nfunction outOfRange(opts, value, numEnd) {\n    if (opts && opts.type === 'Range') {\n        const num = Number(\n            numEnd !== undefined && numEnd !== value.length\n                ? value.substr(0, numEnd)\n                : value\n        );\n\n        if (isNaN(num)) {\n            return true;\n        }\n\n        // FIXME: when opts.min is a string it's a dimension, skip a range validation\n        // for now since it requires a type covertation which is not implmented yet\n        if (opts.min !== null && num < opts.min && typeof opts.min !== 'string') {\n            return true;\n        }\n\n        // FIXME: when opts.max is a string it's a dimension, skip a range validation\n        // for now since it requires a type covertation which is not implmented yet\n        if (opts.max !== null && num > opts.max && typeof opts.max !== 'string') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction consumeFunction(token, getNextToken) {\n    let balanceCloseType = 0;\n    let balanceStash = [];\n    let length = 0;\n\n    // balanced token consuming\n    scan:\n    do {\n        switch (token.type) {\n            case RightCurlyBracket:\n            case RightParenthesis:\n            case RightSquareBracket:\n                if (token.type !== balanceCloseType) {\n                    break scan;\n                }\n\n                balanceCloseType = balanceStash.pop();\n\n                if (balanceStash.length === 0) {\n                    length++;\n                    break scan;\n                }\n\n                break;\n\n            case FunctionToken:\n            case LeftParenthesis:\n            case LeftSquareBracket:\n            case LeftCurlyBracket:\n                balanceStash.push(balanceCloseType);\n                balanceCloseType = balancePair.get(token.type);\n                break;\n        }\n\n        length++;\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// TODO: implement\n// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed\n// https://drafts.csswg.org/css-values/#calc-notation\nfunction calc(next) {\n    return function(token, getNextToken, opts) {\n        if (token === null) {\n            return 0;\n        }\n\n        if (token.type === FunctionToken && eqStrAny(token.value, calcFunctionNames)) {\n            return consumeFunction(token, getNextToken);\n        }\n\n        return next(token, getNextToken, opts);\n    };\n}\n\nfunction tokenType(expectedTokenType) {\n    return function(token) {\n        if (token === null || token.type !== expectedTokenType) {\n            return 0;\n        }\n\n        return 1;\n    };\n}\n\n// =========================\n// Complex types\n//\n\n// https://drafts.csswg.org/css-values-4/#custom-idents\n// 4.2. Author-defined Identifiers: the <custom-ident> type\n// Some properties accept arbitrary author-defined identifiers as a component value.\n// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier\n// that would not be misinterpreted as a pre-defined keyword in that property\u2019s value definition.\n//\n// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident\nfunction customIdent(token) {\n    if (token === null || token.type !== Ident) {\n        return 0;\n    }\n\n    const name = token.value.toLowerCase();\n\n    // The CSS-wide keywords are not valid <custom-ident>s\n    if (eqStrAny(name, cssWideKeywords)) {\n        return 0;\n    }\n\n    // The default keyword is reserved and is also not a valid <custom-ident>\n    if (eqStr(name, 'default')) {\n        return 0;\n    }\n\n    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)\n    // Specifications using <custom-ident> must specify clearly what other keywords\n    // are excluded from <custom-ident>, if any\u2014for example by saying that any pre-defined keywords\n    // in that property\u2019s value definition are excluded. Excluded keywords are excluded\n    // in all ASCII case permutations.\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-values-4/#dashed-idents\n// The <dashed-ident> production is a <custom-ident>, with all the case-sensitivity that implies,\n// with the additional restriction that it must start with two dashes (U+002D HYPHEN-MINUS).\nfunction dashedIdent(token) {\n    if (token === null || token.type !== Ident) {\n        return 0;\n    }\n\n    // ... must start with two dashes (U+002D HYPHEN-MINUS)\n    if (charCodeAt(token.value, 0) !== 0x002D || charCodeAt(token.value, 1) !== 0x002D) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-variables/#typedef-custom-property-name\n// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.\n// The <custom-property-name> production corresponds to this: it\u2019s defined as any <dashed-ident>\n// (a valid identifier that starts with two dashes), except -- itself, which is reserved for future use by CSS.\nfunction customPropertyName(token) {\n    // ... it\u2019s defined as any <dashed-ident>\n    if (!dashedIdent(token)) {\n        return 0;\n    }\n\n    // ... except -- itself, which is reserved for future use by CSS\n    if (token.value === '--') {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-color-4/#hex-notation\n// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.\n// In other words, a hex color is written as a hash character, \"#\", followed by some number of digits 0-9 or\n// letters a-f (the case of the letters doesn\u2019t matter - #00ff00 is identical to #00FF00).\nfunction hexColor(token) {\n    if (token === null || token.type !== Hash) {\n        return 0;\n    }\n\n    const length = token.value.length;\n\n    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)\n    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {\n        return 0;\n    }\n\n    for (let i = 1; i < length; i++) {\n        if (!isHexDigit(charCodeAt(token.value, i))) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nfunction idSelector(token) {\n    if (token === null || token.type !== Hash) {\n        return 0;\n    }\n\n    if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-syntax/#any-value\n// It represents the entirety of what a valid declaration can have as its value.\nfunction declarationValue(token, getNextToken) {\n    if (!token) {\n        return 0;\n    }\n\n    let balanceCloseType = 0;\n    let balanceStash = [];\n    let length = 0;\n\n    // The <declaration-value> production matches any sequence of one or more tokens,\n    // so long as the sequence does not contain ...\n    scan:\n    do {\n        switch (token.type) {\n            // ... <bad-string-token>, <bad-url-token>,\n            case BadString:\n            case BadUrl:\n                break scan;\n\n            // ... unmatched <)-token>, <]-token>, or <}-token>,\n            case RightCurlyBracket:\n            case RightParenthesis:\n            case RightSquareBracket:\n                if (token.type !== balanceCloseType) {\n                    break scan;\n                }\n\n                balanceCloseType = balanceStash.pop();\n                break;\n\n            // ... or top-level <semicolon-token> tokens\n            case Semicolon:\n                if (balanceCloseType === 0) {\n                    break scan;\n                }\n\n                break;\n\n            // ... or <delim-token> tokens with a value of \"!\"\n            case Delim:\n                if (balanceCloseType === 0 && token.value === '!') {\n                    break scan;\n                }\n\n                break;\n\n            case FunctionToken:\n            case LeftParenthesis:\n            case LeftSquareBracket:\n            case LeftCurlyBracket:\n                balanceStash.push(balanceCloseType);\n                balanceCloseType = balancePair.get(token.type);\n                break;\n        }\n\n        length++;\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#any-value\n// The <any-value> production is identical to <declaration-value>, but also\n// allows top-level <semicolon-token> tokens and <delim-token> tokens\n// with a value of \"!\". It represents the entirety of what valid CSS can be in any context.\nfunction anyValue(token, getNextToken) {\n    if (!token) {\n        return 0;\n    }\n\n    let balanceCloseType = 0;\n    let balanceStash = [];\n    let length = 0;\n\n    // The <any-value> production matches any sequence of one or more tokens,\n    // so long as the sequence ...\n    scan:\n    do {\n        switch (token.type) {\n            // ... does not contain <bad-string-token>, <bad-url-token>,\n            case BadString:\n            case BadUrl:\n                break scan;\n\n            // ... unmatched <)-token>, <]-token>, or <}-token>,\n            case RightCurlyBracket:\n            case RightParenthesis:\n            case RightSquareBracket:\n                if (token.type !== balanceCloseType) {\n                    break scan;\n                }\n\n                balanceCloseType = balanceStash.pop();\n                break;\n\n            case FunctionToken:\n            case LeftParenthesis:\n            case LeftSquareBracket:\n            case LeftCurlyBracket:\n                balanceStash.push(balanceCloseType);\n                balanceCloseType = balancePair.get(token.type);\n                break;\n        }\n\n        length++;\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// =========================\n// Dimensions\n//\n\nfunction dimension(type) {\n    if (type) {\n        type = new Set(type);\n    }\n\n    return function(token, getNextToken, opts) {\n        if (token === null || token.type !== Dimension) {\n            return 0;\n        }\n\n        const numberEnd = consumeNumber(token.value, 0);\n\n        // check unit\n        if (type !== null) {\n            // check for IE postfix hack, i.e. 123px\\0 or 123px\\9\n            const reverseSolidusOffset = token.value.indexOf('\\\\', numberEnd);\n            const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)\n                ? token.value.substr(numberEnd)\n                : token.value.substring(numberEnd, reverseSolidusOffset);\n\n            if (type.has(unit.toLowerCase()) === false) {\n                return 0;\n            }\n        }\n\n        // check range if specified\n        if (outOfRange(opts, token.value, numberEnd)) {\n            return 0;\n        }\n\n        return 1;\n    };\n}\n\n// =========================\n// Percentage\n//\n\n// \u00A75.5. Percentages: the <percentage> type\n// https://drafts.csswg.org/css-values-4/#percentages\nfunction percentage(token, getNextToken, opts) {\n    // ... corresponds to the <percentage-token> production\n    if (token === null || token.type !== Percentage) {\n        return 0;\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, token.value.length - 1)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// =========================\n// Numeric\n//\n\n// https://drafts.csswg.org/css-values-4/#numbers\n// The value <zero> represents a literal number with the value 0. Expressions that merely\n// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;\n// only literal <number-token>s do.\nfunction zero(next) {\n    if (typeof next !== 'function') {\n        next = function() {\n            return 0;\n        };\n    }\n\n    return function(token, getNextToken, opts) {\n        if (token !== null && token.type === NumberToken) {\n            if (Number(token.value) === 0) {\n                return 1;\n            }\n        }\n\n        return next(token, getNextToken, opts);\n    };\n}\n\n// \u00A7 5.3. Real Numbers: the <number> type\n// https://drafts.csswg.org/css-values-4/#numbers\n// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.\n// ... It corresponds to the <number-token> production\nfunction number(token, getNextToken, opts) {\n    if (token === null) {\n        return 0;\n    }\n\n    const numberEnd = consumeNumber(token.value, 0);\n    const isNumber = numberEnd === token.value.length;\n    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {\n        return 0;\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, numberEnd)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// \u00A75.2. Integers: the <integer> type\n// https://drafts.csswg.org/css-values-4/#integers\nfunction integer(token, getNextToken, opts) {\n    // ... corresponds to a subset of the <number-token> production\n    if (token === null || token.type !== NumberToken) {\n        return 0;\n    }\n\n    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer\u2019s sign.\n    let i = charCodeAt(token.value, 0) === 0x002B ||       // U+002B PLUS SIGN (+)\n            charCodeAt(token.value, 0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)\n\n    // When written literally, an integer is one or more decimal digits 0 through 9 ...\n    for (; i < token.value.length; i++) {\n        if (!isDigit(charCodeAt(token.value, i))) {\n            return 0;\n        }\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, i)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// token types\nexport const tokenTypes = {\n    'ident-token': tokenType(Ident),\n    'function-token': tokenType(FunctionToken),\n    'at-keyword-token': tokenType(AtKeyword),\n    'hash-token': tokenType(Hash),\n    'string-token': tokenType(StringToken),\n    'bad-string-token': tokenType(BadString),\n    'url-token': tokenType(Url),\n    'bad-url-token': tokenType(BadUrl),\n    'delim-token': tokenType(Delim),\n    'number-token': tokenType(NumberToken),\n    'percentage-token': tokenType(Percentage),\n    'dimension-token': tokenType(Dimension),\n    'whitespace-token': tokenType(WhiteSpace),\n    'CDO-token': tokenType(CDO),\n    'CDC-token': tokenType(CDC),\n    'colon-token': tokenType(Colon),\n    'semicolon-token': tokenType(Semicolon),\n    'comma-token': tokenType(Comma),\n    '[-token': tokenType(LeftSquareBracket),\n    ']-token': tokenType(RightSquareBracket),\n    '(-token': tokenType(LeftParenthesis),\n    ')-token': tokenType(RightParenthesis),\n    '{-token': tokenType(LeftCurlyBracket),\n    '}-token': tokenType(RightCurlyBracket)\n};\n\n// token production types\nexport const productionTypes = {\n    // token type aliases\n    'string': tokenType(StringToken),\n    'ident': tokenType(Ident),\n\n    // percentage\n    'percentage': calc(percentage),\n\n    // numeric\n    'zero': zero(),\n    'number': calc(number),\n    'integer': calc(integer),\n\n    // complex types\n    'custom-ident': customIdent,\n    'dashed-ident': dashedIdent,\n    'custom-property-name': customPropertyName,\n    'hex-color': hexColor,\n    'id-selector': idSelector, // element( <id-selector> )\n    'an-plus-b': anPlusB,\n    'urange': urange,\n    'declaration-value': declarationValue,\n    'any-value': anyValue\n};\n\nexport const unitGroups = [\n    'length',\n    'angle',\n    'time',\n    'frequency',\n    'resolution',\n    'flex',\n    'decibel',\n    'semitones'\n];\n\n// dimensions types depend on units set\nexport function createDemensionTypes(units) {\n    const {\n        angle,\n        decibel,\n        frequency,\n        flex,\n        length,\n        resolution,\n        semitones,\n        time\n    } = units || {};\n\n    return {\n        'dimension': calc(dimension(null)),\n        'angle': calc(dimension(angle)),\n        'decibel': calc(dimension(decibel)),\n        'frequency': calc(dimension(frequency)),\n        'flex': calc(dimension(flex)),\n        'length': calc(zero(dimension(length))),\n        'resolution': calc(dimension(resolution)),\n        'semitones': calc(dimension(semitones)),\n        'time': calc(dimension(time))\n    };\n}\n\nexport function createGenericTypes(units) {\n    return {\n        ...tokenTypes,\n        ...productionTypes,\n        ...createDemensionTypes(units)\n    };\n};\n", "export const length = [\n    // absolute length units https://www.w3.org/TR/css-values-3/#lengths\n    'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px',\n    // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths\n    'em', 'rem',\n    'ex', 'rex',\n    'cap', 'rcap',\n    'ch', 'rch',\n    'ic', 'ric',\n    'lh', 'rlh',\n    // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths\n    'vw', 'svw', 'lvw', 'dvw',\n    'vh', 'svh', 'lvh', 'dvh',\n    'vi', 'svi', 'lvi', 'dvi',\n    'vb', 'svb', 'lvb', 'dvb',\n    'vmin', 'svmin', 'lvmin', 'dvmin',\n    'vmax', 'svmax', 'lvmax', 'dvmax',\n    // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths\n    'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax'\n];\nexport const angle = ['deg', 'grad', 'rad', 'turn'];    // https://www.w3.org/TR/css-values-3/#angles\nexport const time = ['s', 'ms'];                        // https://www.w3.org/TR/css-values-3/#time\nexport const frequency = ['hz', 'khz'];                 // https://www.w3.org/TR/css-values-3/#frequency\nexport const resolution = ['dpi', 'dpcm', 'dppx', 'x']; // https://www.w3.org/TR/css-values-3/#resolution\nexport const flex = ['fr'];                             // https://drafts.csswg.org/css-grid/#fr-unit\nexport const decibel = ['db'];                          // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume\nexport const semitones = ['st'];                        // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch\n", "import { createCustomError } from '../utils/create-custom-error.js';\n\nexport function SyntaxError(message, input, offset) {\n    return Object.assign(createCustomError('SyntaxError', message), {\n        input,\n        offset,\n        rawMessage: message,\n        message: message + '\\n' +\n            '  ' + input + '\\n' +\n            '--' + new Array((offset || input.length) + 1).join('-') + '^'\n    });\n};\n", "import { SyntaxError } from './SyntaxError.js';\n\nconst TAB = 9;\nconst N = 10;\nconst F = 12;\nconst R = 13;\nconst SPACE = 32;\nconst NAME_CHAR = new Uint8Array(128).map((_, idx) =>\n    /[a-zA-Z0-9\\-]/.test(String.fromCharCode(idx)) ? 1 : 0\n);\n\nexport class Scanner {\n    constructor(str) {\n        this.str = str;\n        this.pos = 0;\n    }\n\n    charCodeAt(pos) {\n        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;\n    }\n    charCode() {\n        return this.charCodeAt(this.pos);\n    }\n    isNameCharCode(code = this.charCode()) {\n        return code < 128 && NAME_CHAR[code] === 1;\n    }\n    nextCharCode() {\n        return this.charCodeAt(this.pos + 1);\n    }\n    nextNonWsCode(pos) {\n        return this.charCodeAt(this.findWsEnd(pos));\n    }\n    skipWs() {\n        this.pos = this.findWsEnd(this.pos);\n    }\n    findWsEnd(pos) {\n        for (; pos < this.str.length; pos++) {\n            const code = this.str.charCodeAt(pos);\n            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {\n                break;\n            }\n        }\n\n        return pos;\n    }\n    substringToPos(end) {\n        return this.str.substring(this.pos, this.pos = end);\n    }\n    eat(code) {\n        if (this.charCode() !== code) {\n            this.error('Expect `' + String.fromCharCode(code) + '`');\n        }\n\n        this.pos++;\n    }\n    peek() {\n        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';\n    }\n    error(message) {\n        throw new SyntaxError(message, this.str, this.pos);\n    }\n\n    scanSpaces() {\n        return this.substringToPos(this.findWsEnd(this.pos));\n    }\n    scanWord() {\n        let end = this.pos;\n\n        for (; end < this.str.length; end++) {\n            const code = this.str.charCodeAt(end);\n            if (code >= 128 || NAME_CHAR[code] === 0) {\n                break;\n            }\n        }\n\n        if (this.pos === end) {\n            this.error('Expect a keyword');\n        }\n\n        return this.substringToPos(end);\n    }\n    scanNumber() {\n        let end = this.pos;\n\n        for (; end < this.str.length; end++) {\n            const code = this.str.charCodeAt(end);\n\n            if (code < 48 || code > 57) {\n                break;\n            }\n        }\n\n        if (this.pos === end) {\n            this.error('Expect a number');\n        }\n\n        return this.substringToPos(end);\n    }\n    scanString() {\n        const end = this.str.indexOf('\\'', this.pos + 1);\n\n        if (end === -1) {\n            this.pos = this.str.length;\n            this.error('Expect an apostrophe');\n        }\n\n        return this.substringToPos(end + 1);\n    }\n};\n", "import { Scanner } from './scanner.js';\n\nconst TAB = 9;\nconst N = 10;\nconst F = 12;\nconst R = 13;\nconst SPACE = 32;\nconst EXCLAMATIONMARK = 33;    // !\nconst NUMBERSIGN = 35;         // #\nconst AMPERSAND = 38;          // &\nconst APOSTROPHE = 39;         // '\nconst LEFTPARENTHESIS = 40;    // (\nconst RIGHTPARENTHESIS = 41;   // )\nconst ASTERISK = 42;           // *\nconst PLUSSIGN = 43;           // +\nconst COMMA = 44;              // ,\nconst HYPERMINUS = 45;         // -\nconst LESSTHANSIGN = 60;       // <\nconst GREATERTHANSIGN = 62;    // >\nconst QUESTIONMARK = 63;       // ?\nconst COMMERCIALAT = 64;       // @\nconst LEFTSQUAREBRACKET = 91;  // [\nconst RIGHTSQUAREBRACKET = 93; // ]\nconst LEFTCURLYBRACKET = 123;  // {\nconst VERTICALLINE = 124;      // |\nconst RIGHTCURLYBRACKET = 125; // }\nconst INFINITY = 8734;         // \u221E\nconst COMBINATOR_PRECEDENCE = {\n    ' ': 1,\n    '&&': 2,\n    '||': 3,\n    '|': 4\n};\n\nfunction readMultiplierRange(scanner) {\n    let min = null;\n    let max = null;\n\n    scanner.eat(LEFTCURLYBRACKET);\n    scanner.skipWs();\n\n    min = scanner.scanNumber(scanner);\n    scanner.skipWs();\n\n    if (scanner.charCode() === COMMA) {\n        scanner.pos++;\n        scanner.skipWs();\n\n        if (scanner.charCode() !== RIGHTCURLYBRACKET) {\n            max = scanner.scanNumber(scanner);\n            scanner.skipWs();\n        }\n    } else {\n        max = min;\n    }\n\n    scanner.eat(RIGHTCURLYBRACKET);\n\n    return {\n        min: Number(min),\n        max: max ? Number(max) : 0\n    };\n}\n\nfunction readMultiplier(scanner) {\n    let range = null;\n    let comma = false;\n\n    switch (scanner.charCode()) {\n        case ASTERISK:\n            scanner.pos++;\n\n            range = {\n                min: 0,\n                max: 0\n            };\n\n            break;\n\n        case PLUSSIGN:\n            scanner.pos++;\n\n            range = {\n                min: 1,\n                max: 0\n            };\n\n            break;\n\n        case QUESTIONMARK:\n            scanner.pos++;\n\n            range = {\n                min: 0,\n                max: 1\n            };\n\n            break;\n\n        case NUMBERSIGN:\n            scanner.pos++;\n\n            comma = true;\n\n            if (scanner.charCode() === LEFTCURLYBRACKET) {\n                range = readMultiplierRange(scanner);\n            } else if (scanner.charCode() === QUESTIONMARK) {\n                // https://www.w3.org/TR/css-values-4/#component-multipliers\n                // > the # and ? multipliers may be stacked as #?\n                // In this case just treat \"#?\" as a single multiplier\n                // { min: 0, max: 0, comma: true }\n                scanner.pos++;\n                range = {\n                    min: 0,\n                    max: 0\n                };\n            } else {\n                range = {\n                    min: 1,\n                    max: 0\n                };\n            }\n\n            break;\n\n        case LEFTCURLYBRACKET:\n            range = readMultiplierRange(scanner);\n            break;\n\n        default:\n            return null;\n    }\n\n    return {\n        type: 'Multiplier',\n        comma,\n        min: range.min,\n        max: range.max,\n        term: null\n    };\n}\n\nfunction maybeMultiplied(scanner, node) {\n    const multiplier = readMultiplier(scanner);\n\n    if (multiplier !== null) {\n        multiplier.term = node;\n\n        // https://www.w3.org/TR/css-values-4/#component-multipliers\n        // > The + and # multipliers may be stacked as +#;\n        // Represent \"+#\" as nested multipliers:\n        // { ...<multiplier #>,\n        //   term: {\n        //     ...<multipler +>,\n        //     term: node\n        //   }\n        // }\n        if (scanner.charCode() === NUMBERSIGN &&\n            scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN) {\n            return maybeMultiplied(scanner, multiplier);\n        }\n\n        return multiplier;\n    }\n\n    return node;\n}\n\nfunction maybeToken(scanner) {\n    const ch = scanner.peek();\n\n    if (ch === '') {\n        return null;\n    }\n\n    return maybeMultiplied(scanner, {\n        type: 'Token',\n        value: ch\n    });\n}\n\nfunction readProperty(scanner) {\n    let name;\n\n    scanner.eat(LESSTHANSIGN);\n    scanner.eat(APOSTROPHE);\n\n    name = scanner.scanWord();\n\n    scanner.eat(APOSTROPHE);\n    scanner.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(scanner, {\n        type: 'Property',\n        name\n    });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation\u2014[min,max]\u2014within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(scanner) {\n    // use null for Infinity to make AST format JSON serializable/deserializable\n    let min = null; // -Infinity\n    let max = null; // Infinity\n    let sign = 1;\n\n    scanner.eat(LEFTSQUAREBRACKET);\n\n    if (scanner.charCode() === HYPERMINUS) {\n        scanner.peek();\n        sign = -1;\n    }\n\n    if (sign == -1 && scanner.charCode() === INFINITY) {\n        scanner.peek();\n    } else {\n        min = sign * Number(scanner.scanNumber(scanner));\n\n        if (scanner.isNameCharCode()) {\n            min += scanner.scanWord();\n        }\n    }\n\n    scanner.skipWs();\n    scanner.eat(COMMA);\n    scanner.skipWs();\n\n    if (scanner.charCode() === INFINITY) {\n        scanner.peek();\n    } else {\n        sign = 1;\n\n        if (scanner.charCode() === HYPERMINUS) {\n            scanner.peek();\n            sign = -1;\n        }\n\n        max = sign * Number(scanner.scanNumber(scanner));\n\n        if (scanner.isNameCharCode()) {\n            max += scanner.scanWord();\n        }\n    }\n\n    scanner.eat(RIGHTSQUAREBRACKET);\n\n    return {\n        type: 'Range',\n        min,\n        max\n    };\n}\n\nfunction readType(scanner) {\n    let name;\n    let opts = null;\n\n    scanner.eat(LESSTHANSIGN);\n    name = scanner.scanWord();\n\n    // https://drafts.csswg.org/css-values-5/#boolean\n    if (name === 'boolean-expr') {\n        scanner.eat(LEFTSQUAREBRACKET);\n\n        const implicitGroup = readImplicitGroup(scanner, RIGHTSQUAREBRACKET);\n\n        scanner.eat(RIGHTSQUAREBRACKET);\n        scanner.eat(GREATERTHANSIGN);\n\n        return maybeMultiplied(scanner, {\n            type: 'Boolean',\n            term: implicitGroup.terms.length === 1\n                ? implicitGroup.terms[0]\n                : implicitGroup\n        });\n    }\n\n    if (scanner.charCode() === LEFTPARENTHESIS &&\n        scanner.nextCharCode() === RIGHTPARENTHESIS) {\n        scanner.pos += 2;\n        name += '()';\n    }\n\n    if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET) {\n        scanner.skipWs();\n        opts = readTypeRange(scanner);\n    }\n\n    scanner.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(scanner, {\n        type: 'Type',\n        name,\n        opts\n    });\n}\n\nfunction readKeywordOrFunction(scanner) {\n    const name = scanner.scanWord();\n\n    if (scanner.charCode() === LEFTPARENTHESIS) {\n        scanner.pos++;\n\n        return {\n            type: 'Function',\n            name\n        };\n    }\n\n    return maybeMultiplied(scanner, {\n        type: 'Keyword',\n        name\n    });\n}\n\nfunction regroupTerms(terms, combinators) {\n    function createGroup(terms, combinator) {\n        return {\n            type: 'Group',\n            terms,\n            combinator,\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    let combinator;\n\n    combinators = Object.keys(combinators)\n        .sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);\n\n    while (combinators.length > 0) {\n        combinator = combinators.shift();\n\n        let i = 0;\n        let subgroupStart = 0;\n\n        for (; i < terms.length; i++) {\n            const term = terms[i];\n\n            if (term.type === 'Combinator') {\n                if (term.value === combinator) {\n                    if (subgroupStart === -1) {\n                        subgroupStart = i - 1;\n                    }\n                    terms.splice(i, 1);\n                    i--;\n                } else {\n                    if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                        terms.splice(\n                            subgroupStart,\n                            i - subgroupStart,\n                            createGroup(terms.slice(subgroupStart, i), combinator)\n                        );\n                        i = subgroupStart + 1;\n                    }\n                    subgroupStart = -1;\n                }\n            }\n        }\n\n        if (subgroupStart !== -1 && combinators.length) {\n            terms.splice(\n                subgroupStart,\n                i - subgroupStart,\n                createGroup(terms.slice(subgroupStart, i), combinator)\n            );\n        }\n    }\n\n    return combinator;\n}\n\nfunction readImplicitGroup(scanner, stopCharCode) {\n    const combinators = Object.create(null);\n    const terms = [];\n    let token;\n    let prevToken = null;\n    let prevTokenPos = scanner.pos;\n\n    while (scanner.charCode() !== stopCharCode && (token = peek(scanner, stopCharCode))) {\n        if (token.type !== 'Spaces') {\n            if (token.type === 'Combinator') {\n                // check for combinator in group beginning and double combinator sequence\n                if (prevToken === null || prevToken.type === 'Combinator') {\n                    scanner.pos = prevTokenPos;\n                    scanner.error('Unexpected combinator');\n                }\n\n                combinators[token.value] = true;\n            } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                combinators[' '] = true;  // a b\n                terms.push({\n                    type: 'Combinator',\n                    value: ' '\n                });\n            }\n\n            terms.push(token);\n            prevToken = token;\n            prevTokenPos = scanner.pos;\n        }\n    }\n\n    // check for combinator in group ending\n    if (prevToken !== null && prevToken.type === 'Combinator') {\n        scanner.pos -= prevTokenPos;\n        scanner.error('Unexpected combinator');\n    }\n\n    return {\n        type: 'Group',\n        terms,\n        combinator: regroupTerms(terms, combinators) || ' ',\n        disallowEmpty: false,\n        explicit: false\n    };\n}\n\nfunction readGroup(scanner, stopCharCode) {\n    let result;\n\n    scanner.eat(LEFTSQUAREBRACKET);\n    result = readImplicitGroup(scanner, stopCharCode);\n    scanner.eat(RIGHTSQUAREBRACKET);\n\n    result.explicit = true;\n\n    if (scanner.charCode() === EXCLAMATIONMARK) {\n        scanner.pos++;\n        result.disallowEmpty = true;\n    }\n\n    return result;\n}\n\nfunction peek(scanner, stopCharCode) {\n    let code = scanner.charCode();\n\n    switch (code) {\n        case RIGHTSQUAREBRACKET:\n            // don't eat, stop scan a group\n            break;\n\n        case LEFTSQUAREBRACKET:\n            return maybeMultiplied(scanner, readGroup(scanner, stopCharCode));\n\n        case LESSTHANSIGN:\n            return scanner.nextCharCode() === APOSTROPHE\n                ? readProperty(scanner)\n                : readType(scanner);\n\n        case VERTICALLINE:\n            return {\n                type: 'Combinator',\n                value: scanner.substringToPos(\n                    scanner.pos + (scanner.nextCharCode() === VERTICALLINE ? 2 : 1)\n                )\n            };\n\n        case AMPERSAND:\n            scanner.pos++;\n            scanner.eat(AMPERSAND);\n\n            return {\n                type: 'Combinator',\n                value: '&&'\n            };\n\n        case COMMA:\n            scanner.pos++;\n            return {\n                type: 'Comma'\n            };\n\n        case APOSTROPHE:\n            return maybeMultiplied(scanner, {\n                type: 'String',\n                value: scanner.scanString()\n            });\n\n        case SPACE:\n        case TAB:\n        case N:\n        case R:\n        case F:\n            return {\n                type: 'Spaces',\n                value: scanner.scanSpaces()\n            };\n\n        case COMMERCIALAT:\n            code = scanner.nextCharCode();\n\n            if (scanner.isNameCharCode(code)) {\n                scanner.pos++;\n                return {\n                    type: 'AtKeyword',\n                    name: scanner.scanWord()\n                };\n            }\n\n            return maybeToken(scanner);\n\n        case ASTERISK:\n        case PLUSSIGN:\n        case QUESTIONMARK:\n        case NUMBERSIGN:\n        case EXCLAMATIONMARK:\n            // prohibited tokens (used as a multiplier start)\n            break;\n\n        case LEFTCURLYBRACKET:\n            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n            // check next char isn't a number, because it's likely a disjoined multiplier\n            code = scanner.nextCharCode();\n\n            if (code < 48 || code > 57) {\n                return maybeToken(scanner);\n            }\n\n            break;\n\n        default:\n            if (scanner.isNameCharCode(code)) {\n                return readKeywordOrFunction(scanner);\n            }\n\n            return maybeToken(scanner);\n    }\n}\n\nexport function parse(source) {\n    const scanner = new Scanner(source);\n    const result = readImplicitGroup(scanner);\n\n    if (scanner.pos !== source.length) {\n        scanner.error('Unexpected input');\n    }\n\n    // reduce redundant groups with single group term\n    if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n        return result.terms[0];\n    }\n\n    return result;\n};\n", "const noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nexport function walk(node, options, context) {\n    function walk(node) {\n        enter.call(context, node);\n\n        switch (node.type) {\n            case 'Group':\n                node.terms.forEach(walk);\n                break;\n\n            case 'Multiplier':\n            case 'Boolean':\n                walk(node.term);\n                break;\n\n            case 'Type':\n            case 'Property':\n            case 'Keyword':\n            case 'AtKeyword':\n            case 'Function':\n            case 'String':\n            case 'Token':\n            case 'Comma':\n                break;\n\n            default:\n                throw new Error('Unknown type: ' + node.type);\n        }\n\n        leave.call(context, node);\n    }\n\n    let enter = noop;\n    let leave = noop;\n\n    if (typeof options === 'function') {\n        enter = options;\n    } else if (options) {\n        enter = ensureFunction(options.enter);\n        leave = ensureFunction(options.leave);\n    }\n\n    if (enter === noop && leave === noop) {\n        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n    }\n\n    walk(node, context);\n};\n", "import { tokenize } from '../tokenizer/index.js';\n\nconst astToTokens = {\n    decorator(handlers) {\n        const tokens = [];\n        let curNode = null;\n\n        return {\n            ...handlers,\n            node(node) {\n                const tmp = curNode;\n                curNode = node;\n                handlers.node.call(this, node);\n                curNode = tmp;\n            },\n            emit(value, type, auto) {\n                tokens.push({\n                    type,\n                    value,\n                    node: auto ? null : curNode\n                });\n            },\n            result() {\n                return tokens;\n            }\n        };\n    }\n};\n\nfunction stringToTokens(str) {\n    const tokens = [];\n\n    tokenize(str, (type, start, end) =>\n        tokens.push({\n            type,\n            value: str.slice(start, end),\n            node: null\n        })\n    );\n\n    return tokens;\n}\n\nexport default function(value, syntax) {\n    if (typeof value === 'string') {\n        return stringToTokens(value);\n    }\n\n    return syntax.generate(value, astToTokens);\n};\n", "import { parse } from '../definition-syntax/parse.js';\n\nexport const MATCH = { type: 'Match' };\nexport const MISMATCH = { type: 'Mismatch' };\nexport const DISALLOW_EMPTY = { type: 'DisallowEmpty' };\n\nconst LEFTPARENTHESIS = 40;  // (\nconst RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n    // reduce node count\n    if (thenBranch === MATCH && elseBranch === MISMATCH) {\n        return match;\n    }\n\n    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n        return match;\n    }\n\n    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n        thenBranch = match.then;\n        match = match.match;\n    }\n\n    return {\n        type: 'If',\n        match,\n        then: thenBranch,\n        else: elseBranch\n    };\n}\n\nfunction isFunctionType(name) {\n    return (\n        name.length > 2 &&\n        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&\n        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS\n    );\n}\n\nfunction isEnumCapatible(term) {\n    return (\n        term.type === 'Keyword' ||\n        term.type === 'AtKeyword' ||\n        term.type === 'Function' ||\n        term.type === 'Type' && isFunctionType(term.name)\n    );\n}\n\nfunction groupNode(terms, combinator = ' ', explicit = false) {\n    return {\n        type: 'Group',\n        terms,\n        combinator,\n        disallowEmpty: false,\n        explicit\n    };\n}\n\nfunction replaceTypeInGraph(node, replacements, visited = new Set()) {\n    if (!visited.has(node)) {\n        visited.add(node);\n\n        switch (node.type) {\n            case 'If':\n                node.match = replaceTypeInGraph(node.match, replacements, visited);\n                node.then = replaceTypeInGraph(node.then, replacements, visited);\n                node.else = replaceTypeInGraph(node.else, replacements, visited);\n                break;\n\n            case 'Type':\n                return replacements[node.name] || node;\n        }\n    }\n\n    return node;\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n    switch (combinator) {\n        case ' ': {\n            // Juxtaposing components means that all of them must occur, in the given order.\n            //\n            // a b c\n            // =\n            // match a\n            //   then match b\n            //     then match c\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            //   else MISMATCH\n            let result = MATCH;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                const term = terms[i];\n\n                result = createCondition(\n                    term,\n                    result,\n                    MISMATCH\n                );\n            };\n\n            return result;\n        }\n\n        case '|': {\n            // A bar (|) separates two or more alternatives: exactly one of them must occur.\n            //\n            // a | b | c\n            // =\n            // match a\n            //   then MATCH\n            //   else match b\n            //     then MATCH\n            //     else match c\n            //       then MATCH\n            //       else MISMATCH\n\n            let result = MISMATCH;\n            let map = null;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                let term = terms[i];\n\n                // reduce sequence of keywords into a Enum\n                if (isEnumCapatible(term)) {\n                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                        map = Object.create(null);\n                        result = createCondition(\n                            {\n                                type: 'Enum',\n                                map\n                            },\n                            MATCH,\n                            result\n                        );\n                    }\n\n                    if (map !== null) {\n                        const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                        if (key in map === false) {\n                            map[key] = term;\n                            continue;\n                        }\n                    }\n                }\n\n                map = null;\n\n                // create a new conditonal node\n                result = createCondition(\n                    term,\n                    MATCH,\n                    result\n                );\n            };\n\n            return result;\n        }\n\n        case '&&': {\n            // A double ampersand (&&) separates two or more components,\n            // all of which must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since &&-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms,\n                    all: true\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a && b && c\n            // =\n            // match a\n            //   then [b && c]\n            //   else match b\n            //     then [a && c]\n            //     else match c\n            //       then [a && b]\n            //       else MISMATCH\n            //\n            // a && b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MISMATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            let result = MISMATCH;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                const term = terms[i];\n                let thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        false\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n        }\n\n        case '||': {\n            // A double bar (||) separates two or more options:\n            // one or more of them must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since ||-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms,\n                    all: false\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a || b || c\n            // =\n            // match a\n            //   then [b || c]\n            //   else match b\n            //     then [a || c]\n            //     else match c\n            //       then [a || b]\n            //       else MISMATCH\n            //\n            // a || b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MATCH\n            //     else MISMATCH\n            let result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n            for (let i = terms.length - 1; i >= 0; i--) {\n                const term = terms[i];\n                let thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        true\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n        }\n    }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n    let result = MATCH;\n    let matchTerm = buildMatchGraphInternal(node.term);\n\n    if (node.max === 0) {\n        // disable repeating of empty match to prevent infinite loop\n        matchTerm = createCondition(\n            matchTerm,\n            DISALLOW_EMPTY,\n            MISMATCH\n        );\n\n        // an occurrence count is not limited, make a cycle;\n        // to collect more terms on each following matching mismatch\n        result = createCondition(\n            matchTerm,\n            null, // will be a loop\n            MISMATCH\n        );\n\n        result.then = createCondition(\n            MATCH,\n            MATCH,\n            result // make a loop\n        );\n\n        if (node.comma) {\n            result.then.else = createCondition(\n                { type: 'Comma', syntax: node },\n                result,\n                MISMATCH\n            );\n        }\n    } else {\n        // create a match node chain for [min .. max] interval with optional matches\n        for (let i = node.min || 1; i <= node.max; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                createCondition(\n                    MATCH,\n                    MATCH,\n                    result\n                ),\n                MISMATCH\n            );\n        }\n    }\n\n    if (node.min === 0) {\n        // allow zero match\n        result = createCondition(\n            MATCH,\n            MATCH,\n            result\n        );\n    } else {\n        // create a match node chain to collect [0 ... min - 1] required matches\n        for (let i = 0; i < node.min - 1; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                result,\n                MISMATCH\n            );\n        }\n    }\n\n    return result;\n}\n\nfunction buildMatchGraphInternal(node) {\n    if (typeof node === 'function') {\n        return {\n            type: 'Generic',\n            fn: node\n        };\n    }\n\n    switch (node.type) {\n        case 'Group': {\n            let result = buildGroupMatchGraph(\n                node.combinator,\n                node.terms.map(buildMatchGraphInternal),\n                false\n            );\n\n            if (node.disallowEmpty) {\n                result = createCondition(\n                    result,\n                    DISALLOW_EMPTY,\n                    MISMATCH\n                );\n            }\n\n            return result;\n        }\n\n        case 'Multiplier':\n            return buildMultiplierMatchGraph(node);\n\n        // https://drafts.csswg.org/css-values-5/#boolean\n        case 'Boolean': {\n            const term = buildMatchGraphInternal(node.term);\n            // <boolean-expr[ <test> ]> = not <boolean-expr-group> | <boolean-expr-group> [ [ and <boolean-expr-group> ]* | [ or <boolean-expr-group> ]* ]\n            const matchNode = buildMatchGraphInternal(groupNode([\n                groupNode([\n                    { type: 'Keyword', name: 'not' },\n                    { type: 'Type', name: '!boolean-group' }\n                ]),\n                groupNode([\n                    { type: 'Type', name: '!boolean-group' },\n                    groupNode([\n                        { type: 'Multiplier', comma: false, min: 0, max: 0, term: groupNode([\n                            { type: 'Keyword', name: 'and' },\n                            { type: 'Type', name: '!boolean-group' }\n                        ]) },\n                        { type: 'Multiplier', comma: false, min: 0, max: 0, term: groupNode([\n                            { type: 'Keyword', name: 'or' },\n                            { type: 'Type', name: '!boolean-group' }\n                        ]) }\n                    ], '|')\n                ])\n            ], '|'));\n            // <boolean-expr-group> = <test> | ( <boolean-expr[ <test> ]> ) | <general-enclosed>\n            const booleanGroup = buildMatchGraphInternal(\n                groupNode([\n                    { type: 'Type', name: '!term' },\n                    groupNode([\n                        { type: 'Token', value: '(' },\n                        { type: 'Type', name: '!self' },\n                        { type: 'Token', value: ')' }\n                    ]),\n                    { type: 'Type', name: 'general-enclosed' }\n                ], '|')\n            );\n\n            replaceTypeInGraph(booleanGroup, { '!term': term, '!self': matchNode });\n            replaceTypeInGraph(matchNode, { '!boolean-group': booleanGroup });\n\n            return matchNode;\n        }\n\n        case 'Type':\n        case 'Property':\n            return {\n                type: node.type,\n                name: node.name,\n                syntax: node\n            };\n\n        case 'Keyword':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'AtKeyword':\n            return {\n                type: node.type,\n                name: '@' + node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'Function':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase() + '(',\n                syntax: node\n            };\n\n        case 'String':\n            // convert a one char length String to a Token\n            if (node.value.length === 3) {\n                return {\n                    type: 'Token',\n                    value: node.value.charAt(1),\n                    syntax: node\n                };\n            }\n\n            // otherwise use it as is\n            return {\n                type: node.type,\n                value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                syntax: node\n            };\n\n        case 'Token':\n            return {\n                type: node.type,\n                value: node.value,\n                syntax: node\n            };\n\n        case 'Comma':\n            return {\n                type: node.type,\n                syntax: node\n            };\n\n        default:\n            throw new Error('Unknown node type:', node.type);\n    }\n}\n\nexport function buildMatchGraph(syntaxTree, ref) {\n    if (typeof syntaxTree === 'string') {\n        syntaxTree = parse(syntaxTree);\n    }\n\n    return {\n        type: 'MatchGraph',\n        match: buildMatchGraphInternal(syntaxTree),\n        syntax: ref || null,\n        source: syntaxTree\n    };\n}\n", "import { MATCH, MISMATCH, DISALLOW_EMPTY } from './match-graph.js';\nimport * as TYPE from '../tokenizer/types.js';\n\nconst { hasOwnProperty } = Object.prototype;\nconst STUB = 0;\nconst TOKEN = 1;\nconst OPEN_SYNTAX = 2;\nconst CLOSE_SYNTAX = 3;\n\nconst EXIT_REASON_MATCH = 'Match';\nconst EXIT_REASON_MISMATCH = 'Mismatch';\nconst EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\nconst ITERATION_LIMIT = 15000;\nexport let totalIterationCount = 0;\n\nfunction reverseList(list) {\n    let prev = null;\n    let next = null;\n    let item = list;\n\n    while (item !== null) {\n        next = item.prev;\n        item.prev = prev;\n        prev = item;\n        item = next;\n    }\n\n    return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n    if (testStr.length !== referenceStr.length) {\n        return false;\n    }\n\n    for (let i = 0; i < testStr.length; i++) {\n        const referenceCode = referenceStr.charCodeAt(i);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n        if (testCode >= 0x0041 && testCode <= 0x005A) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isContextEdgeDelim(token) {\n    if (token.type !== TYPE.Delim) {\n        return false;\n    }\n\n    // Fix matching for unicode-range: U+30??, U+FF00-FF9F\n    // Probably we need to check out previous match instead\n    return token.value !== '?';\n}\n\nfunction isCommaContextStart(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.Comma ||\n        token.type === TYPE.Function ||\n        token.type === TYPE.LeftParenthesis ||\n        token.type === TYPE.LeftSquareBracket ||\n        token.type === TYPE.LeftCurlyBracket ||\n        isContextEdgeDelim(token)\n    );\n}\n\nfunction isCommaContextEnd(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.RightParenthesis ||\n        token.type === TYPE.RightSquareBracket ||\n        token.type === TYPE.RightCurlyBracket ||\n        (token.type === TYPE.Delim && token.value === '/')\n    );\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n    function moveToNextToken() {\n        do {\n            tokenIndex++;\n            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n    }\n\n    function getNextToken(offset) {\n        const nextIndex = tokenIndex + offset;\n\n        return nextIndex < tokens.length ? tokens[nextIndex] : null;\n    }\n\n    function stateSnapshotFromSyntax(nextState, prev) {\n        return {\n            nextState,\n            matchStack,\n            syntaxStack,\n            thenStack,\n            tokenIndex,\n            prev\n        };\n    }\n\n    function pushThenStack(nextState) {\n        thenStack = {\n            nextState,\n            matchStack,\n            syntaxStack,\n            prev: thenStack\n        };\n    }\n\n    function pushElseStack(nextState) {\n        elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n    }\n\n    function addTokenToMatch() {\n        matchStack = {\n            type: TOKEN,\n            syntax: state.syntax,\n            token,\n            prev: matchStack\n        };\n\n        moveToNextToken();\n        syntaxStash = null;\n\n        if (tokenIndex > longestMatch) {\n            longestMatch = tokenIndex;\n        }\n    }\n\n    function openSyntax() {\n        syntaxStack = {\n            syntax: state.syntax,\n            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n            prev: syntaxStack\n        };\n\n        matchStack = {\n            type: OPEN_SYNTAX,\n            syntax: state.syntax,\n            token: matchStack.token,\n            prev: matchStack\n        };\n    }\n\n    function closeSyntax() {\n        if (matchStack.type === OPEN_SYNTAX) {\n            matchStack = matchStack.prev;\n        } else {\n            matchStack = {\n                type: CLOSE_SYNTAX,\n                syntax: syntaxStack.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        syntaxStack = syntaxStack.prev;\n    }\n\n    let syntaxStack = null;\n    let thenStack = null;\n    let elseStack = null;\n\n    // null \u2013 stashing allowed, nothing stashed\n    // false \u2013 stashing disabled, nothing stashed\n    // anithing else \u2013 fail stashable syntaxes, some syntax stashed\n    let syntaxStash = null;\n\n    let iterationCount = 0; // count iterations and prevent infinite loop\n    let exitReason = null;\n\n    let token = null;\n    let tokenIndex = -1;\n    let longestMatch = 0;\n    let matchStack = {\n        type: STUB,\n        syntax: null,\n        token: null,\n        prev: null\n    };\n\n    moveToNextToken();\n\n    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n        // function mapList(list, fn) {\n        //     const result = [];\n        //     while (list) {\n        //         result.unshift(fn(list));\n        //         list = list.prev;\n        //     }\n        //     return result;\n        // }\n        // console.log('--\\n',\n        //     '#' + iterationCount,\n        //     require('util').inspect({\n        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n        //         token: token && token.value,\n        //         tokenIndex,\n        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n        //     }, { depth: null })\n        // );\n        switch (state.type) {\n            case 'Match':\n                if (thenStack === null) {\n                    // turn to MISMATCH when some tokens left unmatched\n                    if (token !== null) {\n                        // doesn't mismatch if just one token left and it's an IE hack\n                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                            state = MISMATCH;\n                            break;\n                        }\n                    }\n\n                    // break the main loop, return a result - MATCH\n                    exitReason = EXIT_REASON_MATCH;\n                    break;\n                }\n\n                // go to next syntax (`then` branch)\n                state = thenStack.nextState;\n\n                // check match is not empty\n                if (state === DISALLOW_EMPTY) {\n                    if (thenStack.matchStack === matchStack) {\n                        state = MISMATCH;\n                        break;\n                    } else {\n                        state = MATCH;\n                    }\n                }\n\n                // close syntax if needed\n                while (thenStack.syntaxStack !== syntaxStack) {\n                    closeSyntax();\n                }\n\n                // pop stack\n                thenStack = thenStack.prev;\n                break;\n\n            case 'Mismatch':\n                // when some syntax is stashed\n                if (syntaxStash !== null && syntaxStash !== false) {\n                    // there is no else branches or a branch reduce match stack\n                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                        // restore state from the stash\n                        elseStack = syntaxStash;\n                        syntaxStash = false; // disable stashing\n                    }\n                } else if (elseStack === null) {\n                    // no else branches -> break the main loop\n                    // return a result - MISMATCH\n                    exitReason = EXIT_REASON_MISMATCH;\n                    break;\n                }\n\n                // go to next syntax (`else` branch)\n                state = elseStack.nextState;\n\n                // restore all the rest stack states\n                thenStack = elseStack.thenStack;\n                syntaxStack = elseStack.syntaxStack;\n                matchStack = elseStack.matchStack;\n                tokenIndex = elseStack.tokenIndex;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                // pop stack\n                elseStack = elseStack.prev;\n                break;\n\n            case 'MatchGraph':\n                state = state.match;\n                break;\n\n            case 'If':\n                // IMPORTANT: else stack push must go first,\n                // since it stores the state of thenStack before changes\n                if (state.else !== MISMATCH) {\n                    pushElseStack(state.else);\n                }\n\n                if (state.then !== MATCH) {\n                    pushThenStack(state.then);\n                }\n\n                state = state.match;\n                break;\n\n            case 'MatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state,\n                    index: 0,\n                    mask: 0\n                };\n                break;\n\n            case 'MatchOnceBuffer': {\n                const terms = state.syntax.terms;\n\n                if (state.index === terms.length) {\n                    // no matches at all or it's required all terms to be matched\n                    if (state.mask === 0 || state.syntax.all) {\n                        state = MISMATCH;\n                        break;\n                    }\n\n                    // a partial match is ok\n                    state = MATCH;\n                    break;\n                }\n\n                // all terms are matched\n                if (state.mask === (1 << terms.length) - 1) {\n                    state = MATCH;\n                    break;\n                }\n\n                for (; state.index < terms.length; state.index++) {\n                    const matchFlag = 1 << state.index;\n\n                    if ((state.mask & matchFlag) === 0) {\n                        // IMPORTANT: else stack push must go first,\n                        // since it stores the state of thenStack before changes\n                        pushElseStack(state);\n                        pushThenStack({\n                            type: 'AddMatchOnce',\n                            syntax: state.syntax,\n                            mask: state.mask | matchFlag\n                        });\n\n                        // match\n                        state = terms[state.index++];\n                        break;\n                    }\n                }\n                break;\n            }\n\n            case 'AddMatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state.syntax,\n                    index: 0,\n                    mask: state.mask\n                };\n                break;\n\n            case 'Enum':\n                if (token !== null) {\n                    let name = token.value.toLowerCase();\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (name.indexOf('\\\\') !== -1) {\n                        name = name.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (hasOwnProperty.call(state.map, name)) {\n                        state = state.map[name];\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Generic': {\n                const opts = syntaxStack !== null ? syntaxStack.opts : null;\n                const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n            }\n\n            case 'Type':\n            case 'Property': {\n                const syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                const dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                if (!dictSyntax || !dictSyntax.match) {\n                    throw new Error(\n                        'Bad syntax reference: ' +\n                        (state.type === 'Type'\n                            ? '<' + state.name + '>'\n                            : '<\\'' + state.name + '\\'>')\n                    );\n                }\n\n                // stash a syntax for types with low priority\n                if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                    const lowPriorityMatching =\n                        // https://drafts.csswg.org/css-values-4/#custom-idents\n                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                        // can only claim the keyword if no other unfulfilled production can claim it.\n                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||\n\n                        // https://drafts.csswg.org/css-values-4/#lengths\n                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                        // it must parse as a <number>\n                        (state.name === 'length' && token.value === '0');\n\n                    if (lowPriorityMatching) {\n                        if (syntaxStash === null) {\n                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                        }\n\n                        state = MISMATCH;\n                        break;\n                    }\n                }\n\n                openSyntax();\n                state = dictSyntax.matchRef || dictSyntax.match;\n                break;\n            }\n\n            case 'Keyword': {\n                const name = state.name;\n\n                if (token !== null) {\n                    let keywordName = token.value;\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (keywordName.indexOf('\\\\') !== -1) {\n                        keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                        addTokenToMatch();\n                        state = MATCH;\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n            }\n\n            case 'AtKeyword':\n            case 'Function':\n                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Token':\n                if (token !== null && token.value === state.value) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Comma':\n                if (token !== null && token.type === TYPE.Comma) {\n                    if (isCommaContextStart(matchStack.token)) {\n                        state = MISMATCH;\n                    } else {\n                        addTokenToMatch();\n                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n                    }\n                } else {\n                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n                }\n\n                break;\n\n            case 'String':\n                let string = '';\n                let lastTokenIndex = tokenIndex;\n\n                for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                    string += tokens[lastTokenIndex].value;\n                }\n\n                if (areStringsEqualCaseInsensitive(string, state.value)) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            default:\n                throw new Error('Unknown node type: ' + state.type);\n        }\n    }\n\n    totalIterationCount += iterationCount;\n\n    switch (exitReason) {\n        case null:\n            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n            exitReason = EXIT_REASON_ITERATION_LIMIT;\n            matchStack = null;\n            break;\n\n        case EXIT_REASON_MATCH:\n            while (syntaxStack !== null) {\n                closeSyntax();\n            }\n            break;\n\n        default:\n            matchStack = null;\n    }\n\n    return {\n        tokens,\n        reason: exitReason,\n        iterations: iterationCount,\n        match: matchStack,\n        longestMatch\n    };\n}\n\nexport function matchAsList(tokens, matchGraph, syntaxes) {\n    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match !== null) {\n        let item = reverseList(matchResult.match).prev;\n\n        matchResult.match = [];\n\n        while (item !== null) {\n            switch (item.type) {\n                case OPEN_SYNTAX:\n                case CLOSE_SYNTAX:\n                    matchResult.match.push({\n                        type: item.type,\n                        syntax: item.syntax\n                    });\n                    break;\n\n                default:\n                    matchResult.match.push({\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n                    break;\n            }\n\n            item = item.prev;\n        }\n    }\n\n    return matchResult;\n}\n\nexport function matchAsTree(tokens, matchGraph, syntaxes) {\n    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match === null) {\n        return matchResult;\n    }\n\n    let item = matchResult.match;\n    let host = matchResult.match = {\n        syntax: matchGraph.syntax || null,\n        match: []\n    };\n    const hostStack = [host];\n\n    // revert a list and start with 2nd item since 1st is a stub item\n    item = reverseList(item).prev;\n\n    // build a tree\n    while (item !== null) {\n        switch (item.type) {\n            case OPEN_SYNTAX:\n                host.match.push(host = {\n                    syntax: item.syntax,\n                    match: []\n                });\n                hostStack.push(host);\n                break;\n\n            case CLOSE_SYNTAX:\n                hostStack.pop();\n                host = hostStack[hostStack.length - 1];\n                break;\n\n            default:\n                host.match.push({\n                    syntax: item.syntax || null,\n                    token: item.token.value,\n                    node: item.token.node\n                });\n        }\n\n        item = item.prev;\n    }\n\n    return matchResult;\n}\n", "export function getTrace(node) {\n    function shouldPutToTrace(syntax) {\n        if (syntax === null) {\n            return false;\n        }\n\n        return (\n            syntax.type === 'Type' ||\n            syntax.type === 'Property' ||\n            syntax.type === 'Keyword'\n        );\n    }\n\n    function hasMatch(matchNode) {\n        if (Array.isArray(matchNode.match)) {\n            // use for-loop for better perfomance\n            for (let i = 0; i < matchNode.match.length; i++) {\n                if (hasMatch(matchNode.match[i])) {\n                    if (shouldPutToTrace(matchNode.syntax)) {\n                        result.unshift(matchNode.syntax);\n                    }\n\n                    return true;\n                }\n            }\n        } else if (matchNode.node === node) {\n            result = shouldPutToTrace(matchNode.syntax)\n                ? [matchNode.syntax]\n                : [];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    let result = null;\n\n    if (this.matched !== null) {\n        hasMatch(this.matched);\n    }\n\n    return result;\n}\n\nexport function isType(node, type) {\n    return testNode(this, node, match => match.type === 'Type' && match.name === type);\n}\n\nexport function isProperty(node, property) {\n    return testNode(this, node, match => match.type === 'Property' && match.name === property);\n}\n\nexport function isKeyword(node) {\n    return testNode(this, node, match => match.type === 'Keyword');\n}\n\nfunction testNode(match, node, fn) {\n    const trace = getTrace.call(match, node);\n\n    if (trace === null) {\n        return false;\n    }\n\n    return trace.some(fn);\n}\n", "import { List } from '../utils/List.js';\n\nfunction getFirstMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getFirstMatchNode(matchNode.match[0]);\n}\n\nfunction getLastMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);\n}\n\nexport function matchFragments(lexer, ast, match, type, name) {\n    function findFragments(matchNode) {\n        if (matchNode.syntax !== null &&\n            matchNode.syntax.type === type &&\n            matchNode.syntax.name === name) {\n            const start = getFirstMatchNode(matchNode);\n            const end = getLastMatchNode(matchNode);\n\n            lexer.syntax.walk(ast, function(node, item, list) {\n                if (node === start) {\n                    const nodes = new List();\n\n                    do {\n                        nodes.appendData(item.data);\n\n                        if (item.data === end) {\n                            break;\n                        }\n\n                        item = item.next;\n                    } while (item !== null);\n\n                    fragments.push({\n                        parent: list,\n                        nodes\n                    });\n                }\n            });\n        }\n\n        if (Array.isArray(matchNode.match)) {\n            matchNode.match.forEach(findFragments);\n        }\n    }\n\n    const fragments = [];\n\n    if (match.matched !== null) {\n        findFragments(match.matched);\n    }\n\n    return fragments;\n}\n", "import { List } from '../utils/List.js';\n\nconst { hasOwnProperty } = Object.prototype;\n\nfunction isValidNumber(value) {\n    // Number.isInteger(value) && value >= 0\n    return (\n        typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value &&\n        value >= 0\n    );\n}\n\nfunction isValidLocation(loc) {\n    return (\n        Boolean(loc) &&\n        isValidNumber(loc.offset) &&\n        isValidNumber(loc.line) &&\n        isValidNumber(loc.column)\n    );\n}\n\nfunction createNodeStructureChecker(type, fields) {\n    return function checkNode(node, warn) {\n        if (!node || node.constructor !== Object) {\n            return warn(node, 'Type of node should be an Object');\n        }\n\n        for (let key in node) {\n            let valid = true;\n\n            if (hasOwnProperty.call(node, key) === false) {\n                continue;\n            }\n\n            if (key === 'type') {\n                if (node.type !== type) {\n                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                }\n            } else if (key === 'loc') {\n                if (node.loc === null) {\n                    continue;\n                } else if (node.loc && node.loc.constructor === Object) {\n                    if (typeof node.loc.source !== 'string') {\n                        key += '.source';\n                    } else if (!isValidLocation(node.loc.start)) {\n                        key += '.start';\n                    } else if (!isValidLocation(node.loc.end)) {\n                        key += '.end';\n                    } else {\n                        continue;\n                    }\n                }\n\n                valid = false;\n            } else if (fields.hasOwnProperty(key)) {\n                valid = false;\n\n                for (let i = 0; !valid && i < fields[key].length; i++) {\n                    const fieldType = fields[key][i];\n\n                    switch (fieldType) {\n                        case String:\n                            valid = typeof node[key] === 'string';\n                            break;\n\n                        case Boolean:\n                            valid = typeof node[key] === 'boolean';\n                            break;\n\n                        case null:\n                            valid = node[key] === null;\n                            break;\n\n                        default:\n                            if (typeof fieldType === 'string') {\n                                valid = node[key] && node[key].type === fieldType;\n                            } else if (Array.isArray(fieldType)) {\n                                valid = node[key] instanceof List;\n                            }\n                    }\n                }\n            } else {\n                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n            }\n\n            if (!valid) {\n                warn(node, 'Bad value for `' + type + '.' + key + '`');\n            }\n        }\n\n        for (const key in fields) {\n            if (hasOwnProperty.call(fields, key) &&\n                hasOwnProperty.call(node, key) === false) {\n                warn(node, 'Field `' + type + '.' + key + '` is missed');\n            }\n        }\n    };\n}\n\nfunction genTypesList(fieldTypes, path) {\n    const docsTypes = [];\n\n    for (let i = 0; i < fieldTypes.length; i++) {\n        const fieldType = fieldTypes[i];\n        if (fieldType === String || fieldType === Boolean) {\n            docsTypes.push(fieldType.name.toLowerCase());\n        } else if (fieldType === null) {\n            docsTypes.push('null');\n        } else if (typeof fieldType === 'string') {\n            docsTypes.push(fieldType);\n        } else if (Array.isArray(fieldType)) {\n            docsTypes.push('List<' + (genTypesList(fieldType, path) || 'any') + '>'); // TODO: use type enum\n        } else {\n            throw new Error('Wrong value `' + fieldType + '` in `' + path + '` structure definition');\n        }\n    }\n\n    return docsTypes.join(' | ');\n}\n\nfunction processStructure(name, nodeType) {\n    const structure = nodeType.structure;\n    const fields = {\n        type: String,\n        loc: true\n    };\n    const docs = {\n        type: '\"' + name + '\"'\n    };\n\n    for (const key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        const fieldTypes = fields[key] = Array.isArray(structure[key])\n            ? structure[key].slice()\n            : [structure[key]];\n\n        docs[key] = genTypesList(fieldTypes, name + '.' + key);\n    }\n\n    return {\n        docs,\n        check: createNodeStructureChecker(name, fields)\n    };\n}\n\nexport function getStructureFromConfig(config) {\n    const structure = {};\n\n    if (config.node) {\n        for (const name in config.node) {\n            if (hasOwnProperty.call(config.node, name)) {\n                const nodeType = config.node[name];\n\n                if (nodeType.structure) {\n                    structure[name] = processStructure(name, nodeType);\n                } else {\n                    throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                }\n            }\n        }\n    }\n\n    return structure;\n};\n", "import { SyntaxReferenceError, SyntaxMatchError } from './error.js';\nimport * as names from '../utils/names.js';\nimport { cssWideKeywords } from './generic-const.js';\nimport { createGenericTypes } from './generic.js';\nimport * as units from './units.js';\nimport { parse, generate, walk } from '../definition-syntax/index.js';\nimport prepareTokens from './prepare-tokens.js';\nimport { buildMatchGraph } from './match-graph.js';\nimport { matchAsTree } from './match.js';\nimport * as trace from './trace.js';\nimport { matchFragments } from './search.js';\nimport { getStructureFromConfig } from './structure.js';\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n    const result = {};\n\n    for (const name in map) {\n        if (map[name].syntax) {\n            result[name] = syntaxAsAst\n                ? map[name].syntax\n                : generate(map[name].syntax, { compact });\n        }\n    }\n\n    return result;\n}\n\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n    const result = {};\n\n    for (const [name, atrule] of Object.entries(map)) {\n        result[name] = {\n            prelude: atrule.prelude && (\n                syntaxAsAst\n                    ? atrule.prelude.syntax\n                    : generate(atrule.prelude.syntax, { compact })\n            ),\n            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n        };\n    }\n\n    return result;\n}\n\nfunction valueHasVar(tokens) {\n    for (let i = 0; i < tokens.length; i++) {\n        if (tokens[i].value.toLowerCase() === 'var(') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction syntaxHasTopLevelCommaMultiplier(syntax) {\n    const singleTerm = syntax.terms[0];\n\n    return (\n        syntax.explicit === false &&\n        syntax.terms.length === 1 &&\n        singleTerm.type === 'Multiplier' &&\n        singleTerm.comma === true\n    );\n}\n\nfunction buildMatchResult(matched, error, iterations) {\n    return {\n        matched,\n        iterations,\n        error,\n        ...trace\n    };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCssWideKeywords) {\n    const tokens = prepareTokens(value, lexer.syntax);\n    let result;\n\n    if (valueHasVar(tokens)) {\n        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n    }\n\n    if (useCssWideKeywords) {\n        result = matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);\n    }\n\n    if (!useCssWideKeywords || !result.match) {\n        result = matchAsTree(tokens, syntax.match, lexer);\n        if (!result.match) {\n            return buildMatchResult(\n                null,\n                new SyntaxMatchError(result.reason, syntax.syntax, value, result),\n                result.iterations\n            );\n        }\n    }\n\n    return buildMatchResult(result.match, null, result.iterations);\n}\n\nexport class Lexer {\n    constructor(config, syntax, structure) {\n        this.cssWideKeywords = cssWideKeywords;\n        this.syntax = syntax;\n        this.generic = false;\n        this.units = { ...units };\n        this.atrules = Object.create(null);\n        this.properties = Object.create(null);\n        this.types = Object.create(null);\n        this.structure = structure || getStructureFromConfig(config);\n\n        if (config) {\n            if (config.cssWideKeywords) {\n                this.cssWideKeywords = config.cssWideKeywords;\n            }\n\n            if (config.units) {\n                for (const group of Object.keys(units)) {\n                    if (Array.isArray(config.units[group])) {\n                        this.units[group] = config.units[group];\n                    }\n                }\n            }\n\n            if (config.types) {\n                for (const [name, type] of Object.entries(config.types)) {\n                    this.addType_(name, type);\n                }\n            }\n\n            if (config.generic) {\n                this.generic = true;\n                for (const [name, value] of Object.entries(createGenericTypes(this.units))) {\n                    this.addType_(name, value);\n                }\n            }\n\n            if (config.atrules) {\n                for (const [name, atrule] of Object.entries(config.atrules)) {\n                    this.addAtrule_(name, atrule);\n                }\n            }\n\n            if (config.properties) {\n                for (const [name, property] of Object.entries(config.properties)) {\n                    this.addProperty_(name, property);\n                }\n            }\n        }\n\n        this.cssWideKeywordsSyntax = buildMatchGraph(this.cssWideKeywords.join(' |  '));\n    }\n\n    checkStructure(ast) {\n        function collectWarning(node, message) {\n            warns.push({ node, message });\n        }\n\n        const structure = this.structure;\n        const warns = [];\n\n        this.syntax.walk(ast, function(node) {\n            if (structure.hasOwnProperty(node.type)) {\n                structure[node.type].check(node, collectWarning);\n            } else {\n                collectWarning(node, 'Unknown node type `' + node.type + '`');\n            }\n        });\n\n        return warns.length ? warns : false;\n    }\n\n    createDescriptor(syntax, type, name, parent = null) {\n        const ref = {\n            type,\n            name\n        };\n        const descriptor = {\n            type,\n            name,\n            parent,\n            serializable: typeof syntax === 'string' || (syntax && typeof syntax.type === 'string'),\n            syntax: null,\n            match: null,\n            matchRef: null // used for properties when a syntax referenced as <'property'> in other syntax definitions\n        };\n\n        if (typeof syntax === 'function') {\n            descriptor.match = buildMatchGraph(syntax, ref);\n        } else {\n            if (typeof syntax === 'string') {\n                // lazy parsing on first access\n                Object.defineProperty(descriptor, 'syntax', {\n                    get() {\n                        Object.defineProperty(descriptor, 'syntax', {\n                            value: parse(syntax)\n                        });\n\n                        return descriptor.syntax;\n                    }\n                });\n            } else {\n                descriptor.syntax = syntax;\n            }\n\n            // lazy graph build on first access\n            Object.defineProperty(descriptor, 'match', {\n                get() {\n                    Object.defineProperty(descriptor, 'match', {\n                        value: buildMatchGraph(descriptor.syntax, ref)\n                    });\n\n                    return descriptor.match;\n                }\n            });\n\n            if (type === 'Property') {\n                Object.defineProperty(descriptor, 'matchRef', {\n                    get() {\n                        const syntax = descriptor.syntax;\n                        const value = syntaxHasTopLevelCommaMultiplier(syntax)\n                            ? buildMatchGraph({\n                                ...syntax,\n                                terms: [syntax.terms[0].term]\n                            }, ref)\n                            : null;\n\n                        Object.defineProperty(descriptor, 'matchRef', {\n                            value\n                        });\n\n                        return value;\n                    }\n                });\n            }\n        }\n\n        return descriptor;\n    }\n    addAtrule_(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.atrules[name] = {\n            type: 'Atrule',\n            name: name,\n            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n            descriptors: syntax.descriptors\n                ? Object.keys(syntax.descriptors).reduce(\n                    (map, descName) => {\n                        map[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n                        return map;\n                    },\n                    Object.create(null)\n                )\n                : null\n        };\n    }\n    addProperty_(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n    }\n    addType_(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.types[name] = this.createDescriptor(syntax, 'Type', name);\n    }\n\n    checkAtruleName(atruleName) {\n        if (!this.getAtrule(atruleName)) {\n            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n        }\n    }\n    checkAtrulePrelude(atruleName, prelude) {\n        const error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        const atrule = this.getAtrule(atruleName);\n\n        if (!atrule.prelude && prelude) {\n            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n        }\n\n        if (atrule.prelude && !prelude) {\n            if (!matchSyntax(this, atrule.prelude, '', false).matched) {\n                return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n            }\n        }\n    }\n    checkAtruleDescriptorName(atruleName, descriptorName) {\n        const error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        const atrule = this.getAtrule(atruleName);\n        const descriptor = names.keyword(descriptorName);\n\n        if (!atrule.descriptors) {\n            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n        }\n\n        if (!atrule.descriptors[descriptor.name] &&\n            !atrule.descriptors[descriptor.basename]) {\n            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n        }\n    }\n    checkPropertyName(propertyName) {\n        if (!this.getProperty(propertyName)) {\n            return new SyntaxReferenceError('Unknown property', propertyName);\n        }\n    }\n\n    matchAtrulePrelude(atruleName, prelude) {\n        const error = this.checkAtrulePrelude(atruleName, prelude);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        const atrule = this.getAtrule(atruleName);\n\n        if (!atrule.prelude) {\n            return buildMatchResult(null, null);\n        }\n\n        return matchSyntax(this, atrule.prelude, prelude || '', false);\n    }\n    matchAtruleDescriptor(atruleName, descriptorName, value) {\n        const error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        const atrule = this.getAtrule(atruleName);\n        const descriptor = names.keyword(descriptorName);\n\n        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n    }\n    matchDeclaration(node) {\n        if (node.type !== 'Declaration') {\n            return buildMatchResult(null, new Error('Not a Declaration node'));\n        }\n\n        return this.matchProperty(node.property, node.value);\n    }\n    matchProperty(propertyName, value) {\n        // don't match syntax for a custom property at the moment\n        if (names.property(propertyName).custom) {\n            return buildMatchResult(null, new Error('Lexer matching doesn\\'t applicable for custom properties'));\n        }\n\n        const error = this.checkPropertyName(propertyName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        return matchSyntax(this, this.getProperty(propertyName), value, true);\n    }\n    matchType(typeName, value) {\n        const typeSyntax = this.getType(typeName);\n\n        if (!typeSyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n        }\n\n        return matchSyntax(this, typeSyntax, value, false);\n    }\n    match(syntax, value) {\n        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n        }\n\n        if (typeof syntax === 'string' || !syntax.match) {\n            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n        }\n\n        return matchSyntax(this, syntax, value, false);\n    }\n\n    findValueFragments(propertyName, value, type, name) {\n        return matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n    }\n    findDeclarationValueFragments(declaration, type, name) {\n        return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n    }\n    findAllFragments(ast, type, name) {\n        const result = [];\n\n        this.syntax.walk(ast, {\n            visit: 'Declaration',\n            enter: (declaration) => {\n                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n            }\n        });\n\n        return result;\n    }\n\n    getAtrule(atruleName, fallbackBasename = true) {\n        const atrule = names.keyword(atruleName);\n        const atruleEntry = atrule.vendor && fallbackBasename\n            ? this.atrules[atrule.name] || this.atrules[atrule.basename]\n            : this.atrules[atrule.name];\n\n        return atruleEntry || null;\n    }\n    getAtrulePrelude(atruleName, fallbackBasename = true) {\n        const atrule = this.getAtrule(atruleName, fallbackBasename);\n\n        return atrule && atrule.prelude || null;\n    }\n    getAtruleDescriptor(atruleName, name) {\n        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators\n            ? this.atrules[atruleName].declarators[name] || null\n            : null;\n    }\n    getProperty(propertyName, fallbackBasename = true) {\n        const property = names.property(propertyName);\n        const propertyEntry = property.vendor && fallbackBasename\n            ? this.properties[property.name] || this.properties[property.basename]\n            : this.properties[property.name];\n\n        return propertyEntry || null;\n    }\n    getType(name) {\n        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;\n    }\n\n    validate() {\n        function syntaxRef(name, isType) {\n            return isType ? `<${name}>` : `<'${name}'>`;\n        }\n\n        function validate(syntax, name, broken, descriptor) {\n            if (broken.has(name)) {\n                return broken.get(name);\n            }\n\n            broken.set(name, false);\n            if (descriptor.syntax !== null) {\n                walk(descriptor.syntax, function(node) {\n                    if (node.type !== 'Type' && node.type !== 'Property') {\n                        return;\n                    }\n\n                    const map = node.type === 'Type' ? syntax.types : syntax.properties;\n                    const brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                    if (!hasOwnProperty.call(map, node.name)) {\n                        errors.push(`${syntaxRef(name, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node.name, node.type === 'Type')}`);\n                        broken.set(name, true);\n                    } else if (validate(syntax, node.name, brokenMap, map[node.name])) {\n                        errors.push(`${syntaxRef(name, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node.name, node.type === 'Type')}`);\n                        broken.set(name, true);\n                    }\n                }, this);\n            }\n        }\n\n        const errors = [];\n        let brokenTypes = new Map();\n        let brokenProperties = new Map();\n\n        for (const key in this.types) {\n            validate(this, key, brokenTypes, this.types[key]);\n        }\n\n        for (const key in this.properties) {\n            validate(this, key, brokenProperties, this.properties[key]);\n        }\n\n        const brokenTypesArray = [...brokenTypes.keys()].filter(name => brokenTypes.get(name));\n        const brokenPropertiesArray = [...brokenProperties.keys()].filter(name => brokenProperties.get(name));\n\n        if (brokenTypesArray.length || brokenPropertiesArray.length) {\n            return {\n                errors,\n                types: brokenTypesArray,\n                properties: brokenPropertiesArray\n            };\n        }\n\n        return null;\n    }\n    dump(syntaxAsAst, pretty) {\n        return {\n            generic: this.generic,\n            cssWideKeywords: this.cssWideKeywords,\n            units: this.units,\n            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n        };\n    }\n    toString() {\n        return JSON.stringify(this.dump());\n    }\n};\n", "function appendOrSet(a, b) {\n    if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n        return typeof a === 'string'\n            ? a + b\n            : b.replace(/^\\s*\\|\\s*/, '');\n    }\n\n    return b || null;\n}\n\nfunction sliceProps(obj, props) {\n    const result = Object.create(null);\n\n    for (const [key, value] of Object.entries(obj)) {\n        if (value) {\n            result[key] = {};\n            for (const prop of Object.keys(value)) {\n                if (props.includes(prop)) {\n                    result[key][prop] = value[prop];\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default function mix(dest, src) {\n    const result = { ...dest };\n\n    for (const [prop, value] of Object.entries(src)) {\n        switch (prop) {\n            case 'generic':\n                result[prop] = Boolean(value);\n                break;\n\n            case 'cssWideKeywords':\n                result[prop] = dest[prop]\n                    ? [...dest[prop], ...value]\n                    : value || [];\n                break;\n\n            case 'units':\n                result[prop] = { ...dest[prop] };\n                for (const [name, patch] of Object.entries(value)) {\n                    result[prop][name] = Array.isArray(patch) ? patch : [];\n                }\n                break;\n\n            case 'atrules':\n                result[prop] = { ...dest[prop] };\n\n                for (const [name, atrule] of Object.entries(value)) {\n                    const exists = result[prop][name] || {};\n                    const current = result[prop][name] = {\n                        prelude: exists.prelude || null,\n                        descriptors: {\n                            ...exists.descriptors\n                        }\n                    };\n\n                    if (!atrule) {\n                        continue;\n                    }\n\n                    current.prelude = atrule.prelude\n                        ? appendOrSet(current.prelude, atrule.prelude)\n                        : current.prelude || null;\n\n                    for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {\n                        current.descriptors[descriptorName] = descriptorValue\n                            ? appendOrSet(current.descriptors[descriptorName], descriptorValue)\n                            : null;\n                    }\n\n                    if (!Object.keys(current.descriptors).length) {\n                        current.descriptors = null;\n                    }\n                }\n                break;\n\n            case 'types':\n            case 'properties':\n                result[prop] = { ...dest[prop] };\n                for (const [name, syntax] of Object.entries(value)) {\n                    result[prop][name] = appendOrSet(result[prop][name], syntax);\n                }\n                break;\n\n            case 'scope':\n            case 'features':\n                result[prop] = { ...dest[prop] };\n                for (const [name, props] of Object.entries(value)) {\n                    result[prop][name] = { ...result[prop][name], ...props };\n                }\n                break;\n\n            case 'parseContext':\n                result[prop] = {\n                    ...dest[prop],\n                    ...value\n                };\n                break;\n\n            case 'atrule':\n            case 'pseudo':\n                result[prop] = {\n                    ...dest[prop],\n                    ...sliceProps(value, ['parse'])\n                };\n                break;\n\n            case 'node':\n                result[prop] = {\n                    ...dest[prop],\n                    ...sliceProps(value, ['name', 'structure', 'parse', 'generate', 'walkContext'])\n                };\n                break;\n        }\n    }\n\n    return result;\n}\n", "import { tokenize } from '../tokenizer/index.js';\nimport { createParser } from '../parser/create.js';\nimport { createGenerator } from '../generator/create.js';\nimport { createConvertor } from '../convertor/create.js';\nimport { createWalker } from '../walker/create.js';\nimport { Lexer } from '../lexer/Lexer.js';\nimport mix from './config/mix.js';\n\nfunction createSyntax(config) {\n    const parse = createParser(config);\n    const walk = createWalker(config);\n    const generate = createGenerator(config);\n    const { fromPlainObject, toPlainObject } = createConvertor(walk);\n\n    const syntax = {\n        lexer: null,\n        createLexer: config => new Lexer(config, syntax, syntax.lexer.structure),\n\n        tokenize,\n        parse,\n        generate,\n\n        walk,\n        find: walk.find,\n        findLast: walk.findLast,\n        findAll: walk.findAll,\n\n        fromPlainObject,\n        toPlainObject,\n\n        fork(extension) {\n            const base = mix({}, config); // copy of config\n\n            return createSyntax(\n                typeof extension === 'function'\n                    ? extension(base) // TODO: remove Object.assign as second parameter\n                    : mix(base, extension)\n            );\n        }\n    };\n\n    syntax.lexer = new Lexer({\n        generic: config.generic,\n        cssWideKeywords: config.cssWideKeywords,\n        units: config.units,\n        types: config.types,\n        atrules: config.atrules,\n        properties: config.properties,\n        node: config.node\n    }, syntax);\n\n    return syntax;\n};\n\nexport default config => createSyntax(mix({}, config));\n", "import { createRequire } from 'module';\nimport patch from './data-patch.js';\n\nconst require = createRequire(import.meta.url);\nconst mdnAtrules = require('mdn-data/css/at-rules.json');\nconst mdnProperties = require('mdn-data/css/properties.json');\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\n\nconst hasOwn = Object.hasOwn || ((object, property) => Object.prototype.hasOwnProperty.call(object, property));\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n    const result = Object.create(null);\n\n    for (const [atruleName, atrule] of Object.entries(dict)) {\n        let descriptors = null;\n\n        if (atrule.descriptors) {\n            descriptors = Object.create(null);\n\n            for (const [name, descriptor] of Object.entries(atrule.descriptors)) {\n                descriptors[name] = descriptor.syntax;\n            }\n        }\n\n        result[atruleName.substr(1)] = {\n            prelude: atrule.syntax.trim().replace(/\\{(.|\\s)+\\}/, '').match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n            descriptors\n        };\n    }\n\n    return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n    const result = Object.create(null);\n\n    // copy all syntaxes for an original dict\n    for (const [key, value] of Object.entries(dict)) {\n        if (value) {\n            result[key] = value.syntax || value;\n        }\n    }\n\n    // apply a patch\n    for (const key of Object.keys(patchDict)) {\n        if (hasOwn(dict, key)) {\n            if (patchDict[key].syntax) {\n                result[key] = extendSyntax.test(patchDict[key].syntax)\n                    ? result[key] + ' ' + patchDict[key].syntax.trim()\n                    : patchDict[key].syntax;\n            } else {\n                delete result[key];\n            }\n        } else {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction preprocessPatchAtrulesDescritors(declarations) {\n    const result = {};\n\n    for (const [key, value] of Object.entries(declarations || {})) {\n        result[key] = typeof value === 'string'\n            ? { syntax: value }\n            : value;\n    }\n\n    return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        if (patchDict[key] === null) {\n            continue;\n        }\n\n        const atrulePatch = patchDict[key] || {};\n\n        result[key] = {\n            prelude: key in patchDict && 'prelude' in atrulePatch\n                ? atrulePatch.prelude\n                : dict[key].prelude || null,\n            descriptors: patchDictionary(\n                dict[key].descriptors || {},\n                preprocessPatchAtrulesDescritors(atrulePatch.descriptors)\n            )\n        };\n    }\n\n    // apply a patch\n    for (const [key, atrulePatch] of Object.entries(patchDict)) {\n        if (atrulePatch && !hasOwn(dict, key)) {\n            result[key] = {\n                prelude: atrulePatch.prelude || null,\n                descriptors: atrulePatch.descriptors\n                    ? patchDictionary({}, preprocessPatchAtrulesDescritors(atrulePatch.descriptors))\n                    : null\n            };\n        }\n    }\n\n    return result;\n}\n\nexport default {\n    types: patchDictionary(mdnSyntaxes, patch.types),\n    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n    properties: patchDictionary(mdnProperties, patch.properties)\n};\n", "import { createRequire } from 'module';\n\nconst require = createRequire(import.meta.url);\nconst patch = require('../data/patch.json');\n\nexport default patch;\n", "export * as AnPlusB from './AnPlusB.js';\nexport * as Atrule from './Atrule.js';\nexport * as AtrulePrelude from './AtrulePrelude.js';\nexport * as AttributeSelector from './AttributeSelector.js';\nexport * as Block from './Block.js';\nexport * as Brackets from './Brackets.js';\nexport * as CDC from './CDC.js';\nexport * as CDO from './CDO.js';\nexport * as ClassSelector from './ClassSelector.js';\nexport * as Combinator from './Combinator.js';\nexport * as Comment from './Comment.js';\nexport * as Condition from './Condition.js';\nexport * as Declaration from './Declaration.js';\nexport * as DeclarationList from './DeclarationList.js';\nexport * as Dimension from './Dimension.js';\nexport * as Feature from './Feature.js';\nexport * as FeatureFunction from './FeatureFunction.js';\nexport * as FeatureRange from './FeatureRange.js';\nexport * as Function from './Function.js';\nexport * as GeneralEnclosed from './GeneralEnclosed.js';\nexport * as Hash from './Hash.js';\nexport * as Identifier from './Identifier.js';\nexport * as IdSelector from './IdSelector.js';\nexport * as Layer from './Layer.js';\nexport * as LayerList from './LayerList.js';\nexport * as MediaQuery from './MediaQuery.js';\nexport * as MediaQueryList from './MediaQueryList.js';\nexport * as NestingSelector from './NestingSelector.js';\nexport * as Nth from './Nth.js';\nexport * as Number from './Number.js';\nexport * as Operator from './Operator.js';\nexport * as Parentheses from './Parentheses.js';\nexport * as Percentage from './Percentage.js';\nexport * as PseudoClassSelector from './PseudoClassSelector.js';\nexport * as PseudoElementSelector from './PseudoElementSelector.js';\nexport * as Ratio from './Ratio.js';\nexport * as Raw from './Raw.js';\nexport * as Rule from './Rule.js';\nexport * as Scope from './Scope.js';\nexport * as Selector from './Selector.js';\nexport * as SelectorList from './SelectorList.js';\nexport * as String from './String.js';\nexport * as StyleSheet from './StyleSheet.js';\nexport * as SupportsDeclaration from './SupportsDeclaration.js';\nexport * as TypeSelector from './TypeSelector.js';\nexport * as UnicodeRange from './UnicodeRange.js';\nexport * as Url from './Url.js';\nexport * as Value from './Value.js';\nexport * as WhiteSpace from './WhiteSpace.js';\n", "import {\n    isDigit,\n    WhiteSpace,\n    Comment,\n    Ident,\n    Number,\n    Dimension\n} from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\n\nfunction checkInteger(offset, disallowSign) {\n    let pos = this.tokenStart + offset;\n    const code = this.charCodeAt(pos);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            this.error('Number sign is not allowed');\n        }\n        pos++;\n    }\n\n    for (; pos < this.tokenEnd; pos++) {\n        if (!isDigit(this.charCodeAt(pos))) {\n            this.error('Integer is expected', pos);\n        }\n    }\n}\n\nfunction checkTokenIsInteger(disallowSign) {\n    return checkInteger.call(this, 0, disallowSign);\n}\n\nfunction expectCharCode(offset, code) {\n    if (!this.cmpChar(this.tokenStart + offset, code)) {\n        let msg = '';\n\n        switch (code) {\n            case N:\n                msg = 'N is expected';\n                break;\n            case HYPHENMINUS:\n                msg = 'HyphenMinus is expected';\n                break;\n        }\n\n        this.error(msg, this.tokenStart + offset);\n    }\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB() {\n    let offset = 0;\n    let sign = 0;\n    let type = this.tokenType;\n\n    while (type === WhiteSpace || type === Comment) {\n        type = this.lookupType(++offset);\n    }\n\n    if (type !== Number) {\n        if (this.isDelim(PLUSSIGN, offset) ||\n            this.isDelim(HYPHENMINUS, offset)) {\n            sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;\n\n            do {\n                type = this.lookupType(++offset);\n            } while (type === WhiteSpace || type === Comment);\n\n            if (type !== Number) {\n                this.skip(offset);\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    if (offset > 0) {\n        this.skip(offset);\n    }\n\n    if (sign === 0) {\n        type = this.charCodeAt(this.tokenStart);\n        if (type !== PLUSSIGN && type !== HYPHENMINUS) {\n            this.error('Number sign is expected');\n        }\n    }\n\n    checkTokenIsInteger.call(this, sign !== 0);\n    return sign === HYPHENMINUS ? '-' + this.consume(Number) : this.consume(Number);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nexport const name = 'AnPlusB';\nexport const structure = {\n    a: [String, null],\n    b: [String, null]\n};\n\nexport function parse() {\n    /* eslint-disable brace-style*/\n    const start = this.tokenStart;\n    let a = null;\n    let b = null;\n\n    // <integer>\n    if (this.tokenType === Number) {\n        checkTokenIsInteger.call(this, ALLOW_SIGN);\n        b = this.consume(Number);\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {\n        a = '-1';\n\n        expectCharCode.call(this, 1, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // -n- <signless-integer>\n            case 3:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(Number);\n                break;\n\n            // <dashndashdigit-ident>\n            default:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n                checkInteger.call(this, 3, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + 2);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (this.tokenType === Ident || (this.isDelim(PLUSSIGN) && this.lookupType(1) === Ident)) {\n        let sign = 0;\n        a = '1';\n\n        // just ignore a plus\n        if (this.isDelim(PLUSSIGN)) {\n            sign = 1;\n            this.next();\n        }\n\n        expectCharCode.call(this, 0, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // '+'? n- <signless-integer>\n            case 2:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(Number);\n                break;\n\n            // '+'? <ndashdigit-ident>\n            default:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n                checkInteger.call(this, 2, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + sign + 1);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (this.tokenType === Dimension) {\n        const code = this.charCodeAt(this.tokenStart);\n        const sign = code === PLUSSIGN || code === HYPHENMINUS;\n        let i = this.tokenStart + sign;\n\n        for (; i < this.tokenEnd; i++) {\n            if (!isDigit(this.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === this.tokenStart + sign) {\n            this.error('Integer is expected', this.tokenStart + sign);\n        }\n\n        expectCharCode.call(this, i - this.tokenStart, N);\n        a = this.substring(start, i);\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === this.tokenEnd) {\n            this.next();\n            b = consumeB.call(this);\n        } else {\n            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === this.tokenEnd) {\n                this.next();\n                this.skipSC();\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n                b = '-' + this.consume(Number);\n            }\n            // <ndashdigit-dimension>\n            else {\n                checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);\n                this.next();\n                b = this.substrToCursor(i + 1);\n            }\n        }\n    } else {\n        this.error();\n    }\n\n    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {\n        a = a.substr(1);\n    }\n\n    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {\n        b = b.substr(1);\n    }\n\n    return {\n        type: 'AnPlusB',\n        loc: this.getLocation(start, this.tokenStart),\n        a,\n        b\n    };\n}\n\nexport function generate(node) {\n    if (node.a) {\n        const a =\n            node.a === '+1' && 'n' ||\n            node.a ===  '1' && 'n' ||\n            node.a === '-1' && '-n' ||\n            node.a + 'n';\n\n        if (node.b) {\n            const b = node.b[0] === '-' || node.b[0] === '+'\n                ? node.b\n                : '+' + node.b;\n            this.tokenize(a + b);\n        } else {\n            this.tokenize(a);\n        }\n    } else {\n        this.tokenize(node.b);\n    }\n}\n", "import {\n    AtKeyword,\n    Semicolon,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from '../../tokenizer/index.js';\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);\n}\n\nfunction isDeclarationBlockAtrule() {\n    for (let offset = 1, type; type = this.lookupType(offset); offset++) {\n        if (type === RightCurlyBracket) {\n            return true;\n        }\n\n        if (type === LeftCurlyBracket ||\n            type === AtKeyword) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n\nexport const name = 'Atrule';\nexport const walkContext = 'atrule';\nexport const structure = {\n    name: String,\n    prelude: ['AtrulePrelude', 'Raw', null],\n    block: ['Block', null]\n};\n\nexport function parse(isDeclaration = false) {\n    const start = this.tokenStart;\n    let name;\n    let nameLowerCase;\n    let prelude = null;\n    let block = null;\n\n    this.eat(AtKeyword);\n\n    name = this.substrToCursor(start + 1);\n    nameLowerCase = name.toLowerCase();\n    this.skipSC();\n\n    // parse prelude\n    if (this.eof === false &&\n        this.tokenType !== LeftCurlyBracket &&\n        this.tokenType !== Semicolon) {\n        if (this.parseAtrulePrelude) {\n            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw);\n        } else {\n            prelude = consumeRaw.call(this, this.tokenIndex);\n        }\n\n        this.skipSC();\n    }\n\n    switch (this.tokenType) {\n        case Semicolon:\n            this.next();\n            break;\n\n        case LeftCurlyBracket:\n            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&\n                typeof this.atrule[nameLowerCase].block === 'function') {\n                block = this.atrule[nameLowerCase].block.call(this, isDeclaration);\n            } else {\n                // TODO: should consume block content as Raw?\n                block = this.Block(isDeclarationBlockAtrule.call(this));\n            }\n\n            break;\n    }\n\n    return {\n        type: 'Atrule',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        prelude,\n        block\n    };\n}\n\nexport function generate(node) {\n    this.token(AtKeyword, '@' + node.name);\n\n    if (node.prelude !== null) {\n        this.node(node.prelude);\n    }\n\n    if (node.block) {\n        this.node(node.block);\n    } else {\n        this.token(Semicolon, ';');\n    }\n}\n", "import {\n    Semicolon,\n    LeftCurlyBracket\n} from '../../tokenizer/index.js';\n\nexport const name = 'AtrulePrelude';\nexport const walkContext = 'atrulePrelude';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(name) {\n    let children = null;\n\n    if (name !== null) {\n        name = name.toLowerCase();\n    }\n\n    this.skipSC();\n\n    if (hasOwnProperty.call(this.atrule, name) &&\n        typeof this.atrule[name].prelude === 'function') {\n        // custom consumer\n        children = this.atrule[name].prelude.call(this);\n    } else {\n        // default consumer\n        children = this.readSequence(this.scope.AtrulePrelude);\n    }\n\n    this.skipSC();\n\n    if (this.eof !== true &&\n        this.tokenType !== LeftCurlyBracket &&\n        this.tokenType !== Semicolon) {\n        this.error('Semicolon or block is expected');\n    }\n\n    return {\n        type: 'AtrulePrelude',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import {\n    Ident,\n    String as StringToken,\n    Delim,\n    LeftSquareBracket,\n    RightSquareBracket\n} from '../../tokenizer/index.js';\n\nconst DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)\nconst ASTERISK = 0x002A;         // U+002A ASTERISK (*)\nconst EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)\nconst CIRCUMFLEXACCENT = 0x005E; // U+005E (^)\nconst VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;            // U+007E TILDE (~)\n\nfunction getAttributeName() {\n    if (this.eof) {\n        this.error('Unexpected end of input');\n    }\n\n    const start = this.tokenStart;\n    let expectIdent = false;\n\n    if (this.isDelim(ASTERISK)) {\n        expectIdent = true;\n        this.next();\n    } else if (!this.isDelim(VERTICALLINE)) {\n        this.eat(Ident);\n    }\n\n    if (this.isDelim(VERTICALLINE)) {\n        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {\n            this.next();\n            this.eat(Ident);\n        } else if (expectIdent) {\n            this.error('Identifier is expected', this.tokenEnd);\n        }\n    } else if (expectIdent) {\n        this.error('Vertical line is expected');\n    }\n\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nfunction getOperator() {\n    const start = this.tokenStart;\n    const code = this.charCodeAt(start);\n\n    if (code !== EQUALSSIGN &&        // =\n        code !== TILDE &&             // ~=\n        code !== CIRCUMFLEXACCENT &&  // ^=\n        code !== DOLLARSIGN &&        // $=\n        code !== ASTERISK &&          // *=\n        code !== VERTICALLINE         // |=\n    ) {\n        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n    }\n\n    this.next();\n\n    if (code !== EQUALSSIGN) {\n        if (!this.isDelim(EQUALSSIGN)) {\n            this.error('Equal sign is expected');\n        }\n\n        this.next();\n    }\n\n    return this.substrToCursor(start);\n}\n\n// '[' <wq-name> ']'\n// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\nexport const name = 'AttributeSelector';\nexport const structure = {\n    name: 'Identifier',\n    matcher: [String, null],\n    value: ['String', 'Identifier', null],\n    flags: [String, null]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let name;\n    let matcher = null;\n    let value = null;\n    let flags = null;\n\n    this.eat(LeftSquareBracket);\n    this.skipSC();\n\n    name = getAttributeName.call(this);\n    this.skipSC();\n\n    if (this.tokenType !== RightSquareBracket) {\n        // avoid case `[name i]`\n        if (this.tokenType !== Ident) {\n            matcher = getOperator.call(this);\n\n            this.skipSC();\n\n            value = this.tokenType === StringToken\n                ? this.String()\n                : this.Identifier();\n\n            this.skipSC();\n        }\n\n        // attribute flags\n        if (this.tokenType === Ident) {\n            flags = this.consume(Ident);\n\n            this.skipSC();\n        }\n    }\n\n    this.eat(RightSquareBracket);\n\n    return {\n        type: 'AttributeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        matcher,\n        value,\n        flags\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '[');\n    this.node(node.name);\n\n    if (node.matcher !== null) {\n        this.tokenize(node.matcher);\n        this.node(node.value);\n    }\n\n    if (node.flags !== null) {\n        this.token(Ident, node.flags);\n    }\n\n    this.token(Delim, ']');\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    Semicolon,\n    AtKeyword,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw() {\n    return this.Raw(null, true);\n}\nfunction consumeRule() {\n    return this.parseWithFallback(this.Rule, consumeRaw);\n}\nfunction consumeRawDeclaration() {\n    return this.Raw(this.consumeUntilSemicolonIncluded, true);\n}\nfunction consumeDeclaration() {\n    if (this.tokenType === Semicolon) {\n        return consumeRawDeclaration.call(this, this.tokenIndex);\n    }\n\n    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);\n\n    if (this.tokenType === Semicolon) {\n        this.next();\n    }\n\n    return node;\n}\n\nexport const name = 'Block';\nexport const walkContext = 'block';\nexport const structure = {\n    children: [[\n        'Atrule',\n        'Rule',\n        'Declaration'\n    ]]\n};\n\nexport function parse(isStyleBlock) {\n    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;\n    const start = this.tokenStart;\n    let children = this.createList();\n\n    this.eat(LeftCurlyBracket);\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case RightCurlyBracket:\n                break scan;\n\n            case WhiteSpace:\n            case Comment:\n                this.next();\n                break;\n\n            case AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));\n                break;\n\n            default:\n                if (isStyleBlock && this.isDelim(AMPERSAND))  {\n                    children.push(consumeRule.call(this));\n                } else {\n                    children.push(consumer.call(this));\n                }\n        }\n    }\n\n    if (!this.eof) {\n        this.eat(RightCurlyBracket);\n    }\n\n    return {\n        type: 'Block',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftCurlyBracket, '{');\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(Semicolon, ';');\n        }\n    });\n    this.token(RightCurlyBracket, '}');\n}\n", "import {\n    Delim,\n    LeftSquareBracket,\n    RightSquareBracket\n} from '../../tokenizer/index.js';\n\nexport const name = 'Brackets';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(LeftSquareBracket);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightSquareBracket);\n    }\n\n    return {\n        type: 'Brackets',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '[');\n    this.children(node);\n    this.token(Delim, ']');\n}\n", "import { CDC } from '../../tokenizer/index.js';\n\nexport const name = 'CDC';\nexport const structure = [];\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(CDC); // -->\n\n    return {\n        type: 'CDC',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(CDC, '-->');\n}\n", "import { CDO } from '../../tokenizer/index.js';\n\nexport const name = 'CDO';\nexport const structure = [];\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(CDO); // <!--\n\n    return {\n        type: 'CDO',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(CDO, '<!--');\n}\n", "import { Delim, Ident } from '../../tokenizer/index.js';\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// '.' ident\nexport const name = 'ClassSelector';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    this.eatDelim(FULLSTOP);\n\n    return {\n        type: 'ClassSelector',\n        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),\n        name: this.consume(Ident)\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '.');\n    this.token(Ident, node.name);\n}\n", "import { WhiteSpace, Delim } from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nexport const name = 'Combinator';\nexport const structure = {\n    name: String\n};\n\n// + | > | ~ | /deep/\nexport function parse() {\n    const start = this.tokenStart;\n    let name;\n\n    switch (this.tokenType) {\n        case WhiteSpace:\n            name = ' ';\n            break;\n\n        case Delim:\n            switch (this.charCodeAt(this.tokenStart)) {\n                case GREATERTHANSIGN:\n                case PLUSSIGN:\n                case TILDE:\n                    this.next();\n                    break;\n\n                case SOLIDUS:\n                    this.next();\n                    this.eatIdent('deep');\n                    this.eatDelim(SOLIDUS);\n                    break;\n\n                default:\n                    this.error('Combinator is expected');\n            }\n\n            name = this.substrToCursor(start);\n            break;\n    }\n\n    return {\n        type: 'Combinator',\n        loc: this.getLocation(start, this.tokenStart),\n        name\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n", "import { Comment } from '../../tokenizer/index.js';\n\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\n\nexport const name = 'Comment';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let end = this.tokenEnd;\n\n    this.eat(Comment);\n\n    if ((end - start + 2) >= 2 &&\n        this.charCodeAt(end - 2) === ASTERISK &&\n        this.charCodeAt(end - 1) === SOLIDUS) {\n        end -= 2;\n    }\n\n    return {\n        type: 'Comment',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substring(start + 2, end)\n    };\n}\n\nexport function generate(node) {\n    this.token(Comment, '/*' + node.value + '*/');\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    Ident,\n    LeftParenthesis,\n    RightParenthesis,\n    Function as FunctionToken,\n    Colon,\n    EOF\n} from '../../tokenizer/index.js';\n\nconst likelyFeatureToken = new Set([Colon, RightParenthesis, EOF]);\n\nexport const name = 'Condition';\nexport const structure = {\n    kind: String,\n    children: [[\n        'Identifier',\n        'Feature',\n        'FeatureFunction',\n        'FeatureRange',\n        'SupportsDeclaration'\n    ]]\n};\n\nfunction featureOrRange(kind) {\n    if (this.lookupTypeNonSC(1) === Ident &&\n        likelyFeatureToken.has(this.lookupTypeNonSC(2))) {\n        return this.Feature(kind);\n    }\n\n    return this.FeatureRange(kind);\n}\n\nconst parentheses = {\n    media: featureOrRange,\n    container: featureOrRange,\n    supports() {\n        return this.SupportsDeclaration();\n    }\n};\n\nexport function parse(kind = 'media') {\n    const children = this.createList();\n\n    scan: while (!this.eof) {\n        switch (this.tokenType) {\n            case Comment:\n            case WhiteSpace:\n                this.next();\n                continue;\n\n            case Ident:\n                children.push(this.Identifier());\n                break;\n\n            case LeftParenthesis: {\n                let term = this.parseWithFallback(\n                    () => parentheses[kind].call(this, kind),\n                    () => null\n                );\n\n                if (!term) {\n                    term = this.parseWithFallback(\n                        () => {\n                            this.eat(LeftParenthesis);\n                            const res = this.Condition(kind);\n                            this.eat(RightParenthesis);\n                            return res;\n                        },\n                        () => {\n                            return this.GeneralEnclosed(kind);\n                        }\n                    );\n                }\n\n                children.push(term);\n                break;\n            }\n\n            case FunctionToken: {\n                let term = this.parseWithFallback(\n                    () => this.FeatureFunction(kind),\n                    () => null\n                );\n\n                if (!term) {\n                    term = this.GeneralEnclosed(kind);\n                }\n\n                children.push(term);\n                break;\n            }\n\n            default:\n                break scan;\n        }\n    }\n\n    if (children.isEmpty) {\n        this.error('Condition is expected');\n    }\n\n    return {\n        type: 'Condition',\n        loc: this.getLocationFromList(children),\n        kind,\n        children\n    };\n}\n\nexport function generate(node) {\n    node.children.forEach(child => {\n        if (child.type === 'Condition') {\n            this.token(LeftParenthesis, '(');\n            this.node(child);\n            this.token(RightParenthesis, ')');\n        } else {\n            this.node(child);\n        }\n    });\n}\n\n", "import { isCustomProperty } from '../../utils/names.js';\nimport {\n    Ident,\n    Hash,\n    Colon,\n    Semicolon,\n    Delim,\n    WhiteSpace\n} from '../../tokenizer/index.js';\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\nfunction consumeValueRaw() {\n    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);\n}\n\nfunction consumeCustomPropertyRaw() {\n    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);\n}\n\nfunction consumeValue() {\n    const startValueToken = this.tokenIndex;\n    const value = this.Value();\n\n    if (value.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== Semicolon &&\n        this.isDelim(EXCLAMATIONMARK) === false &&\n        this.isBalanceEdge(startValueToken) === false) {\n        this.error();\n    }\n\n    return value;\n}\n\nexport const name = 'Declaration';\nexport const walkContext = 'declaration';\nexport const structure = {\n    important: [Boolean, String],\n    property: String,\n    value: ['Value', 'Raw']\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const startToken = this.tokenIndex;\n    const property = readProperty.call(this);\n    const customProperty = isCustomProperty(property);\n    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;\n    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;\n    let important = false;\n    let value;\n\n    this.skipSC();\n    this.eat(Colon);\n\n    const valueStart = this.tokenIndex;\n\n    if (!customProperty) {\n        this.skipSC();\n    }\n\n    if (parseValue) {\n        value = this.parseWithFallback(consumeValue, consumeRaw);\n    } else {\n        value = consumeRaw.call(this, this.tokenIndex);\n    }\n\n    if (customProperty && value.type === 'Value' && value.children.isEmpty) {\n        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {\n            if (this.lookupType(offset) === WhiteSpace) {\n                value.children.appendData({\n                    type: 'WhiteSpace',\n                    loc: null,\n                    value: ' '\n                });\n                break;\n            }\n        }\n    }\n\n    if (this.isDelim(EXCLAMATIONMARK)) {\n        important = getImportant.call(this);\n        this.skipSC();\n    }\n\n    // Do not include semicolon to range per spec\n    // https://drafts.csswg.org/css-syntax/#declaration-diagram\n\n    if (this.eof === false &&\n        this.tokenType !== Semicolon &&\n        this.isBalanceEdge(startToken) === false) {\n        this.error();\n    }\n\n    return {\n        type: 'Declaration',\n        loc: this.getLocation(start, this.tokenStart),\n        important,\n        property,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(Ident, node.property);\n    this.token(Colon, ':');\n    this.node(node.value);\n\n    if (node.important) {\n        this.token(Delim, '!');\n        this.token(Ident, node.important === true ? 'important' : node.important);\n    }\n}\n\nfunction readProperty() {\n    const start = this.tokenStart;\n\n    // hacks\n    if (this.tokenType === Delim) {\n        switch (this.charCodeAt(this.tokenStart)) {\n            case ASTERISK:\n            case DOLLARSIGN:\n            case PLUSSIGN:\n            case NUMBERSIGN:\n            case AMPERSAND:\n                this.next();\n                break;\n\n            // TODO: not sure we should support this hack\n            case SOLIDUS:\n                this.next();\n                if (this.isDelim(SOLIDUS)) {\n                    this.next();\n                }\n                break;\n        }\n    }\n\n    if (this.tokenType === Hash) {\n        this.eat(Hash);\n    } else {\n        this.eat(Ident);\n    }\n\n    return this.substrToCursor(start);\n}\n\n// ! ws* important\nfunction getImportant() {\n    this.eat(Delim);\n    this.skipSC();\n\n    const important = this.consume(Ident);\n\n    // store original value in case it differ from `important`\n    // for better original source restoring and hacks like `!ie` support\n    return important === 'important' ? true : important;\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    Semicolon,\n    AtKeyword\n} from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilSemicolonIncluded, true);\n}\n\nexport const name = 'DeclarationList';\nexport const structure = {\n    children: [[\n        'Declaration',\n        'Atrule',\n        'Rule'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case WhiteSpace:\n            case Comment:\n            case Semicolon:\n                this.next();\n                break;\n\n            case AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));\n                break;\n\n            default:\n                if (this.isDelim(AMPERSAND))  {\n                    children.push(this.parseWithFallback(this.Rule, consumeRaw));\n                } else {\n                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));\n                }\n        }\n    }\n\n    return {\n        type: 'DeclarationList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(Semicolon, ';');\n        }\n    });\n}\n\n", "import { Dimension } from '../../tokenizer/index.js';\n\nexport const name = 'Dimension';\nexport const structure = {\n    value: String,\n    unit: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const value = this.consumeNumber(Dimension);\n\n    return {\n        type: 'Dimension',\n        loc: this.getLocation(start, this.tokenStart),\n        value,\n        unit: this.substring(start + value.length, this.tokenStart)\n    };\n}\n\nexport function generate(node) {\n    this.token(Dimension, node.value + node.unit);\n}\n", "import {\n    Ident,\n    Number,\n    Dimension,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    Colon,\n    Delim\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\n\nexport const name = 'Feature';\nexport const structure = {\n    kind: String,\n    name: String,\n    value: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function', null]\n};\n\nexport function parse(kind) {\n    const start = this.tokenStart;\n    let name;\n    let value = null;\n\n    this.eat(LeftParenthesis);\n    this.skipSC();\n\n    name = this.consume(Ident);\n    this.skipSC();\n\n    if (this.tokenType !== RightParenthesis) {\n        this.eat(Colon);\n        this.skipSC();\n\n        switch (this.tokenType) {\n            case Number:\n                if (this.lookupNonWSType(1) === Delim) {\n                    value = this.Ratio();\n                } else {\n                    value = this.Number();\n                }\n\n                break;\n\n            case Dimension:\n                value = this.Dimension();\n                break;\n\n            case Ident:\n                value = this.Identifier();\n                break;\n\n            case FunctionToken:\n                value = this.parseWithFallback(\n                    () => {\n                        const res = this.Function(this.readSequence, this.scope.Value);\n\n                        this.skipSC();\n\n                        if (this.isDelim(SOLIDUS)) {\n                            this.error();\n                        }\n\n                        return res;\n                    },\n                    () => {\n                        return this.Ratio();\n                    }\n                );\n                break;\n\n            default:\n                this.error('Number, dimension, ratio or identifier is expected');\n        }\n\n        this.skipSC();\n    }\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Feature',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        name,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.token(Ident, node.name);\n\n    if (node.value !== null) {\n        this.token(Colon, ':');\n        this.node(node.value);\n    }\n\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Function as FunctionToken,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'FeatureFunction';\nexport const structure = {\n    kind: String,\n    feature: String,\n    value: ['Declaration', 'Selector']\n};\n\nfunction getFeatureParser(kind, name) {\n    const featuresOfKind = this.features[kind] || {};\n    const parser = featuresOfKind[name];\n\n    if (typeof parser !== 'function') {\n        this.error(`Unknown feature ${name}()`);\n    }\n\n    return parser;\n}\n\nexport function parse(kind = 'unknown') {\n    const start = this.tokenStart;\n    const functionName = this.consumeFunctionName();\n    const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());\n\n    this.skipSC();\n\n    const value = this.parseWithFallback(\n        () => {\n            const startValueToken = this.tokenIndex;\n            const value = valueParser.call(this);\n\n            if (this.eof === false &&\n                this.isBalanceEdge(startValueToken) === false) {\n                this.error();\n            }\n\n            return value;\n        },\n        () => this.Raw(null, false)\n    );\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'FeatureFunction',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        feature: functionName,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(FunctionToken, node.feature + '(');\n    this.node(node.value);\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Ident,\n    Number,\n    Dimension,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst LESSTHANSIGN = 0x003C;    // U+003C LESS-THAN SIGN (<)\nconst EQUALSSIGN = 0x003D;      // U+003D EQUALS SIGN (=)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\n\nexport const name = 'FeatureRange';\nexport const structure = {\n    kind: String,\n    left: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function'],\n    leftComparison: String,\n    middle: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function'],\n    rightComparison: [String, null],\n    right: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function', null]\n};\n\nfunction readTerm() {\n    this.skipSC();\n\n    switch (this.tokenType) {\n        case Number:\n            if (this.isDelim(SOLIDUS, this.lookupOffsetNonSC(1))) {\n                return this.Ratio();\n            } else {\n                return this.Number();\n            }\n\n        case Dimension:\n            return this.Dimension();\n\n        case Ident:\n            return this.Identifier();\n\n        case FunctionToken:\n            return this.parseWithFallback(\n                () => {\n                    const res = this.Function(this.readSequence, this.scope.Value);\n\n                    this.skipSC();\n\n                    if (this.isDelim(SOLIDUS)) {\n                        this.error();\n                    }\n\n                    return res;\n                },\n                () => {\n                    return this.Ratio();\n                }\n            );\n\n        default:\n            this.error('Number, dimension, ratio or identifier is expected');\n    }\n}\n\nfunction readComparison(expectColon) {\n    this.skipSC();\n\n    if (this.isDelim(LESSTHANSIGN) ||\n        this.isDelim(GREATERTHANSIGN)) {\n        const value = this.source[this.tokenStart];\n\n        this.next();\n\n        if (this.isDelim(EQUALSSIGN)) {\n            this.next();\n            return value + '=';\n        }\n\n        return value;\n    }\n\n    if (this.isDelim(EQUALSSIGN)) {\n        return '=';\n    }\n\n    this.error(`Expected ${expectColon ? '\":\", ' : ''}\"<\", \">\", \"=\" or \")\"`);\n}\n\nexport function parse(kind = 'unknown') {\n    const start = this.tokenStart;\n\n    this.skipSC();\n    this.eat(LeftParenthesis);\n\n    const left = readTerm.call(this);\n    const leftComparison = readComparison.call(this, left.type === 'Identifier');\n    const middle = readTerm.call(this);\n    let rightComparison = null;\n    let right = null;\n\n    if (this.lookupNonWSType(0) !== RightParenthesis) {\n        rightComparison = readComparison.call(this);\n        right = readTerm.call(this);\n    }\n\n    this.skipSC();\n    this.eat(RightParenthesis);\n\n    return {\n        type: 'FeatureRange',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        left,\n        leftComparison,\n        middle,\n        rightComparison,\n        right\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.node(node.left);\n    this.tokenize(node.leftComparison);\n    this.node(node.middle);\n\n    if (node.right) {\n        this.tokenize(node.rightComparison);\n        this.node(node.right);\n    }\n\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Function as FunctionToken,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'Function';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [[]]\n};\n\n// <function-token> <sequence> )\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    const name = this.consumeFunctionName();\n    const nameLowerCase = name.toLowerCase();\n    let children;\n\n    children = recognizer.hasOwnProperty(nameLowerCase)\n        ? recognizer[nameLowerCase].call(this, recognizer)\n        : readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Function',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(FunctionToken, node.name + '(');\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'GeneralEnclosed';\nexport const structure = {\n    kind: String,\n    function: [String, null],\n    children: [[]]\n};\n\n// <function-token> <any-value> )\n// ( <any-value> )\nexport function parse(kind) {\n    const start = this.tokenStart;\n    let functionName = null;\n\n    if (this.tokenType === FunctionToken) {\n        functionName = this.consumeFunctionName();\n    } else {\n        this.eat(LeftParenthesis);\n    }\n\n    const children = this.parseWithFallback(\n        () => {\n            const startValueToken = this.tokenIndex;\n            const children = this.readSequence(this.scope.Value);\n\n            if (this.eof === false &&\n                this.isBalanceEdge(startValueToken) === false) {\n                this.error();\n            }\n\n            return children;\n        },\n        () => this.createSingleNodeList(\n            this.Raw(null, false)\n        )\n    );\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'GeneralEnclosed',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        function: functionName,\n        children\n    };\n}\n\nexport function generate(node) {\n    if (node.function) {\n        this.token(FunctionToken, node.function + '(');\n    } else {\n        this.token(LeftParenthesis, '(');\n    }\n\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n", "import { Hash } from '../../tokenizer/index.js';\n\n// '#' ident\nexport const xxx = 'XXX';\nexport const name = 'Hash';\nexport const structure = {\n    value: String\n};\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(Hash);\n\n    return {\n        type: 'Hash',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start + 1)\n    };\n}\nexport function generate(node) {\n    this.token(Hash, '#' + node.value);\n}\n\n", "import { Ident } from '../../tokenizer/index.js';\n\nexport const name = 'Identifier';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        name: this.consume(Ident)\n    };\n}\n\nexport function generate(node) {\n    this.token(Ident, node.name);\n}\n", "import { Hash, Delim } from '../../tokenizer/index.js';\n\nexport const name = 'IdSelector';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    // TODO: check value is an ident\n    this.eat(Hash);\n\n    return {\n        type: 'IdSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start + 1)\n    };\n}\n\nexport function generate(node) {\n    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector\n    // in safe mode (e.g. \"a#id\"), because IE11 doesn't allow a sequence <ident-token> <hash-token>\n    // without a whitespace in values (e.g. \"1px solid#000\")\n    this.token(Delim, '#' + node.name);\n}\n", "import { Ident, Delim } from '../../tokenizer/index.js';\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\nexport const name = 'Layer';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    let tokenStart = this.tokenStart;\n    let name = this.consume(Ident);\n\n    while (this.isDelim(FULLSTOP)) {\n        this.eat(Delim);\n        name += '.' + this.consume(Ident);\n    }\n\n    return {\n        type: 'Layer',\n        loc: this.getLocation(tokenStart, this.tokenStart),\n        name\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n", "import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'LayerList';\nexport const structure = {\n    children: [[\n        'Layer'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.Layer());\n\n        if (this.lookupTypeNonSC(0) !== Comma) {\n            break;\n        }\n\n        this.skipSC();\n        this.next();\n        this.skipSC();\n    }\n\n    return {\n        type: 'LayerList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n", "import {\n    Comma,\n    EOF,\n    Ident,\n    LeftCurlyBracket,\n    LeftParenthesis,\n    Function as FunctionToken,\n    Semicolon\n} from '../../tokenizer/index.js';\n\nexport const name = 'MediaQuery';\nexport const structure = {\n    modifier: [String, null],\n    mediaType: [String, null],\n    condition: ['Condition', null]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let modifier = null;\n    let mediaType = null;\n    let condition = null;\n\n    this.skipSC();\n\n    if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {\n        // [ not | only ]? <media-type>\n        const ident = this.consume(Ident);\n        const identLowerCase = ident.toLowerCase();\n\n        if (identLowerCase === 'not' || identLowerCase === 'only') {\n            this.skipSC();\n            modifier = identLowerCase;\n            mediaType = this.consume(Ident);\n        } else {\n            mediaType = ident;\n        }\n\n        switch (this.lookupTypeNonSC(0)) {\n            case Ident: {\n                // and <media-condition-without-or>\n                this.skipSC();\n                this.eatIdent('and');\n                condition = this.Condition('media');\n                break;\n            }\n\n            case LeftCurlyBracket:\n            case Semicolon:\n            case Comma:\n            case EOF:\n                break;\n\n            default:\n                this.error('Identifier or parenthesis is expected');\n        }\n    } else {\n        switch (this.tokenType) {\n            case Ident:\n            case LeftParenthesis:\n            case FunctionToken: {\n                // <media-condition>\n                condition = this.Condition('media');\n                break;\n            }\n\n            case LeftCurlyBracket:\n            case Semicolon:\n            case EOF:\n                break;\n\n            default:\n                this.error('Identifier or parenthesis is expected');\n        }\n    }\n\n    return {\n        type: 'MediaQuery',\n        loc: this.getLocation(start, this.tokenStart),\n        modifier,\n        mediaType,\n        condition\n    };\n}\n\nexport function generate(node) {\n    if (node.mediaType) {\n        if (node.modifier) {\n            this.token(Ident, node.modifier);\n        }\n\n        this.token(Ident, node.mediaType);\n\n        if (node.condition) {\n            this.token(Ident, 'and');\n            this.node(node.condition);\n        }\n    } else if (node.condition) {\n        this.node(node.condition);\n    }\n}\n\n", "import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'MediaQueryList';\nexport const structure = {\n    children: [[\n        'MediaQuery'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.MediaQuery());\n\n        if (this.tokenType !== Comma) {\n            break;\n        }\n\n        this.next();\n    }\n\n    return {\n        type: 'MediaQueryList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n", "import { Delim } from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nexport const name = 'NestingSelector';\nexport const structure = {\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eatDelim(AMPERSAND);\n\n    return {\n        type: 'NestingSelector',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(Delim, '&');\n}\n", "import { Ident } from '../../tokenizer/index.js';\n\nexport const name = 'Nth';\nexport const structure = {\n    nth: ['AnPlusB', 'Identifier'],\n    selector: ['SelectorList', null]\n};\n\nexport function parse() {\n    this.skipSC();\n\n    const start = this.tokenStart;\n    let end = start;\n    let selector = null;\n    let nth;\n\n    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {\n        nth = this.Identifier();\n    } else {\n        nth = this.AnPlusB();\n    }\n\n    end = this.tokenStart;\n    this.skipSC();\n\n    if (this.lookupValue(0, 'of')) {\n        this.next();\n\n        selector = this.SelectorList();\n        end = this.tokenStart;\n    }\n\n    return {\n        type: 'Nth',\n        loc: this.getLocation(start, end),\n        nth,\n        selector\n    };\n}\n\nexport function generate(node) {\n    this.node(node.nth);\n    if (node.selector !== null) {\n        this.token(Ident, 'of');\n        this.node(node.selector);\n    }\n}\n", "import { Number as NumberToken } from '../../tokenizer/index.js';\n\nexport const name = 'Number';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'Number',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consume(NumberToken)\n    };\n}\n\nexport function generate(node) {\n    this.token(NumberToken, node.value);\n}\n", "// '/' | '*' | ',' | ':' | '+' | '-'\nexport const name = 'Operator';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.next();\n\n    return {\n        type: 'Operator',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n", "import {\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Parentheses';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(LeftParenthesis);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Parentheses',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n", "import { Percentage } from '../../tokenizer/index.js';\n\nexport const name = 'Percentage';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'Percentage',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consumeNumber(Percentage)\n    };\n}\n\nexport function generate(node) {\n    this.token(Percentage, node.value + '%');\n}\n", "import {\n    Ident,\n    Function as FunctionToken,\n    Colon,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'PseudoClassSelector';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// : [ <ident> | <function-token> <any-value>? ) ]\nexport function parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(Colon);\n\n    if (this.tokenType === FunctionToken) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (this.lookupNonWSType(0) == RightParenthesis) {\n            children = this.createList();\n        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(null, false)\n            );\n        }\n\n        this.eat(RightParenthesis);\n    } else {\n        name = this.consume(Ident);\n    }\n\n    return {\n        type: 'PseudoClassSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Colon, ':');\n\n    if (node.children === null) {\n        this.token(Ident, node.name);\n    } else {\n        this.token(FunctionToken, node.name + '(');\n        this.children(node);\n        this.token(RightParenthesis, ')');\n    }\n}\n", "import {\n    Ident,\n    Function as FunctionToken,\n    Colon,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'PseudoElementSelector';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// :: [ <ident> | <function-token> <any-value>? ) ]\nexport function parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(Colon);\n    this.eat(Colon);\n\n    if (this.tokenType === FunctionToken) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (this.lookupNonWSType(0) == RightParenthesis) {\n            children = this.createList();\n        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(null, false)\n            );\n        }\n\n        this.eat(RightParenthesis);\n    } else {\n        name = this.consume(Ident);\n    }\n\n    return {\n        type: 'PseudoElementSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Colon, ':');\n    this.token(Colon, ':');\n\n    if (node.children === null) {\n        this.token(Ident, node.name);\n    } else {\n        this.token(FunctionToken, node.name + '(');\n        this.children(node);\n        this.token(RightParenthesis, ')');\n    }\n}\n", "import {\n    Delim,\n    Number as NumberToken,\n    Function as FunctionToken\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\n\n// Media Queries Level 3 defines terms of <ratio> as a positive (not zero or negative)\n// integers (see https://drafts.csswg.org/mediaqueries-3/#values)\n// However, Media Queries Level 4 removes any definition of values\n// (see https://drafts.csswg.org/mediaqueries-4/#values) and refers to\n// CSS Values and Units for detail. In CSS Values and Units Level 4 a <ratio>\n// definition was added (see https://drafts.csswg.org/css-values-4/#ratios) which\n// defines ratio as \"<number [0,\u221E]> [ / <number [0,\u221E]> ]?\" and based on it\n// any constrains on terms were removed. Parser also doesn't test numbers\n// in any way to make possible for linting and fixing them by the tools using CSSTree.\n// An additional syntax examination may be applied by a lexer.\nfunction consumeTerm() {\n    this.skipSC();\n\n    switch (this.tokenType) {\n        case NumberToken:\n            return this.Number();\n\n        case FunctionToken:\n            return this.Function(this.readSequence, this.scope.Value);\n\n        default:\n            this.error('Number of function is expected');\n    }\n}\n\nexport const name = 'Ratio';\nexport const structure = {\n    left: ['Number', 'Function'],\n    right: ['Number', 'Function', null]\n};\n\n// <number [0,\u221E]> [ / <number [0,\u221E]> ]?\nexport function parse() {\n    const start = this.tokenStart;\n    const left = consumeTerm.call(this);\n    let right = null;\n\n    this.skipSC();\n    if (this.isDelim(SOLIDUS)) {\n        this.eatDelim(SOLIDUS);\n        right = consumeTerm.call(this);\n    }\n\n    return {\n        type: 'Ratio',\n        loc: this.getLocation(start, this.tokenStart),\n        left,\n        right\n    };\n}\n\nexport function generate(node) {\n    this.node(node.left);\n    this.token(Delim, '/');\n    if (node.right) {\n        this.node(node.right);\n    } else {\n        this.node(NumberToken, 1);\n    }\n}\n", "import { WhiteSpace } from '../../tokenizer/index.js';\n\nfunction getOffsetExcludeWS() {\n    if (this.tokenIndex > 0) {\n        if (this.lookupType(-1) === WhiteSpace) {\n            return this.tokenIndex > 1\n                ? this.getTokenStart(this.tokenIndex - 1)\n                : this.firstCharOffset;\n        }\n    }\n\n    return this.tokenStart;\n}\n\nexport const name = 'Raw';\nexport const structure = {\n    value: String\n};\n\nexport function parse(consumeUntil, excludeWhiteSpace) {\n    const startOffset = this.getTokenStart(this.tokenIndex);\n    let endOffset;\n\n    this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);\n\n    if (excludeWhiteSpace && this.tokenStart > startOffset) {\n        endOffset = getOffsetExcludeWS.call(this);\n    } else {\n        endOffset = this.tokenStart;\n    }\n\n    return {\n        type: 'Raw',\n        loc: this.getLocation(startOffset, endOffset),\n        value: this.substring(startOffset, endOffset)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n", "import { LeftCurlyBracket } from '../../tokenizer/index.js';\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilLeftCurlyBracket, true);\n}\n\nfunction consumePrelude() {\n    const prelude = this.SelectorList();\n\n    if (prelude.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== LeftCurlyBracket) {\n        this.error();\n    }\n\n    return prelude;\n}\n\nexport const name = 'Rule';\nexport const walkContext = 'rule';\nexport const structure = {\n    prelude: ['SelectorList', 'Raw'],\n    block: ['Block']\n};\n\nexport function parse() {\n    const startToken = this.tokenIndex;\n    const startOffset = this.tokenStart;\n    let prelude;\n    let block;\n\n    if (this.parseRulePrelude) {\n        prelude = this.parseWithFallback(consumePrelude, consumeRaw);\n    } else {\n        prelude = consumeRaw.call(this, startToken);\n    }\n\n    block = this.Block(true);\n\n    return {\n        type: 'Rule',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        prelude,\n        block\n    };\n}\nexport function generate(node) {\n    this.node(node.prelude);\n    this.node(node.block);\n}\n\n", "import {\n    Ident,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Scope';\nexport const structure = {\n    root: ['SelectorList', 'Raw', null],\n    limit: ['SelectorList', 'Raw', null]\n};\n\nexport function parse() {\n    let root = null;\n    let limit = null;\n\n    this.skipSC();\n\n    const startOffset = this.tokenStart;\n    if (this.tokenType === LeftParenthesis) {\n        this.next();\n        this.skipSC();\n        root = this.parseWithFallback(\n            this.SelectorList,\n            () => this.Raw(false, true)\n        );\n        this.skipSC();\n        this.eat(RightParenthesis);\n    }\n\n    if (this.lookupNonWSType(0) === Ident) {\n        this.skipSC();\n        this.eatIdent('to');\n        this.skipSC();\n        this.eat(LeftParenthesis);\n        this.skipSC();\n        limit = this.parseWithFallback(\n            this.SelectorList,\n            () => this.Raw(false, true)\n        );\n        this.skipSC();\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Scope',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        root,\n        limit\n    };\n}\n\nexport function generate(node) {\n    if (node.root) {\n        this.token(LeftParenthesis, '(');\n        this.node(node.root);\n        this.token(RightParenthesis, ')');\n    }\n\n    if (node.limit) {\n        this.token(Ident, 'to');\n        this.token(LeftParenthesis, '(');\n        this.node(node.limit);\n        this.token(RightParenthesis, ')');\n    }\n}\n", "export const name = 'Selector';\nexport const structure = {\n    children: [[\n        'TypeSelector',\n        'IdSelector',\n        'ClassSelector',\n        'AttributeSelector',\n        'PseudoClassSelector',\n        'PseudoElementSelector',\n        'Combinator'\n    ]]\n};\n\nexport function parse() {\n    const children = this.readSequence(this.scope.Selector);\n\n    // nothing were consumed\n    if (this.getFirstListNode(children) === null) {\n        this.error('Selector is expected');\n    }\n\n    return {\n        type: 'Selector',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'SelectorList';\nexport const walkContext = 'selector';\nexport const structure = {\n    children: [[\n        'Selector',\n        'Raw'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    while (!this.eof) {\n        children.push(this.Selector());\n\n        if (this.tokenType === Comma) {\n            this.next();\n            continue;\n        }\n\n        break;\n    }\n\n    return {\n        type: 'SelectorList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n", "import { String as StringToken } from '../../tokenizer/index.js';\nimport { decode, encode } from '../../utils/string.js';\n\nexport const name = 'String';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'String',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: decode(this.consume(StringToken))\n    };\n}\n\nexport function generate(node) {\n    this.token(StringToken, encode(node.value));\n}\n", "import {\n    isHexDigit,\n    isWhiteSpace,\n    isValidEscape,\n    consumeEscaped,\n    decodeEscaped\n} from '../tokenizer/index.js';\n\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;  // \"\nconst APOSTROPHE = 0x0027;      // '\n\nexport function decode(str) {\n    const len = str.length;\n    const firstChar = str.charCodeAt(0);\n    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;\n    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;\n    let decoded = '';\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last quote as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-a-string\n// \u00A7 2.1. Common Serializing Idioms\nexport function encode(str, apostrophe) {\n    const quote = apostrophe ? '\\'' : '\"';\n    const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        // If the character is '\"' (U+0022) or \"\\\" (U+005C), the escaped character.\n        if (code === quoteCode || code === REVERSE_SOLIDUS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && (isHexDigit(code) || isWhiteSpace(code))) {\n                encoded += ' ';\n            }\n\n            // Otherwise, the character itself.\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return quote + encoded + quote;\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    AtKeyword,\n    CDO,\n    CDC\n} from '../../tokenizer/index.js';\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction consumeRaw() {\n    return this.Raw(null, false);\n}\n\nexport const name = 'StyleSheet';\nexport const walkContext = 'stylesheet';\nexport const structure = {\n    children: [[\n        'Comment',\n        'CDO',\n        'CDC',\n        'Atrule',\n        'Rule',\n        'Raw'\n    ]]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const children = this.createList();\n    let child;\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case WhiteSpace:\n                this.next();\n                continue;\n\n            case Comment:\n                // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n                if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {\n                    this.next();\n                    continue;\n                }\n\n                child = this.Comment();\n                break;\n\n            case CDO: // <!--\n                child = this.CDO();\n                break;\n\n            case CDC: // -->\n                child = this.CDC();\n                break;\n\n            // CSS Syntax Module Level 3\n            // \u00A72.2 Error handling\n            // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n            case AtKeyword:\n                child = this.parseWithFallback(this.Atrule, consumeRaw);\n                break;\n\n            // Anything else starts a qualified rule ...\n            default:\n                child = this.parseWithFallback(this.Rule, consumeRaw);\n        }\n\n        children.push(child);\n    }\n\n    return {\n        type: 'StyleSheet',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import {\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'SupportsDeclaration';\nexport const structure = {\n    declaration: 'Declaration'\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(LeftParenthesis);\n    this.skipSC();\n\n    const declaration = this.Declaration();\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'SupportsDeclaration',\n        loc: this.getLocation(start, this.tokenStart),\n        declaration\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.node(node.declaration);\n    this.token(RightParenthesis, ')');\n}\n", "import { Ident } from '../../tokenizer/index.js';\n\nconst ASTERISK = 0x002A;     // U+002A ASTERISK (*)\nconst VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)\n\nfunction eatIdentifierOrAsterisk() {\n    if (this.tokenType !== Ident &&\n        this.isDelim(ASTERISK) === false) {\n        this.error('Identifier or asterisk is expected');\n    }\n\n    this.next();\n}\n\nexport const name = 'TypeSelector';\nexport const structure = {\n    name: String\n};\n\n// ident\n// ident|ident\n// ident|*\n// *\n// *|ident\n// *|*\n// |ident\n// |*\nexport function parse() {\n    const start = this.tokenStart;\n\n    if (this.isDelim(VERTICALLINE)) {\n        this.next();\n        eatIdentifierOrAsterisk.call(this);\n    } else {\n        eatIdentifierOrAsterisk.call(this);\n\n        if (this.isDelim(VERTICALLINE)) {\n            this.next();\n            eatIdentifierOrAsterisk.call(this);\n        }\n    }\n\n    return {\n        type: 'TypeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n", "import {\n    isHexDigit,\n    Ident,\n    Number,\n    Dimension\n} from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\n\nfunction eatHexSequence(offset, allowDash) {\n    let len = 0;\n\n    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {\n        const code = this.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && len !== 0) {\n            eatHexSequence.call(this, offset + len + 1, false);\n            return -1;\n        }\n\n        if (!isHexDigit(code)) {\n            this.error(\n                allowDash && len !== 0\n                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'\n                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),\n                pos\n            );\n        }\n\n        if (++len > 6) {\n            this.error('Too many hex digits', pos);\n        };\n    }\n\n    this.next();\n    return len;\n}\n\nfunction eatQuestionMarkSequence(max) {\n    let count = 0;\n\n    while (this.isDelim(QUESTIONMARK)) {\n        if (++count > max) {\n            this.error('Too many question marks');\n        }\n\n        this.next();\n    }\n}\n\nfunction startsWith(code) {\n    if (this.charCodeAt(this.tokenStart) !== code) {\n        this.error((code === PLUSSIGN ? 'Plus sign' : 'Hyphen minus') + ' is expected');\n    }\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction scanUnicodeRange() {\n    let hexLength = 0;\n\n    switch (this.tokenType) {\n        case Number:\n            // u <number-token> '?'*\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (this.isDelim(QUESTIONMARK)) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n                break;\n            }\n\n            if (this.tokenType === Dimension ||\n                this.tokenType === Number) {\n                startsWith.call(this, HYPHENMINUS);\n                eatHexSequence.call(this, 1, false);\n                break;\n            }\n\n            break;\n\n        case Dimension:\n            // u <dimension-token> '?'*\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (hexLength > 0) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n            }\n\n            break;\n\n        default:\n            // u '+' <ident-token> '?'*\n            // u '+' '?'+\n            this.eatDelim(PLUSSIGN);\n\n            if (this.tokenType === Ident) {\n                hexLength = eatHexSequence.call(this, 0, true);\n                if (hexLength > 0) {\n                    eatQuestionMarkSequence.call(this, 6 - hexLength);\n                }\n                break;\n            }\n\n            if (this.isDelim(QUESTIONMARK)) {\n                this.next();\n                eatQuestionMarkSequence.call(this, 5);\n                break;\n            }\n\n            this.error('Hex digit or question mark is expected');\n    }\n}\n\nexport const name = 'UnicodeRange';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    // U or u\n    this.eatIdent('u');\n    scanUnicodeRange.call(this);\n\n    return {\n        type: 'UnicodeRange',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n", "import * as url from '../../utils/url.js';\nimport * as string from '../../utils/string.js';\nimport {\n    Function as FunctionToken,\n    String as StringToken,\n    Url,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Url';\nexport const structure = {\n    value: String\n};\n\n// <url-token> | <function-token> <string> )\nexport function parse() {\n    const start = this.tokenStart;\n    let value;\n\n    switch (this.tokenType) {\n        case Url:\n            value = url.decode(this.consume(Url));\n            break;\n\n        case FunctionToken:\n            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {\n                this.error('Function name must be `url`');\n            }\n\n            this.eat(FunctionToken);\n            this.skipSC();\n            value = string.decode(this.consume(StringToken));\n            this.skipSC();\n            if (!this.eof) {\n                this.eat(RightParenthesis);\n            }\n            break;\n\n        default:\n            this.error('Url or Function is expected');\n    }\n\n    return {\n        type: 'Url',\n        loc: this.getLocation(start, this.tokenStart),\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(Url, url.encode(node.value));\n}\n", "import {\n    isHexDigit,\n    isWhiteSpace,\n    isValidEscape,\n    consumeEscaped,\n    decodeEscaped\n} from '../tokenizer/index.js';\n\nconst SPACE = 0x0020;            // U+0020 SPACE\nconst REVERSE_SOLIDUS = 0x005c;  // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;   // \"\nconst APOSTROPHE = 0x0027;       // '\nconst LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()\nconst RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())\n\nexport function decode(str) {\n    const len = str.length;\n    let start = 4; // length of \"url(\"\n    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;\n    let decoded = '';\n\n    while (start < end && isWhiteSpace(str.charCodeAt(start))) {\n        start++;\n    }\n\n    while (start < end && isWhiteSpace(str.charCodeAt(end))) {\n        end--;\n    }\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last left parenthesis as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\nexport function encode(str) {\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        if (code === SPACE ||\n            code === REVERSE_SOLIDUS ||\n            code === QUOTATION_MARK ||\n            code === APOSTROPHE ||\n            code === LEFTPARENTHESIS ||\n            code === RIGHTPARENTHESIS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && isHexDigit(code)) {\n                encoded += ' ';\n            }\n\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return 'url(' + encoded + ')';\n}\n", "export const name = 'Value';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const children = this.readSequence(this.scope.Value);\n\n    return {\n        type: 'Value',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import { WhiteSpace } from '../../tokenizer/index.js';\n\nconst SPACE = Object.freeze({\n    type: 'WhiteSpace',\n    loc: null,\n    value: ' '\n});\n\nexport const name = 'WhiteSpace';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    this.eat(WhiteSpace);\n    return SPACE;\n\n    // return {\n    //     type: 'WhiteSpace',\n    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    //     value: this.consume(WHITESPACE)\n    // };\n}\n\nexport function generate(node) {\n    this.token(WhiteSpace, node.value);\n}\n", "import { cssWideKeywords } from '../../lexer/generic-const.js';\nimport definitions from '../../data.js';\nimport * as node from '../node/index.js';\n\nexport default {\n    generic: true,\n    cssWideKeywords,\n    ...definitions,\n    node\n};\n", "export { default as AtrulePrelude } from './atrulePrelude.js';\nexport { default as Selector } from './selector.js';\nexport { default as Value } from './value.js';\n", "import {\n    Ident,\n    String as StringToken,\n    Number as NumberToken,\n    Function as FunctionToken,\n    Url,\n    Hash,\n    Dimension,\n    Percentage,\n    LeftParenthesis,\n    LeftSquareBracket,\n    Comma,\n    Delim\n} from '../../tokenizer/index.js';\n\nconst NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)\nconst ASTERISK = 0x002A;    // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)\nconst U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)\n\nexport default function defaultRecognizer(context) {\n    switch (this.tokenType) {\n        case Hash:\n            return this.Hash();\n\n        case Comma:\n            return this.Operator();\n\n        case LeftParenthesis:\n            return this.Parentheses(this.readSequence, context.recognizer);\n\n        case LeftSquareBracket:\n            return this.Brackets(this.readSequence, context.recognizer);\n\n        case StringToken:\n            return this.String();\n\n        case Dimension:\n            return this.Dimension();\n\n        case Percentage:\n            return this.Percentage();\n\n        case NumberToken:\n            return this.Number();\n\n        case FunctionToken:\n            return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')\n                ? this.Url()\n                : this.Function(this.readSequence, context.recognizer);\n\n        case Url:\n            return this.Url();\n\n        case Ident:\n            // check for unicode range, it should start with u+ or U+\n            if (this.cmpChar(this.tokenStart, U) &&\n                this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {\n                return this.UnicodeRange();\n            } else {\n                return this.Identifier();\n            }\n\n        case Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            if (code === SOLIDUS ||\n                code === ASTERISK ||\n                code === PLUSSIGN ||\n                code === HYPHENMINUS) {\n                return this.Operator(); // TODO: replace with Delim\n            }\n\n            // TODO: produce a node with Delim node type\n\n            if (code === NUMBERSIGN) {\n                this.error('Hex or identifier is expected', this.tokenStart + 1);\n            }\n\n            break;\n        }\n    }\n};\n", "import getNode from './default.js';\n\nexport default {\n    getNode\n};\n", "import {\n    Delim,\n    Ident,\n    Dimension,\n    Percentage,\n    Number as NumberToken,\n    Hash,\n    Colon,\n    LeftSquareBracket\n} from '../../tokenizer/index.js';\n\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst FULLSTOP = 0x002E;        // U+002E FULL STOP (.)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nfunction onWhiteSpace(next, children) {\n    if (children.last !== null && children.last.type !== 'Combinator' &&\n        next !== null && next.type !== 'Combinator') {\n        children.push({  // FIXME: this.Combinator() should be used instead\n            type: 'Combinator',\n            loc: null,\n            name: ' '\n        });\n    }\n}\n\nfunction getNode() {\n    switch (this.tokenType) {\n        case LeftSquareBracket:\n            return this.AttributeSelector();\n\n        case Hash:\n            return this.IdSelector();\n\n        case Colon:\n            if (this.lookupType(1) === Colon) {\n                return this.PseudoElementSelector();\n            } else {\n                return this.PseudoClassSelector();\n            }\n\n        case Ident:\n            return this.TypeSelector();\n\n        case NumberToken:\n        case Percentage:\n            return this.Percentage();\n\n        case Dimension:\n            // throws when .123ident\n            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {\n                this.error('Identifier is expected', this.tokenStart + 1);\n            }\n            break;\n\n        case Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            switch (code) {\n                case PLUSSIGN:\n                case GREATERTHANSIGN:\n                case TILDE:\n                case SOLIDUS:  // /deep/\n                    return this.Combinator();\n\n                case FULLSTOP:\n                    return this.ClassSelector();\n\n                case ASTERISK:\n                case VERTICALLINE:\n                    return this.TypeSelector();\n\n                case NUMBERSIGN:\n                    return this.IdSelector();\n\n                case AMPERSAND:\n                    return this.NestingSelector();\n            }\n\n            break;\n        }\n    }\n};\n\nexport default {\n    onWhiteSpace,\n    getNode\n};\n", "// legacy IE function\n// expression( <any-value> )\nexport default function() {\n    return this.createSingleNodeList(\n        this.Raw(null, false)\n    );\n}\n", "import { Comma, WhiteSpace } from '../../tokenizer/index.js';\n\n// var( <ident> , <value>? )\nexport default function() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer\n    children.push(this.Identifier());\n\n    this.skipSC();\n\n    if (this.tokenType === Comma) {\n        children.push(this.Operator());\n\n        const startIndex = this.tokenIndex;\n        const value = this.parseCustomProperty\n            ? this.Value(null)\n            : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);\n\n        if (value.type === 'Value' && value.children.isEmpty) {\n            for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {\n                if (this.lookupType(offset) === WhiteSpace) {\n                    value.children.appendData({\n                        type: 'WhiteSpace',\n                        loc: null,\n                        value: ' '\n                    });\n                    break;\n                }\n            }\n        }\n\n        children.push(value);\n    }\n\n    return children;\n};\n", "import getNode from './default.js';\nimport expressionFn from '../function/expression.js';\nimport varFn from '../function/var.js';\n\nfunction isPlusMinusOperator(node) {\n    return (\n        node !== null &&\n        node.type === 'Operator' &&\n        (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+')\n    );\n}\n\nexport default {\n    getNode,\n    onWhiteSpace(next, children) {\n        if (isPlusMinusOperator(next)) {\n            next.value = ' ' + next.value;\n        }\n        if (isPlusMinusOperator(children.last)) {\n            children.last.value += ' ';\n        }\n    },\n    'expression': expressionFn,\n    'var': varFn\n};\n", "import { Ident } from '../../tokenizer/index.js';\n\n// https://drafts.csswg.org/css-contain-3/#container-rule\n// The keywords `none`, `and`, `not`, and `or` are excluded from the <custom-ident> above.\nconst nonContainerNameKeywords = new Set(['none', 'and', 'not', 'or']);\n\nexport default {\n    parse: {\n        prelude() {\n            const children = this.createList();\n\n            if (this.tokenType === Ident) {\n                const name = this.substring(this.tokenStart, this.tokenEnd);\n\n                if (!nonContainerNameKeywords.has(name.toLowerCase())) {\n                    children.push(this.Identifier());\n                }\n            }\n\n            children.push(this.Condition('container'));\n\n            return children;\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude: null,\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n", "import {\n    String as StringToken,\n    Ident,\n    Url,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nfunction parseWithFallback(parse, fallback) {\n    return this.parseWithFallback(\n        () => {\n            try {\n                return parse.call(this);\n            } finally {\n                this.skipSC();\n                if (this.lookupNonWSType(0) !== RightParenthesis) {\n                    this.error();\n                }\n            }\n        },\n        fallback || (() => this.Raw(null, true))\n    );\n}\n\nconst parseFunctions = {\n    layer() {\n        this.skipSC();\n\n        const children = this.createList();\n        const node = parseWithFallback.call(this, this.Layer);\n\n        if (node.type !== 'Raw' || node.value !== '') {\n            children.push(node);\n        }\n\n        return children;\n    },\n    supports() {\n        this.skipSC();\n\n        const children = this.createList();\n        const node = parseWithFallback.call(\n            this,\n            this.Declaration,\n            () => parseWithFallback.call(this, () => this.Condition('supports'))\n        );\n\n        if (node.type !== 'Raw' || node.value !== '') {\n            children.push(node);\n        }\n\n        return children;\n    }\n};\n\nexport default {\n    parse: {\n        prelude() {\n            const children = this.createList();\n\n            switch (this.tokenType) {\n                case StringToken:\n                    children.push(this.String());\n                    break;\n\n                case Url:\n                case FunctionToken:\n                    children.push(this.Url());\n                    break;\n\n                default:\n                    this.error('String or url() is expected');\n            }\n\n            this.skipSC();\n\n            if (this.tokenType === Ident &&\n                this.cmpStr(this.tokenStart, this.tokenEnd, 'layer')) {\n                children.push(this.Identifier());\n            } else if (\n                this.tokenType === FunctionToken &&\n                this.cmpStr(this.tokenStart, this.tokenEnd, 'layer(')\n            ) {\n                children.push(this.Function(null, parseFunctions));\n            }\n\n            this.skipSC();\n\n            if (this.tokenType === FunctionToken &&\n                this.cmpStr(this.tokenStart, this.tokenEnd, 'supports(')) {\n                children.push(this.Function(null, parseFunctions));\n            }\n\n            if (this.lookupNonWSType(0) === Ident ||\n                this.lookupNonWSType(0) === LeftParenthesis) {\n                children.push(this.MediaQueryList());\n            }\n\n            return children;\n        },\n        block: null\n    }\n};\n", "export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.LayerList()\n            );\n        },\n        block() {\n            return this.Block(false);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.MediaQueryList()\n            );\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.Scope()\n            );\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude: null,\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n", "export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.Condition('supports')\n            );\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n", "import container from './container.js';\nimport fontFace from './font-face.js';\nimport importAtrule from './import.js';\nimport layer from './layer.js';\nimport media from './media.js';\nimport nest from './nest.js';\nimport page from './page.js';\nimport scope from './scope.js';\nimport startingStyle from './starting-style.js';\nimport supports from './supports.js';\n\nexport default {\n    container,\n    'font-face': fontFace,\n    import: importAtrule,\n    layer,\n    media,\n    nest,\n    page,\n    scope,\n    'starting-style': startingStyle,\n    supports\n};\n", "import { Comma, String as StringToken, Ident, RightParenthesis } from '../../tokenizer/index.js';\n\nexport function parseLanguageRangeList() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    loop: while (!this.eof) {\n        switch (this.tokenType) {\n            case Ident:\n                children.push(this.Identifier());\n                break;\n\n            case StringToken:\n                children.push(this.String());\n                break;\n\n            case Comma:\n                children.push(this.Operator());\n                break;\n\n            case RightParenthesis:\n                break loop;\n\n            default:\n                this.error('Identifier, string or comma is expected');\n        }\n\n        this.skipSC();\n    }\n\n    return children;\n}\n", "import { parseLanguageRangeList } from './lang.js';\n\nconst selectorList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.SelectorList()\n        );\n    }\n};\n\nconst selector = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Selector()\n        );\n    }\n};\n\nconst identList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Identifier()\n        );\n    }\n};\n\nconst langList = {\n    parse: parseLanguageRangeList\n};\n\nconst nth = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Nth()\n        );\n    }\n};\n\nexport default {\n    'dir': identList,\n    'has': selectorList,\n    'lang': langList,\n    'matches': selectorList,\n    'is': selectorList,\n    '-moz-any': selectorList,\n    '-webkit-any': selectorList,\n    'where': selectorList,\n    'not': selectorList,\n    'nth-child': nth,\n    'nth-last-child': nth,\n    'nth-last-of-type': nth,\n    'nth-of-type': nth,\n    'slotted': selector,\n    'host': selector,\n    'host-context': selector\n};\n", "export { parse as AnPlusB } from './AnPlusB.js';\nexport { parse as Atrule } from './Atrule.js';\nexport { parse as AtrulePrelude } from './AtrulePrelude.js';\nexport { parse as AttributeSelector } from './AttributeSelector.js';\nexport { parse as Block } from './Block.js';\nexport { parse as Brackets } from './Brackets.js';\nexport { parse as CDC } from './CDC.js';\nexport { parse as CDO } from './CDO.js';\nexport { parse as ClassSelector } from './ClassSelector.js';\nexport { parse as Combinator } from './Combinator.js';\nexport { parse as Comment } from './Comment.js';\nexport { parse as Condition } from './Condition.js';\nexport { parse as Declaration } from './Declaration.js';\nexport { parse as DeclarationList } from './DeclarationList.js';\nexport { parse as Dimension } from './Dimension.js';\nexport { parse as Feature } from './Feature.js';\nexport { parse as FeatureFunction } from './FeatureFunction.js';\nexport { parse as FeatureRange } from './FeatureRange.js';\nexport { parse as Function } from './Function.js';\nexport { parse as GeneralEnclosed } from './GeneralEnclosed.js';\nexport { parse as Hash } from './Hash.js';\nexport { parse as Identifier } from './Identifier.js';\nexport { parse as IdSelector } from './IdSelector.js';\nexport { parse as Layer } from './Layer.js';\nexport { parse as LayerList } from './LayerList.js';\nexport { parse as MediaQuery } from './MediaQuery.js';\nexport { parse as MediaQueryList } from './MediaQueryList.js';\nexport { parse as NestingSelector } from './NestingSelector.js';\nexport { parse as Nth } from './Nth.js';\nexport { parse as Number } from './Number.js';\nexport { parse as Operator } from './Operator.js';\nexport { parse as Parentheses } from './Parentheses.js';\nexport { parse as Percentage } from './Percentage.js';\nexport { parse as PseudoClassSelector } from './PseudoClassSelector.js';\nexport { parse as PseudoElementSelector } from './PseudoElementSelector.js';\nexport { parse as Ratio } from './Ratio.js';\nexport { parse as Raw } from './Raw.js';\nexport { parse as Rule } from './Rule.js';\nexport { parse as Scope } from './Scope.js';\nexport { parse as Selector } from './Selector.js';\nexport { parse as SelectorList } from './SelectorList.js';\nexport { parse as String } from './String.js';\nexport { parse as StyleSheet } from './StyleSheet.js';\nexport { parse as SupportsDeclaration } from './SupportsDeclaration.js';\nexport { parse as TypeSelector } from './TypeSelector.js';\nexport { parse as UnicodeRange } from './UnicodeRange.js';\nexport { parse as Url } from './Url.js';\nexport { parse as Value } from './Value.js';\nexport { parse as WhiteSpace } from './WhiteSpace.js';\n", "import * as scope from '../scope/index.js';\nimport atrule from '../atrule/index.js';\nimport pseudo from '../pseudo/index.js';\nimport * as node from '../node/index-parse.js';\n\nexport default {\n    parseContext: {\n        default: 'StyleSheet',\n        stylesheet: 'StyleSheet',\n        atrule: 'Atrule',\n        atrulePrelude(options) {\n            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);\n        },\n        mediaQueryList: 'MediaQueryList',\n        mediaQuery: 'MediaQuery',\n        condition(options) {\n            return this.Condition(options.kind);\n        },\n        rule: 'Rule',\n        selectorList: 'SelectorList',\n        selector: 'Selector',\n        block() {\n            return this.Block(true);\n        },\n        declarationList: 'DeclarationList',\n        declaration: 'Declaration',\n        value: 'Value'\n    },\n    features: {\n        supports: {\n            selector() {\n                return this.Selector();\n            }\n        },\n        container: {\n            style() {\n                return this.Declaration();\n            }\n        }\n    },\n    scope,\n    atrule,\n    pseudo,\n    node\n};\n", "import * as node from '../node/index.js';\n\nexport default {\n    node\n};\n", "import createSyntax from './create.js';\nimport lexerConfig from './config/lexer.js';\nimport parserConfig from './config/parser.js';\nimport walkerConfig from './config/walker.js';\n\nexport default createSyntax({\n    ...lexerConfig,\n    ...parserConfig,\n    ...walkerConfig\n});\n", "import { createRequire } from 'module';\n\nconst require = createRequire(import.meta.url);\n\nexport const { version } = require('../package.json');\n", "import syntax from './syntax/index.js';\n\nexport * from './version.js';\nexport { default as createSyntax } from './syntax/create.js';\nexport { List } from './utils/List.js';\nexport { Lexer } from './lexer/Lexer.js';\nexport { tokenTypes, tokenNames, TokenStream, OffsetToLocation } from './tokenizer/index.js';\nexport * as definitionSyntax from './definition-syntax/index.js';\nexport { clone } from './utils/clone.js';\nexport * from './utils/names.js';\nexport * as ident from './utils/ident.js';\nexport * as string from './utils/string.js';\nexport * as url from './utils/url.js';\nexport const {\n    tokenize,\n    parse,\n    generate,\n    lexer,\n    createLexer,\n\n    walk,\n    find,\n    findLast,\n    findAll,\n\n    toPlainObject,\n    fromPlainObject,\n\n    fork\n} = syntax;\n", "/**\n * utility.js\n */\n\n/* import */\nimport nwsapi from '@asamuzakjp/nwsapi';\nimport bidiFactory from 'bidi-js';\nimport isCustomElementName from 'is-potential-custom-element-name';\n\n/* constants */\nimport {\n  DOCUMENT_FRAGMENT_NODE, DOCUMENT_NODE, DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_PRECEDING, ELEMENT_NODE, HAS_COMPOUND, KEY_INPUT_BUTTON,\n  KEY_INPUT_EDIT, KEY_INPUT_TEXT, LOGIC_COMPLEX, LOGIC_COMPOUND, N_TH,\n  PSEUDO_CLASS, TARGET_LINEAL, TARGET_SELF, TEXT_NODE, TYPE_FROM, TYPE_TO\n} from './constant.js';\nconst REG_LOGIC_COMPLEX =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPLEX})`);\nconst REG_LOGIC_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPOUND})`);\nconst REG_LOGIC_HAS_COMPOUND =\n  new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH}|${LOGIC_COMPOUND}|${HAS_COMPOUND})`);\nconst REG_WO_LOGICAL = new RegExp(`:(?!${PSEUDO_CLASS}|${N_TH})`);\n\n/**\n * get type\n * @param {*} o - object to check\n * @returns {string} - type of object\n */\nexport const getType = o =>\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\n\n/**\n * resolve content document, root node and tree walker, is in shadow\n * @param {object} node - Document, DocumentFragment, Element node\n * @returns {Array.<object|boolean>}\n *   - array of document, root node , tree walker, node is in shadow\n */\nexport const resolveContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  let document;\n  let root;\n  let shadow;\n  switch (node.nodeType) {\n    case DOCUMENT_NODE: {\n      document = node;\n      root = node;\n      break;\n    }\n    case DOCUMENT_FRAGMENT_NODE: {\n      const { host, mode, ownerDocument } = node;\n      document = ownerDocument;\n      root = node;\n      shadow = host && (mode === 'close' || mode === 'open');\n      break;\n    }\n    case ELEMENT_NODE: {\n      document = node.ownerDocument;\n      let refNode = node;\n      while (refNode) {\n        const { host, mode, nodeType, parentNode } = refNode;\n        if (nodeType === DOCUMENT_FRAGMENT_NODE) {\n          shadow = host && (mode === 'close' || mode === 'open');\n          break;\n        } else if (parentNode) {\n          refNode = parentNode;\n        } else {\n          break;\n        }\n      }\n      root = refNode;\n      break;\n    }\n    default : {\n      throw new TypeError(`Unexpected node ${node.nodeName}`);\n    }\n  }\n  return [\n    document,\n    root,\n    !!shadow\n  ];\n};\n\n/**\n * traverse node tree\n * @param {object} node - node\n * @param {object} walker - tree walker\n * @param {boolean} force - traverse only to next node\n * @returns {?object} - current node\n */\nexport const traverseNode = (node, walker, force = false) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!walker) {\n    return null;\n  }\n  let refNode = walker.currentNode;\n  if (refNode === node) {\n    return refNode;\n  } else if (force || refNode.contains(node)) {\n    refNode = walker.nextNode();\n    while (refNode) {\n      if (refNode === node) {\n        break;\n      }\n      refNode = walker.nextNode();\n    }\n    return refNode;\n  } else {\n    if (refNode !== walker.root) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        } else if (refNode === walker.root || refNode.contains(node)) {\n          break;\n        }\n        refNode = walker.parentNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n    if (node.nodeType === ELEMENT_NODE) {\n      let bool;\n      while (refNode) {\n        if (refNode === node) {\n          bool = true;\n          break;\n        }\n        refNode = walker.nextNode();\n      }\n      if (bool) {\n        return refNode;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * is custom element\n * @param {object} node - Element node\n * @param {object} opt - options\n * @returns {boolean} - result;\n */\nexport const isCustomElement = (node, opt = {}) => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, ownerDocument } = node;\n  const { formAssociated } = opt;\n  const window = ownerDocument.defaultView;\n  let elmConstructor;\n  const attr = node.getAttribute('is');\n  if (attr) {\n    elmConstructor =\n      isCustomElementName(attr) && window.customElements.get(attr);\n  } else {\n    elmConstructor =\n      isCustomElementName(localName) && window.customElements.get(localName);\n  }\n  if (elmConstructor) {\n    if (formAssociated) {\n      return !!elmConstructor.formAssociated;\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * get slotted text content\n * @param {object} node - Element node\n * @returns {?string} - text content\n */\nexport const getSlottedTextContent = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (typeof node.assignedNodes !== 'function') {\n    return null;\n  }\n  const nodes = node.assignedNodes();\n  if (nodes.length) {\n    let text;\n    for (const item of nodes) {\n      text = item.textContent.trim();\n      if (text) {\n        break;\n      }\n    }\n    return text;\n  }\n  return node.textContent.trim();\n};\n\n/**\n * get directionality of node\n * @see https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute\n * @param {object} node - Element node\n * @returns {?string} - 'ltr' / 'rtl'\n */\nexport const getDirectionality = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { dir: dirAttr, localName, parentNode } = node;\n  const { getEmbeddingLevels } = bidiFactory();\n  if (dirAttr === 'ltr' || dirAttr === 'rtl') {\n    return dirAttr;\n  } else if (dirAttr === 'auto') {\n    let text;\n    switch (localName) {\n      case 'input': {\n        const valueKeys = [...KEY_INPUT_BUTTON, ...KEY_INPUT_TEXT, 'hidden'];\n        if (!node.type || valueKeys.includes(node.type)) {\n          text = node.value;\n        } else {\n          const ltrKeys = [\n            'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio',\n            'time'\n          ];\n          if (ltrKeys.includes(node.type)) {\n            return 'ltr';\n          }\n        }\n        break;\n      }\n      case 'slot': {\n        text = getSlottedTextContent(node);\n        break;\n      }\n      case 'textarea': {\n        text = node.value;\n        break;\n      }\n      default: {\n        const items = [].slice.call(node.childNodes);\n        for (const item of items) {\n          const {\n            dir: itemDir, localName: itemLocalName, nodeType: itemNodeType,\n            textContent: itemTextContent\n          } = item;\n          if (itemNodeType === TEXT_NODE) {\n            text = itemTextContent.trim();\n          } else if (itemNodeType === ELEMENT_NODE) {\n            const keys = ['bdi', 'script', 'style', 'textarea'];\n            if (!keys.includes(itemLocalName) &&\n                (!itemDir || (itemDir !== 'ltr' && itemDir !== 'rtl'))) {\n              if (itemLocalName === 'slot') {\n                text = getSlottedTextContent(item);\n              } else {\n                text = itemTextContent.trim();\n              }\n            }\n          }\n          if (text) {\n            break;\n          }\n        }\n      }\n    }\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    } else if (parentNode) {\n      const { nodeType: parentNodeType } = parentNode;\n      if (parentNodeType === ELEMENT_NODE) {\n        return getDirectionality(parentNode);\n      }\n    }\n  } else if (localName === 'input' && node.type === 'tel') {\n    return 'ltr';\n  } else if (localName === 'bdi') {\n    const text = node.textContent.trim();\n    if (text) {\n      const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n      if (level % 2 === 1) {\n        return 'rtl';\n      }\n    }\n  } else if (parentNode) {\n    if (localName === 'slot') {\n      const text = getSlottedTextContent(node);\n      if (text) {\n        const { paragraphs: [{ level }] } = getEmbeddingLevels(text);\n        if (level % 2 === 1) {\n          return 'rtl';\n        }\n        return 'ltr';\n      }\n    }\n    const { nodeType: parentNodeType } = parentNode;\n    if (parentNodeType === ELEMENT_NODE) {\n      return getDirectionality(parentNode);\n    }\n  }\n  return 'ltr';\n};\n\n/**\n * is content editable\n * NOTE: not implemented in jsdom https://github.com/jsdom/jsdom/issues/1670\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isContentEditable = node => {\n  if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (node.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (typeof node.isContentEditable === 'boolean') {\n    return node.isContentEditable;\n  } else if (node.ownerDocument.designMode === 'on') {\n    return true;\n  } else {\n    let attr;\n    if (node.hasAttribute('contenteditable')) {\n      attr = node.getAttribute('contenteditable');\n    } else {\n      attr = 'inherit';\n    }\n    switch (attr) {\n      case '':\n      case 'true': {\n        return true;\n      }\n      case 'plaintext-only': {\n        // FIXME:\n        // @see https://github.com/w3c/editing/issues/470\n        // @see https://github.com/whatwg/html/issues/10651\n        return true;\n      }\n      case 'false': {\n        return false;\n      }\n      default: {\n        if (node?.parentNode?.nodeType === ELEMENT_NODE) {\n          return isContentEditable(node.parentNode);\n        }\n        return false;\n      }\n    }\n  }\n};\n\n/**\n * is node visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  const { display, visibility } = window.getComputedStyle(node);\n  if (display !== 'none' && visibility === 'visible') {\n    return true;\n  }\n  return false;\n};\n\n/**\n * is focus visible\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusVisible = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const { localName, type } = node;\n  switch (localName) {\n    case 'input': {\n      if (!type || KEY_INPUT_EDIT.includes(type)) {\n        return true;\n      }\n      return false;\n    }\n    case 'textarea': {\n      return true;\n    }\n    default: {\n      return isContentEditable(node);\n    }\n  }\n};\n\n/**\n * is focusable area\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusableArea = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (!node.isConnected) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  if (node instanceof window.HTMLElement) {\n    if (Number.isInteger(parseInt(node.getAttribute('tabindex')))) {\n      return true;\n    }\n    if (isContentEditable(node)) {\n      return true;\n    }\n    const { localName, parentNode } = node;\n    switch (localName) {\n      case 'a': {\n        if (node.href || node.hasAttribute('href')) {\n          return true;\n        }\n        return false;\n      }\n      case 'iframe': {\n        return true;\n      }\n      case 'input': {\n        if (node.disabled || node.hasAttribute('disabled') ||\n            node.hidden || node.hasAttribute('hidden')) {\n          return false;\n        }\n        return true;\n      }\n      case 'summary': {\n        if (parentNode.localName === 'details') {\n          let child = parentNode.firstElementChild;\n          let bool = false;\n          while (child) {\n            if (child.localName === 'summary') {\n              bool = child === node;\n              break;\n            }\n            child = child.nextElementSibling;\n          }\n          return bool;\n        }\n        return false;\n      }\n      default: {\n        const keys = ['button', 'select', 'textarea'];\n        if (keys.includes(localName) &&\n            !(node.disabled || node.hasAttribute('disabled'))) {\n          return true;\n        }\n      }\n    }\n  } else if (node instanceof window.SVGElement) {\n    if (Number.isInteger(parseInt(node.getAttributeNS(null, 'tabindex')))) {\n      const keys = [\n        'clipPath', 'defs', 'desc', 'linearGradient', 'marker', 'mask',\n        'metadata', 'pattern', 'radialGradient', 'script', 'style', 'symbol',\n        'title'\n      ];\n      const ns = 'http://www.w3.org/2000/svg';\n      let bool;\n      let refNode = node;\n      while (refNode.namespaceURI === ns) {\n        bool = keys.includes(refNode.localName);\n        if (bool) {\n          break;\n        }\n        if (refNode?.parentNode?.namespaceURI === ns) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n      if (bool) {\n        return false;\n      }\n      return true;\n    }\n    if (node.localName === 'a' &&\n        (node.href || node.hasAttributeNS(null, 'href'))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * is focusable\n * NOTE: not applied, need fix in jsdom itself\n * @see https://github.com/whatwg/html/pull/8392\n * @see https://phabricator.services.mozilla.com/D156219\n * @see https://github.com/jsdom/jsdom/issues/3029\n * @see https://github.com/jsdom/jsdom/issues/3464\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isFocusable = node => {\n  if (node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const window = node.ownerDocument.defaultView;\n  let refNode = node;\n  let res = true;\n  while (refNode) {\n    if (refNode.disabled || refNode.hasAttribute('disabled')) {\n      res = false;\n      break;\n    }\n    if (refNode.hidden || refNode.hasAttribute('hidden')) {\n      res = false;\n    }\n    const {\n      contentVisibility, display, visibility\n    } = window.getComputedStyle(refNode);\n    if (display === 'none' || visibility !== 'visible' ||\n        (contentVisibility === 'hidden' && refNode !== node)) {\n      res = false;\n    } else {\n      res = true;\n    }\n    if (res && refNode?.parentNode?.nodeType === ELEMENT_NODE) {\n      refNode = refNode.parentNode;\n    } else {\n      break;\n    }\n  }\n  return res;\n};\n\n/**\n * get namespace URI\n * @param {string} ns - namespace prefix\n * @param {Array} node - Element node\n * @returns {?string} - namespace URI\n */\nexport const getNamespaceURI = (ns, node) => {\n  if (typeof ns !== 'string') {\n    throw new TypeError(`Unexpected type ${getType(ns)}`);\n  } else if (!node?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(node)}`);\n  }\n  if (!ns || node.nodeType !== ELEMENT_NODE) {\n    return null;\n  }\n  const { attributes } = node;\n  let res;\n  for (const attr of attributes) {\n    const { name, namespaceURI, prefix, value } = attr;\n    if (name === `xmlns:${ns}`) {\n      res = value;\n    } else if (prefix === ns) {\n      res = namespaceURI;\n    }\n    if (res) {\n      break;\n    }\n  }\n  return res ?? null;\n};\n\n/**\n * is namespace declared\n * @param {string} ns - namespace\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const isNamespaceDeclared = (ns = '', node = {}) => {\n  if (!ns || typeof ns !== 'string' || node?.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  if (node.lookupNamespaceURI(ns)) {\n    return true;\n  }\n  const root = node.ownerDocument.documentElement;\n  let parent = node;\n  let res;\n  while (parent) {\n    res = getNamespaceURI(ns, parent);\n    if (res || parent === root) {\n      break;\n    }\n    parent = parent.parentNode;\n  }\n  return !!res;\n};\n\n/**\n * is preceding - nodeA precedes and/or contains nodeB\n * @param {object} nodeA - Element node\n * @param {object} nodeB - Element node\n * @returns {boolean} - result\n */\nexport const isPreceding = (nodeA, nodeB) => {\n  if (!nodeA?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeA)}`);\n  } else if (!nodeB?.nodeType) {\n    throw new TypeError(`Unexpected type ${getType(nodeB)}`);\n  }\n  if (nodeA.nodeType !== ELEMENT_NODE || nodeB.nodeType !== ELEMENT_NODE) {\n    return false;\n  }\n  const posBit = nodeB.compareDocumentPosition(nodeA);\n  const res = posBit & DOCUMENT_POSITION_PRECEDING ||\n              posBit & DOCUMENT_POSITION_CONTAINS;\n  return !!res;\n};\n\n/**\n * sort nodes\n * @param {Array.<object>|Set.<object>} nodes - collection of nodes\n * @returns {Array.<object|undefined>} - collection of sorted nodes\n */\nexport const sortNodes = (nodes = []) => {\n  const arr = [...nodes];\n  if (arr.length > 1) {\n    arr.sort((a, b) => {\n      let res;\n      if (isPreceding(b, a)) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * init nwsapi\n * @param {object} window - Window\n * @param {object} document - Document\n * @returns {object} - nwsapi\n */\nexport const initNwsapi = (window, document) => {\n  if (!window?.DOMException) {\n    throw new TypeError(`Unexpected global object ${getType(window)}`);\n  }\n  if (document?.nodeType !== DOCUMENT_NODE) {\n    document = window.document;\n  }\n  const nw = nwsapi({\n    document,\n    DOMException: window.DOMException\n  });\n  nw.configure({\n    LOGERRORS: false\n  });\n  return nw;\n};\n\n/**\n * filter selector (for nwsapi)\n * @param {string} selector - selector\n * @param {object} opt - options\n * @returns {boolean} - result\n */\nexport const filterSelector = (selector, opt = {}) => {\n  if (!selector || typeof selector !== 'string') {\n    return false;\n  }\n  const { complex, compound, descend, simple, target } = opt;\n  // exclude simple selector and compound selector\n  if (simple || compound) {\n    return false;\n  }\n  // exclude missing close square bracket\n  if (selector.includes('[')) {\n    const index = selector.lastIndexOf('[');\n    const sel = selector.substring(index);\n    if (sel.indexOf(']') < 0) {\n      return false;\n    }\n  }\n  // exclude namespaced selectors, escaped selectors, pseudo-element selectors,\n  // selectors containing non-ASCII or control character other than whitespace,\n  // attribute selectors with case flag, e.g. [attr i], or with unclosed quotes,\n  // and empty :is() or :where()\n  if (/[|\\\\]|::|[^\\u0021-\\u007F\\s]|\\[\\s*[\\w$*=^|~-]+(?:(?:\"[\\w$*=^|~\\s'-]+\"|'[\\w$*=^|~\\s\"-]+')?(?:\\s+[\\w$*=^|~-]+)+|\"[^\"\\]]{1,255}|'[^'\\]]{1,255})\\s*\\]|:(?:is|where)\\(\\s*\\)/.test(selector)) {\n    return false;\n  }\n  // include pseudo-classes that are known to work correctly\n  if (selector.includes(':')) {\n    if (descend) {\n      return false;\n    } else if ((target === TARGET_SELF || target === TARGET_LINEAL) &&\n               /:has\\(/.test(selector)) {\n      return !REG_LOGIC_HAS_COMPOUND.test(selector);\n    } else if (/:(?:is|not)\\(/.test(selector)) {\n      if (complex) {\n        return !REG_LOGIC_COMPLEX.test(selector);\n      } else {\n        return !REG_LOGIC_COMPOUND.test(selector);\n      }\n    } else {\n      return !REG_WO_LOGICAL.test(selector);\n    }\n  }\n  return true;\n};\n", "/**\n * constant.js\n */\n\n/* string */\nexport const ATTR_SELECTOR = 'AttributeSelector';\nexport const CLASS_SELECTOR = 'ClassSelector';\nexport const COMBINATOR = 'Combinator';\nexport const IDENT = 'Identifier';\nexport const ID_SELECTOR = 'IdSelector';\nexport const NOT_SUPPORTED_ERR = 'NotSupportedError';\nexport const NTH = 'Nth';\nexport const OPERATOR = 'Operator';\nexport const PS_CLASS_SELECTOR = 'PseudoClassSelector';\nexport const PS_ELEMENT_SELECTOR = 'PseudoElementSelector';\nexport const SELECTOR = 'Selector';\nexport const STRING = 'String';\nexport const SYNTAX_ERR = 'SyntaxError';\nexport const TARGET_ALL = 'all';\nexport const TARGET_FIRST = 'first';\nexport const TARGET_LINEAL = 'lineal';\nexport const TARGET_SELF = 'self';\nexport const TYPE_SELECTOR = 'TypeSelector';\n\n/* numeric */\nexport const BIT_01 = 1;\nexport const BIT_02 = 2;\nexport const BIT_04 = 4;\nexport const BIT_08 = 8;\nexport const BIT_16 = 0x10;\nexport const BIT_32 = 0x20;\nexport const BIT_FFFF = 0xFFFF;\nexport const DUO = 2;\nexport const HEX = 16;\nexport const HYPHEN = 0x2D;\nexport const TYPE_FROM = 8;\nexport const TYPE_TO = -1;\n\n/* Node */\nexport const ELEMENT_NODE = 1;\nexport const TEXT_NODE = 3;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\nexport const DOCUMENT_POSITION_PRECEDING = 2;\nexport const DOCUMENT_POSITION_CONTAINS = 8;\nexport const DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n\n/* NodeFilter */\nexport const SHOW_ALL = 0xFFFFFFFF;\nexport const SHOW_DOCUMENT = 0x100;\nexport const SHOW_DOCUMENT_FRAGMENT = 0x400;\nexport const SHOW_ELEMENT = 1;\nexport const WALKER_FILTER = 0x501;\n\n/* selectors */\nexport const ALPHA_NUM = '[A-Z\\\\d]+';\nexport const CHILD_IDX = '(?:first|last|only)-(?:child|of-type)';\nexport const DIGIT = '(?:0|[1-9]\\\\d*)';\nexport const LANG_PART = `(?:-${ALPHA_NUM})*`;\nexport const PSEUDO_CLASS = `(?:any-)?link|${CHILD_IDX}|checked|empty|indeterminate|read-(?:only|write)|root|target`;\nexport const ANB =\n  `[+-]?(?:${DIGIT}n?|n)|(?:[+-]?${DIGIT})?n\\\\s*[+-]\\\\s*${DIGIT}`;\n// N_TH: excludes An+B with selector list, e.g. :nth-child(2n+1 of .foo)\nexport const N_TH =\n  `nth-(?:last-)?(?:child|of-type)\\\\(\\\\s*(?:even|odd|${ANB})\\\\s*\\\\)`;\n// SUB_TYPE: attr, id, class, pseudo-class, note that [foo|=bar] is excluded\nexport const SUB_TYPE = '\\\\[[^|\\\\]]+\\\\]|[#.:][\\\\w-]+';\nexport const SUB_TYPE_WO_PSEUDO = '\\\\[[^|\\\\]]+\\\\]|[#.][\\\\w-]+';\n// TAG_TYPE: *, tag\nexport const TAG_ID_CLASS = '(?:[A-Za-z][\\\\w-]*|[#.][\\\\w-]+)';\nexport const TAG_TYPE = '\\\\*|[A-Za-z][\\\\w-]*';\nexport const TAG_TYPE_I = '\\\\*|[A-Z][\\\\w-]*';\nexport const COMPOUND = `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE})+)`;\nexport const COMPOUND_WO_PSEUDO =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE_WO_PSEUDO})+)`;\nexport const COMBO = '\\\\s?[\\\\s>~+]\\\\s?';\nexport const COMPLEX = `${COMPOUND}(?:${COMBO}${COMPOUND})*`;\nexport const DESCEND = '\\\\s?[\\\\s>]\\\\s?';\nexport const NESTED_LOGIC_A =\n  `:is\\\\(\\\\s*${COMPOUND}(?:\\\\s*,\\\\s*${COMPOUND})*\\\\s*\\\\)`;\nexport const NESTED_LOGIC_B =\n  `:is\\\\(\\\\s*${COMPLEX}(?:\\\\s*,\\\\s*${COMPLEX})*\\\\s*\\\\)`;\nexport const COMPOUND_A =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE}|${NESTED_LOGIC_A})+)`;\nexport const COMPOUND_B =\n  `(?:${TAG_TYPE}|(?:${TAG_TYPE})?(?:${SUB_TYPE}|${NESTED_LOGIC_B})+)`;\nexport const COMPOUND_I =\n  `(?:${TAG_TYPE_I}|(?:${TAG_TYPE_I})?(?:${SUB_TYPE})+)`;\nexport const COMPLEX_L = `${COMPOUND_B}(?:${COMBO}${COMPOUND_B})*`;\nexport const LOGIC_COMPLEX =\n  `(?:is|not)\\\\(\\\\s*${COMPLEX_L}(?:\\\\s*,\\\\s*${COMPLEX_L})*\\\\s*\\\\)`;\nexport const LOGIC_COMPOUND =\n  `(?:is|not)\\\\(\\\\s*${COMPOUND_A}(?:\\\\s*,\\\\s*${COMPOUND_A})*\\\\s*\\\\)`;\nexport const HAS_COMPOUND = `has\\\\([\\\\s>~+]?\\\\s*${COMPOUND_WO_PSEUDO}\\\\s*\\\\)`;\n\n/* array */\nexport const KEY_FORM_FOCUS =\n  Object.freeze(['button', 'input', 'select', 'textarea']);\nexport const KEY_INPUT_BUTTON = Object.freeze(['button', 'reset', 'submit']);\nexport const KEY_INPUT_DATE =\n  Object.freeze(['date', 'datetime-local', 'month', 'time', 'week']);\nexport const KEY_INPUT_TEXT =\n  Object.freeze(['email', 'password', 'search', 'tel', 'text', 'url']);\nexport const KEY_INPUT_EDIT =\n  Object.freeze([...KEY_INPUT_DATE, ...KEY_INPUT_TEXT, 'number']);\nexport const KEY_INPUT_LTR = Object.freeze([\n  'checkbox', 'color', 'date', 'image', 'number', 'range', 'radio', 'time'\n]);\nexport const KEY_LOGICAL = Object.freeze(['has', 'is', 'not', 'where']);\nexport const KEY_MODIFIER = Object.freeze([\n  'Alt', 'AltGraph', 'CapsLock', 'Control', 'Fn', 'FnLock', 'Hyper', 'Meta',\n  'NumLock', 'ScrollLock', 'Shift', 'Super', 'Symbol', 'SymbolLock'\n]);\nexport const KEY_PS_STATE = Object.freeze([\n  'enabled', 'disabled', 'valid', 'invalid', 'in-range', 'out-of-range',\n  'checked', 'indeterminate', 'read-only', 'read-write', 'open', 'closed',\n  'placeholder-shown'\n]);\nexport const KEY_SHADOW_HOST = Object.freeze(['host', 'host-context']);\n", "/**\n * parser.js\n */\n\n/* import */\nimport { findAll, parse, toPlainObject, walk } from 'css-tree';\nimport { getType } from './utility.js';\n\n/* constants */\nimport {\n  ATTR_SELECTOR, BIT_01, BIT_02, BIT_04, BIT_08, BIT_16, BIT_32, BIT_FFFF,\n  CLASS_SELECTOR, DUO, HEX, HYPHEN, ID_SELECTOR, KEY_LOGICAL, KEY_PS_STATE,\n  KEY_SHADOW_HOST, NTH, PS_CLASS_SELECTOR, PS_ELEMENT_SELECTOR, SELECTOR,\n  SYNTAX_ERR, TYPE_SELECTOR\n} from './constant.js';\nconst REG_EMPTY_PS_FUNC = /(?<=:(?:dir|has|host(?:-context)?|is|lang|not|nth-(?:last-)?(?:child|of-type)|where))\\(\\s+\\)/g;\nconst REG_SHADOW_PS_ELEMENT = /^part|slotted$/;\nconst U_FFFD = '\\uFFFD';\n\n/**\n * unescape selector\n * @param {string} selector - CSS selector\n * @returns {?string} - unescaped selector\n */\nexport const unescapeSelector = (selector = '') => {\n  if (typeof selector === 'string' && selector.indexOf('\\\\', 0) >= 0) {\n    const arr = selector.split('\\\\');\n    const l = arr.length;\n    for (let i = 1; i < l; i++) {\n      let item = arr[i];\n      if (item === '' && i === l - 1) {\n        item = U_FFFD;\n      } else {\n        const hexExists = /^([\\da-f]{1,6}\\s?)/i.exec(item);\n        if (hexExists) {\n          const [, hex] = hexExists;\n          let str;\n          try {\n            const low = parseInt('D800', HEX);\n            const high = parseInt('DFFF', HEX);\n            const deci = parseInt(hex, HEX);\n            if (deci === 0 || (deci >= low && deci <= high)) {\n              str = U_FFFD;\n            } else {\n              str = String.fromCodePoint(deci);\n            }\n          } catch (e) {\n            str = U_FFFD;\n          }\n          let postStr = '';\n          if (item.length > hex.length) {\n            postStr = item.substring(hex.length);\n          }\n          item = `${str}${postStr}`;\n        // whitespace\n        } else if (/^[\\n\\r\\f]/.test(item)) {\n          item = '\\\\' + item;\n        }\n      }\n      arr[i] = item;\n    }\n    selector = arr.join('');\n  }\n  return selector;\n};\n\n/**\n * preprocess\n * @see https://drafts.csswg.org/css-syntax-3/#input-preprocessing\n * @param {...*} args - arguments\n * @returns {string} - filtered selector string\n */\nexport const preprocess = (...args) => {\n  if (!args.length) {\n    throw new TypeError('1 argument required, but only 0 present.');\n  }\n  let [selector] = args;\n  if (typeof selector === 'string') {\n    let index = 0;\n    while (index >= 0) {\n      // @see https://drafts.csswg.org/selectors/#id-selectors\n      index = selector.indexOf('#', index);\n      if (index < 0) {\n        break;\n      }\n      const preHash = selector.substring(0, index + 1);\n      let postHash = selector.substring(index + 1);\n      // @see https://drafts.csswg.org/css-syntax-3/#ident-token-diagram\n      if (/^\\d$/.test(postHash.substring(0, 1))) {\n        throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n      }\n      const codePoint = postHash.codePointAt(0);\n      if (codePoint === HYPHEN) {\n        if (/^\\d$/.test(postHash.substring(1, 2))) {\n          throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n        }\n      // escape char above 0xFFFF\n      } else if (codePoint > BIT_FFFF) {\n        const str = `\\\\${codePoint.toString(HEX)} `;\n        if (postHash.length === DUO) {\n          postHash = str;\n        } else {\n          postHash = `${str}${postHash.substring(DUO)}`;\n        }\n      }\n      selector = `${preHash}${postHash}`;\n      index++;\n    }\n    selector = selector.replace(/\\f|\\r\\n?/g, '\\n')\n      .replace(/[\\0\\uD800-\\uDFFF]|\\\\$/g, U_FFFD);\n  } else if (selector === undefined || selector === null) {\n    selector = getType(selector).toLowerCase();\n  } else if (Array.isArray(selector)) {\n    selector = selector.join(',');\n  } else if (Object.prototype.hasOwnProperty.call(selector, 'toString')) {\n    selector = selector.toString();\n  } else {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  return selector;\n};\n\n/**\n * create AST from CSS selector\n * @param {string} selector - CSS selector\n * @returns {object} - AST\n */\nexport const parseSelector = selector => {\n  selector = preprocess(selector);\n  // invalid selectors\n  if (/^$|^\\s*>|,\\s*$/.test(selector)) {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  let res;\n  try {\n    const ast = parse(selector, {\n      context: 'selectorList',\n      parseCustomProperty: true\n    });\n    res = toPlainObject(ast);\n  } catch (e) {\n    const { message } = e;\n    if (/^(?:\"\\]\"|Attribute selector [()\\s,=~^$*|]+) is expected$/.test(message) &&\n        !selector.endsWith(']')) {\n      const index = selector.lastIndexOf('[');\n      const sel = selector.substring(index);\n      if (sel.includes('\"')) {\n        const quotes = sel.match(/\"/g).length;\n        if (quotes % 2) {\n          res = parseSelector(`${selector}\"]`);\n        } else {\n          res = parseSelector(`${selector}]`);\n        }\n      } else {\n        res = parseSelector(`${selector}]`);\n      }\n    } else if (message === '\")\" is expected') {\n      // workaround for https://github.com/csstree/csstree/issues/283\n      if (REG_EMPTY_PS_FUNC.test(selector)) {\n        res = parseSelector(`${selector.replaceAll(REG_EMPTY_PS_FUNC, '()')}`);\n      } else if (!selector.endsWith(')')) {\n        res = parseSelector(`${selector})`);\n      } else {\n        throw new DOMException(message, SYNTAX_ERR);\n      }\n    } else {\n      throw new DOMException(message, SYNTAX_ERR);\n    }\n  }\n  return res;\n};\n\n/**\n * walk AST\n * @param {object} ast - AST\n * @returns {Array.<object|undefined>} - collection of AST branches\n */\nexport const walkAST = (ast = {}) => {\n  const branches = new Set();\n  const info = new Map();\n  const opt = {\n    enter: node => {\n      switch (node.type) {\n        case SELECTOR: {\n          branches.add(node.children);\n          break;\n        }\n        case PS_CLASS_SELECTOR: {\n          if (KEY_LOGICAL.includes(node.name)) {\n            info.set('hasNestedSelector', true);\n            info.set('hasLogicalPseudoFunc', true);\n            if (node.name === 'has') {\n              info.set('hasHasPseudoFunc', true);\n            }\n          } else if (KEY_PS_STATE.includes(node.name)) {\n            info.set('hasStatePseudoClass', true);\n          } else if (KEY_SHADOW_HOST.includes(node.name) &&\n                     Array.isArray(node.children) && node.children.length) {\n            info.set('hasNestedSelector', true);\n          }\n          break;\n        }\n        case PS_ELEMENT_SELECTOR: {\n          if (REG_SHADOW_PS_ELEMENT.test(node.name)) {\n            info.set('hasNestedSelector', true);\n          }\n          break;\n        }\n        case NTH: {\n          if (node.selector) {\n            info.set('hasNestedSelector', true);\n            info.set('hasNthChildOfSelector', true);\n          }\n          break;\n        }\n        default:\n      }\n    }\n  };\n  walk(ast, opt);\n  if (info.get('hasNestedSelector')) {\n    findAll(ast, (node, item, list) => {\n      if (list) {\n        if (node.type === PS_CLASS_SELECTOR &&\n            KEY_LOGICAL.includes(node.name)) {\n          const itemList = list.filter(i => {\n            const { name, type } = i;\n            return type === PS_CLASS_SELECTOR && KEY_LOGICAL.includes(name);\n          });\n          for (const { children } of itemList) {\n            // SelectorList\n            for (const { children: grandChildren } of children) {\n              // Selector\n              for (const { children: greatGrandChildren } of grandChildren) {\n                if (branches.has(greatGrandChildren)) {\n                  branches.delete(greatGrandChildren);\n                }\n              }\n            }\n          }\n        } else if (node.type === PS_CLASS_SELECTOR &&\n                   KEY_SHADOW_HOST.includes(node.name) &&\n                   Array.isArray(node.children) && node.children.length) {\n          const itemList = list.filter(i => {\n            const { children, name, type } = i;\n            const res =\n              type === PS_CLASS_SELECTOR && KEY_SHADOW_HOST.includes(name) &&\n              Array.isArray(children) && children.length;\n            return res;\n          });\n          for (const { children } of itemList) {\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        } else if (node.type === PS_ELEMENT_SELECTOR &&\n                   REG_SHADOW_PS_ELEMENT.test(node.name)) {\n          const itemList = list.filter(i => {\n            const { name, type } = i;\n            const res =\n              type === PS_ELEMENT_SELECTOR && REG_SHADOW_PS_ELEMENT.test(name);\n            return res;\n          });\n          for (const { children } of itemList) {\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        } else if (node.type === NTH && node.selector) {\n          const itemList = list.filter(i => {\n            const { selector, type } = i;\n            const res = type === NTH && selector;\n            return res;\n          });\n          for (const { selector } of itemList) {\n            const { children } = selector;\n            // Selector\n            for (const { children: grandChildren } of children) {\n              if (branches.has(grandChildren)) {\n                branches.delete(grandChildren);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  return {\n    branches: [...branches],\n    info: Object.fromEntries(info)\n  };\n};\n\n/**\n * sort AST\n * @param {Array.<object>} asts - collection of AST\n * @returns {Array.<object>} - collection of sorted AST\n */\nexport const sortAST = asts => {\n  const arr = [...asts];\n  if (arr.length > 1) {\n    const order = new Map([\n      [PS_ELEMENT_SELECTOR, BIT_01],\n      [ID_SELECTOR, BIT_02],\n      [CLASS_SELECTOR, BIT_04],\n      [TYPE_SELECTOR, BIT_08],\n      [ATTR_SELECTOR, BIT_16],\n      [PS_CLASS_SELECTOR, BIT_32]\n    ]);\n    arr.sort((a, b) => {\n      const { type: typeA } = a;\n      const { type: typeB } = b;\n      const bitA = order.get(typeA);\n      const bitB = order.get(typeB);\n      let res;\n      if (bitA === bitB) {\n        res = 0;\n      } else if (bitA > bitB) {\n        res = 1;\n      } else {\n        res = -1;\n      }\n      return res;\n    });\n  }\n  return arr;\n};\n\n/**\n * parse AST name - e.g. ns|E -> { prefix: ns, localName: E }\n * @param {string} selector - type selector\n * @returns {object} - node properties\n */\nexport const parseAstName = selector => {\n  let prefix;\n  let localName;\n  if (selector && typeof selector === 'string') {\n    if (selector.indexOf('|') > -1) {\n      [prefix, localName] = selector.split('|');\n    } else {\n      prefix = '*';\n      localName = selector;\n    }\n  } else {\n    throw new DOMException(`Invalid selector ${selector}`, SYNTAX_ERR);\n  }\n  return {\n    prefix,\n    localName\n  };\n};\n\n/* export */\nexport { find as findAST, generate as generateCSS } from 'css-tree';\n", "/**\n * matcher.js\n */\n\n/* import */\nimport { generateCSS, parseAstName, unescapeSelector } from './parser.js';\nimport { getDirectionality, getType, isNamespaceDeclared } from './utility.js';\n\n/* constants */\nimport {\n  ALPHA_NUM, ELEMENT_NODE, IDENT, LANG_PART, NOT_SUPPORTED_ERR,\n  PS_ELEMENT_SELECTOR, STRING, SYNTAX_ERR\n} from './constant.js';\n\n/**\n * match pseudo-element selector\n * @param {string} astName - AST name\n * @param {string} astType - AST type\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive unknown pseudo-element\n * @param {boolean} [opt.warn] - warn unsupported pseudo-element\n * @throws {DOMException}\n * @returns {void}\n */\nexport const matchPseudoElementSelector = (astName, astType, opt = {}) => {\n  const { forgive, warn } = opt;\n  if (astType === PS_ELEMENT_SELECTOR) {\n    switch (astName) {\n      case 'after':\n      case 'backdrop':\n      case 'before':\n      case 'cue':\n      case 'cue-region':\n      case 'first-letter':\n      case 'first-line':\n      case 'file-selector-button':\n      case 'marker':\n      case 'placeholder':\n      case 'selection':\n      case 'target-text': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      case 'part':\n      case 'slotted': {\n        if (warn) {\n          throw new DOMException(`Unsupported pseudo-element ::${astName}()`,\n            NOT_SUPPORTED_ERR);\n        }\n        break;\n      }\n      default: {\n        if (astName.startsWith('-webkit-')) {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n        } else if (!forgive) {\n          throw new DOMException(`Unknown pseudo-element ::${astName}`,\n            SYNTAX_ERR);\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`Unexpected ast type ${getType(astType)}`);\n  }\n};\n\n/**\n * match directionality pseudo-class - :dir()\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchDirectionPseudoClass = (ast, node) => {\n  const { name } = ast;\n  if (!name) {\n    let type;\n    if (name === '') {\n      type = '(empty String)';\n    } else {\n      type = getType(name);\n    }\n    throw new TypeError(`Unexpected ast type ${type}`);\n  }\n  const dir = getDirectionality(node);\n  return name === dir;\n};\n\n/**\n * match language pseudo-class - :lang()\n * @see https://datatracker.ietf.org/doc/html/rfc4647#section-3.3.1\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchLanguagePseudoClass = (ast, node) => {\n  const { name, type, value } = ast;\n  let astName;\n  if (type === STRING && value) {\n    astName = value;\n  } else if (type === IDENT && name) {\n    astName = unescapeSelector(name);\n  }\n  if (astName === '*') {\n    if (node.hasAttribute('lang')) {\n      if (node.getAttribute('lang')) {\n        return true;\n      }\n    } else {\n      let parent = node.parentNode;\n      let res;\n      while (parent) {\n        if (parent.nodeType === ELEMENT_NODE) {\n          if (parent.hasAttribute('lang')) {\n            if (parent.getAttribute('lang')) {\n              res = true;\n            }\n            break;\n          }\n          parent = parent.parentNode;\n        } else {\n          break;\n        }\n      }\n      return !!res;\n    }\n  } else if (astName) {\n    const reg = new RegExp(`^(?:\\\\*-)?${ALPHA_NUM}${LANG_PART}$`, 'i');\n    if (reg.test(astName)) {\n      let regExtendedLang;\n      if (astName.indexOf('-') > -1) {\n        const [langMain, langSub, ...langRest] = astName.split('-');\n        let extendedMain;\n        if (langMain === '*') {\n          extendedMain = `${ALPHA_NUM}${LANG_PART}`;\n        } else {\n          extendedMain = `${langMain}${LANG_PART}`;\n        }\n        const extendedSub = `-${langSub}${LANG_PART}`;\n        const len = langRest.length;\n        let extendedRest = '';\n        if (len) {\n          for (let i = 0; i < len; i++) {\n            extendedRest += `-${langRest[i]}${LANG_PART}`;\n          }\n        }\n        regExtendedLang =\n          new RegExp(`^${extendedMain}${extendedSub}${extendedRest}$`, 'i');\n      } else {\n        regExtendedLang = new RegExp(`^${astName}${LANG_PART}$`, 'i');\n      }\n      if (node.hasAttribute('lang')) {\n        return regExtendedLang.test(node.getAttribute('lang'));\n      } else {\n        let parent = node.parentNode;\n        let res;\n        while (parent) {\n          if (parent.nodeType === ELEMENT_NODE) {\n            if (parent.hasAttribute('lang')) {\n              res = regExtendedLang.test(parent.getAttribute('lang'));\n              break;\n            }\n            parent = parent.parentNode;\n          } else {\n            break;\n          }\n        }\n        return !!res;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * match attribute selector\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @returns {boolean} - result\n */\nexport const matchAttributeSelector = (ast, node) => {\n  const {\n    flags: astFlags, matcher: astMatcher, name: astName, value: astValue\n  } = ast;\n  if (typeof astFlags === 'string' && !/^[is]$/i.test(astFlags)) {\n    const css = generateCSS(ast);\n    throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n  }\n  const { attributes } = node;\n  if (attributes?.length) {\n    const contentType = node.ownerDocument.contentType;\n    let caseInsensitive;\n    if (contentType === 'text/html') {\n      if (typeof astFlags === 'string' && /^s$/i.test(astFlags)) {\n        caseInsensitive = false;\n      } else {\n        caseInsensitive = true;\n      }\n    } else if (typeof astFlags === 'string' && /^i$/i.test(astFlags)) {\n      caseInsensitive = true;\n    } else {\n      caseInsensitive = false;\n    }\n    let astAttrName = unescapeSelector(astName.name);\n    if (caseInsensitive) {\n      astAttrName = astAttrName.toLowerCase();\n    }\n    const attrValues = new Set();\n    // namespaced\n    if (astAttrName.indexOf('|') > -1) {\n      const {\n        prefix: astPrefix, localName: astLocalName\n      } = parseAstName(astAttrName);\n      for (const item of attributes) {\n        let { name: itemName, value: itemValue } = item;\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        switch (astPrefix) {\n          case '': {\n            if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          case '*': {\n            if (itemName.indexOf(':') > -1) {\n              if (itemName.endsWith(`:${astLocalName}`)) {\n                attrValues.add(itemValue);\n              }\n            } else if (astLocalName === itemName) {\n              attrValues.add(itemValue);\n            }\n            break;\n          }\n          default: {\n            if (itemName.indexOf(':') > -1) {\n              const [itemPrefix, itemLocalName] = itemName.split(':');\n              // ignore xml:lang\n              if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n                continue;\n              } else if (astPrefix === itemPrefix &&\n                           astLocalName === itemLocalName) {\n                const namespaceDeclared =\n                    isNamespaceDeclared(astPrefix, node);\n                if (namespaceDeclared) {\n                  attrValues.add(itemValue);\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      for (let { name: itemName, value: itemValue } of attributes) {\n        if (caseInsensitive) {\n          itemName = itemName.toLowerCase();\n          itemValue = itemValue.toLowerCase();\n        }\n        if (itemName.indexOf(':') > -1) {\n          const [itemPrefix, itemLocalName] = itemName.split(':');\n          // ignore xml:lang\n          if (itemPrefix === 'xml' && itemLocalName === 'lang') {\n            continue;\n          } else if (astAttrName === itemLocalName) {\n            attrValues.add(itemValue);\n          }\n        } else if (astAttrName === itemName) {\n          attrValues.add(itemValue);\n        }\n      }\n    }\n    if (attrValues.size) {\n      const { name: astIdentValue, value: astStringValue } = astValue ?? {};\n      let attrValue;\n      if (astIdentValue) {\n        if (caseInsensitive) {\n          attrValue = astIdentValue.toLowerCase();\n        } else {\n          attrValue = astIdentValue;\n        }\n      } else if (astStringValue) {\n        if (caseInsensitive) {\n          attrValue = astStringValue.toLowerCase();\n        } else {\n          attrValue = astStringValue;\n        }\n      } else if (astStringValue === '') {\n        attrValue = astStringValue;\n      }\n      switch (astMatcher) {\n        case '=': {\n          return typeof attrValue === 'string' && attrValues.has(attrValue);\n        }\n        case '~=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let res;\n            for (const value of attrValues) {\n              const item = new Set(value.split(/\\s+/));\n              if (item.has(attrValue)) {\n                res = true;\n                break;\n              }\n            }\n            return !!res;\n          }\n          return false;\n        }\n        case '|=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value === attrValue || value.startsWith(`${attrValue}-`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '^=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.startsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '$=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.endsWith(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case '*=': {\n          if (attrValue && typeof attrValue === 'string') {\n            let item;\n            for (const value of attrValues) {\n              if (value.includes(`${attrValue}`)) {\n                item = value;\n                break;\n              }\n            }\n            if (item) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        }\n        case null:\n        default: {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * match type selector\n * @param {object} ast - AST\n * @param {object} node - Element node\n * @param {object} opt - options\n * @param {boolean} [opt.forgive] - forgive undeclared namespace\n * @returns {boolean} - result\n */\nexport const matchTypeSelector = (ast, node, opt = {}) => {\n  const astName = unescapeSelector(ast.name);\n  const { localName, namespaceURI, prefix } = node;\n  const { forgive } = opt;\n  let {\n    prefix: astPrefix, localName: astLocalName\n  } = parseAstName(astName, node);\n  if (node.ownerDocument.contentType === 'text/html' &&\n      /[A-Z][\\\\w-]*/i.test(localName)) {\n    astPrefix = astPrefix.toLowerCase();\n    astLocalName = astLocalName.toLowerCase();\n  }\n  let nodePrefix;\n  let nodeLocalName;\n  // just in case that the namespaced content is parsed as text/html\n  if (localName.indexOf(':') > -1) {\n    [nodePrefix, nodeLocalName] = localName.split(':');\n  } else {\n    nodePrefix = prefix || '';\n    nodeLocalName = localName;\n  }\n  switch (astPrefix) {\n    case '': {\n      if (!nodePrefix && !namespaceURI &&\n          (astLocalName === '*' || astLocalName === nodeLocalName)) {\n        return true;\n      }\n      return false;\n    }\n    case '*': {\n      if (astLocalName === '*' || astLocalName === nodeLocalName) {\n        return true;\n      }\n      return false;\n    }\n    default: {\n      const astNS = node.lookupNamespaceURI(astPrefix);\n      const nodeNS = node.lookupNamespaceURI(nodePrefix);\n      if (astNS === nodeNS && astPrefix === nodePrefix) {\n        if (astLocalName === '*' || astLocalName === nodeLocalName) {\n          return true;\n        }\n        return false;\n      } else if (!forgive && !astNS) {\n        throw new DOMException(`Undeclared namespace ${astPrefix}`, SYNTAX_ERR);\n      }\n      return false;\n    }\n  }\n};\n", "/**\n * finder.js\n */\n\n/* import */\nimport {\n  matchAttributeSelector, matchDirectionPseudoClass, matchLanguagePseudoClass,\n  matchPseudoElementSelector, matchTypeSelector\n} from './matcher.js';\nimport {\n  findAST, generateCSS, parseSelector, sortAST, unescapeSelector, walkAST\n} from './parser.js';\nimport {\n  isContentEditable, isCustomElement, isFocusVisible, isFocusableArea,\n  isVisible, resolveContent, sortNodes, traverseNode\n} from './utility.js';\n\n/* constants */\nimport {\n  ATTR_SELECTOR, BIT_01, CLASS_SELECTOR, COMBINATOR, DOCUMENT_FRAGMENT_NODE,\n  ELEMENT_NODE, ID_SELECTOR, KEY_FORM_FOCUS, KEY_INPUT_DATE, KEY_INPUT_EDIT,\n  KEY_INPUT_TEXT, KEY_LOGICAL, KEY_MODIFIER, NOT_SUPPORTED_ERR,\n  PS_CLASS_SELECTOR, PS_ELEMENT_SELECTOR, SHOW_ALL, SYNTAX_ERR, TARGET_ALL,\n  TARGET_FIRST, TARGET_LINEAL, TARGET_SELF, TEXT_NODE, TYPE_SELECTOR,\n  WALKER_FILTER\n} from './constant.js';\nconst DIR_NEXT = 'next';\nconst DIR_PREV = 'prev';\n\n/**\n * Finder\n * NOTE: #ast[i] corresponds to #nodes[i]\n * #ast: Array<Ast | undefined>\n * #nodes: Array<Nodes>\n * Ast: {\n *   branch: Array<Branch | undefined>,\n *   dir: string | null,\n *   filtered: boolean,\n *   find: boolean\n * }\n * Branch: Array<Twig>\n * Twig: {\n *   combo: Leaf | null,\n *   leaves: Array<Leaf>\n * }\n * Leaf: {\n *   children: Array<Leaf | undefined> | null,\n *   loc: null,\n *   type: string\n * }\n * Nodes: Array<HTMLElement | undefined>\n */\nexport class Finder {\n  /* private fields */\n  #ast;\n  #astCache;\n  #descendant;\n  #document;\n  #documentCache;\n  #event;\n  #focus;\n  #invalidate;\n  #invalidateResults;\n  #lastFocusVisible;\n  #node;\n  #nodes;\n  #noexcept;\n  #qswalker;\n  #results;\n  #root;\n  #selector;\n  #shadow;\n  #verifyShadowHost;\n  #walkers;\n  #warn;\n  #window;\n\n  /**\n   * construct\n   * @param {object} window - window\n   */\n  constructor(window) {\n    this.#window = window;\n    this.#astCache = new WeakMap();\n    this.#documentCache = new WeakMap();\n    this.#invalidateResults = new WeakMap();\n    this.#results = new WeakMap();\n    this.#event = null;\n    this.#focus = null;\n    this.#lastFocusVisible = null;\n    this._registerEventListeners();\n  }\n\n  /**\n   * handle error\n   * @param {Error} e - Error\n   * @param {object} opt - options\n   * @throws Error\n   * @returns {void}\n   */\n  onError(e, opt) {\n    const noexcept = opt?.noexcept ?? this.#noexcept;\n    if (!noexcept) {\n      if (e instanceof DOMException ||\n          e instanceof this.#window.DOMException) {\n        if (e.name === NOT_SUPPORTED_ERR) {\n          if (this.#warn) {\n            console.warn(e.message);\n          }\n        } else {\n          throw new this.#window.DOMException(e.message, e.name);\n        }\n      } else if (e.name in this.#window) {\n        throw new this.#window[e.name](e.message);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * setup finder\n   * @param {string} selector - CSS selector\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {object} [opt.event] - MouseEvent, KeyboardEvent\n   * @param {boolean} [opt.noexcept] - no exception\n   * @param {boolean} [opt.warn] - console warn\n   * @returns {object} - finder\n   */\n  setup(selector, node, opt = {}) {\n    const { noexcept, warn } = opt;\n    this.#noexcept = !!noexcept;\n    this.#warn = !!warn;\n    this.#node = node;\n    [\n      this.#document,\n      this.#root,\n      this.#shadow\n    ] = resolveContent(node);\n    this.#selector = selector;\n    [\n      this.#ast,\n      this.#nodes\n    ] = this._correspond(selector);\n    this.#invalidateResults = new WeakMap();\n    this.#walkers = new WeakMap();\n    this.#verifyShadowHost = null;\n    return this;\n  }\n\n  /**\n   * register event listeners\n   * @private\n   * @returns {Array.<void>} - results\n   */\n  _registerEventListeners() {\n    const opt = {\n      capture: true,\n      passive: true\n    };\n    const func = [];\n    const focusKeys = ['focus', 'focusin'];\n    for (const key of focusKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#focus = evt;\n      }, opt));\n    }\n    const keyboardKeys = ['keydown', 'keyup'];\n    for (const key of keyboardKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        const { key } = evt;\n        if (!KEY_MODIFIER.includes(key)) {\n          this.#event = evt;\n        }\n      }, opt));\n    }\n    const mouseKeys = [\n      'mouseover', 'mousedown', 'mouseup', 'click', 'mouseout'\n    ];\n    for (const key of mouseKeys) {\n      func.push(this.#window.addEventListener(key, evt => {\n        this.#event = evt;\n      }, opt));\n    }\n    return func;\n  }\n\n  /**\n   * correspond ast and nodes\n   * @private\n   * @param {string} selector - CSS selector\n   * @returns {Array.<Array.<object|undefined>>} - array of ast and nodes\n   */\n  _correspond(selector) {\n    const nodes = [];\n    this.#descendant = false;\n    this.#invalidate = false;\n    let ast;\n    if (this.#documentCache.has(this.#document)) {\n      const cachedItem = this.#documentCache.get(this.#document);\n      if (cachedItem && cachedItem.has(`${selector}`)) {\n        const item = cachedItem.get(`${selector}`);\n        ast = item.ast;\n        this.#descendant = item.descendant;\n        this.#invalidate = item.invalidate;\n      }\n    }\n    if (ast) {\n      const l = ast.length;\n      for (let i = 0; i < l; i++) {\n        ast[i].dir = null;\n        ast[i].filtered = false;\n        ast[i].find = false;\n        nodes[i] = [];\n      }\n    } else {\n      let cssAst;\n      try {\n        cssAst = parseSelector(selector);\n      } catch (e) {\n        this.onError(e);\n      }\n      const { branches, info } = walkAST(cssAst);\n      const {\n        hasHasPseudoFunc, hasLogicalPseudoFunc, hasNthChildOfSelector,\n        hasStatePseudoClass\n      } = info;\n      let invalidate = hasHasPseudoFunc || hasStatePseudoClass ||\n        !!(hasLogicalPseudoFunc && hasNthChildOfSelector);\n      let descendant = false;\n      let i = 0;\n      ast = [];\n      for (const [...items] of branches) {\n        const branch = [];\n        let item = items.shift();\n        if (item && item.type !== COMBINATOR) {\n          const leaves = new Set();\n          while (item) {\n            let itemName = item.name;\n            if (item.type === COMBINATOR) {\n              const [nextItem] = items;\n              if (nextItem.type === COMBINATOR) {\n                throw new DOMException(`Invalid selector ${selector}`,\n                  SYNTAX_ERR);\n              }\n              if (itemName === '+' || itemName === '~') {\n                invalidate = true;\n              } else {\n                descendant = true;\n              }\n              branch.push({\n                combo: item,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n            } else if (item) {\n              if (itemName && typeof itemName === 'string') {\n                itemName = unescapeSelector(itemName);\n                if (typeof itemName === 'string' && itemName !== item.name) {\n                  item.name = itemName;\n                }\n                if (/[|:]/.test(itemName)) {\n                  item.namespace = true;\n                }\n              }\n              leaves.add(item);\n            }\n            if (items.length) {\n              item = items.shift();\n            } else {\n              branch.push({\n                combo: null,\n                leaves: sortAST(leaves)\n              });\n              leaves.clear();\n              break;\n            }\n          }\n        }\n        ast.push({\n          branch,\n          dir: null,\n          filtered: false,\n          find: false\n        });\n        nodes[i] = [];\n        i++;\n      }\n      let cachedItem;\n      if (this.#documentCache.has(this.#document)) {\n        cachedItem = this.#documentCache.get(this.#document);\n      } else {\n        cachedItem = new Map();\n      }\n      cachedItem.set(`${selector}`, {\n        ast,\n        descendant,\n        invalidate\n      });\n      this.#documentCache.set(this.#document, cachedItem);\n      this.#descendant = descendant;\n      this.#invalidate = invalidate;\n    }\n    return [\n      ast,\n      nodes\n    ];\n  }\n\n  /**\n   * create tree walker\n   * @private\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} opt - options\n   * @param {boolean} [opt.force] - force new tree walker\n   * @param {number} [opt.whatToShow] - NodeFilter whatToShow\n   * @returns {object} - tree walker\n   */\n  _createTreeWalker(node, opt = {}) {\n    const { force = false, whatToShow = WALKER_FILTER } = opt;\n    let walker;\n    if (force) {\n      walker = this.#document.createTreeWalker(node, whatToShow);\n    } else if (this.#walkers.has(node)) {\n      walker = this.#walkers.get(node);\n    } else {\n      walker = this.#document.createTreeWalker(node, whatToShow);\n      this.#walkers.set(node, walker);\n    }\n    return walker;\n  }\n\n  /**\n   * prepare querySelector walker\n   * @private\n   * @returns {object} - tree walker\n   */\n  _prepareQuerySelectorWalker() {\n    this.#qswalker = this._createTreeWalker(this.#node);\n    return this.#qswalker;\n  }\n\n  /**\n   * collect nth child\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} [anb.selector] - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthChild(anb, node, opt) {\n    const { a, b, reverse, selector } = anb;\n    const { parentNode } = node;\n    const matched = new Set();\n    let selectorBranches;\n    if (selector) {\n      if (this.#astCache.has(selector)) {\n        selectorBranches = this.#astCache.get(selector);\n      } else {\n        const { branches } = walkAST(selector);\n        selectorBranches = branches;\n        if (!this.#invalidate) {\n          this.#astCache.set(selector, selectorBranches);\n        }\n      }\n      const { branches } = walkAST(selector);\n      selectorBranches = branches;\n    }\n    if (parentNode) {\n      const walker = this._createTreeWalker(parentNode, {\n        force: true\n      });\n      let refNode = walker.firstChild();\n      const selectorNodes = new Set();\n      let l = 0;\n      if (selectorBranches) {\n        while (refNode) {\n          if (isVisible(refNode)) {\n            let bool;\n            for (const leaves of selectorBranches) {\n              bool = this._matchLeaves(leaves, refNode, opt);\n              if (!bool) {\n                break;\n              }\n            }\n            if (bool) {\n              selectorNodes.add(refNode);\n            }\n          }\n          l++;\n          refNode = walker.nextSibling();\n        }\n      } else {\n        while (refNode) {\n          l++;\n          refNode = walker.nextSibling();\n        }\n      }\n      // :first-child, :last-child, :nth-child(b of S), :nth-last-child(b of S)\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          if (selectorNodes.size) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (selectorNodes.has(refNode)) {\n                if (i === b - 1) {\n                  matched.add(refNode);\n                  break;\n                }\n                i++;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n            }\n          } else if (!selector) {\n            refNode = traverseNode(parentNode, walker);\n            if (reverse) {\n              refNode = walker.lastChild();\n            } else {\n              refNode = walker.firstChild();\n            }\n            let i = 0;\n            while (refNode) {\n              if (i === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            }\n          }\n        }\n      // :nth-child()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let i = 0;\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            if (refNode && nth >= 0 && nth < l) {\n              if (selectorNodes.size) {\n                if (selectorNodes.has(refNode)) {\n                  if (j === nth) {\n                    matched.add(refNode);\n                    nth += a;\n                  }\n                  if (a > 0) {\n                    j++;\n                  } else {\n                    j--;\n                  }\n                }\n              } else if (i === nth) {\n                if (!selector) {\n                  matched.add(refNode);\n                }\n                nth += a;\n              }\n              if (reverse) {\n                refNode = walker.previousSibling();\n              } else {\n                refNode = walker.nextSibling();\n              }\n              i++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      if (selectorBranches) {\n        let bool;\n        for (const leaves of selectorBranches) {\n          bool = this._matchLeaves(leaves, node, opt);\n          if (bool) {\n            break;\n          }\n        }\n        if (bool) {\n          matched.add(node);\n        }\n      } else {\n        matched.add(node);\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * collect nth of type\n   * @private\n   * @param {object} anb - An+B options\n   * @param {number} anb.a - a\n   * @param {number} anb.b - b\n   * @param {boolean} [anb.reverse] - reverse order\n   * @param {object} node - Element node\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _collectNthOfType(anb, node) {\n    const { a, b, reverse } = anb;\n    const { localName, namespaceURI, parentNode, prefix } = node;\n    const matched = new Set();\n    if (parentNode) {\n      const walker = this._createTreeWalker(parentNode);\n      let refNode = traverseNode(parentNode, walker);\n      refNode = walker.firstChild();\n      let l = 0;\n      while (refNode) {\n        l++;\n        refNode = walker.nextSibling();\n      }\n      // :first-of-type, :last-of-type\n      if (a === 0) {\n        if (b > 0 && b <= l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = 0;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === b - 1) {\n                matched.add(refNode);\n                break;\n              }\n              j++;\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      // :nth-of-type()\n      } else {\n        let nth = b - 1;\n        if (a > 0) {\n          while (nth < 0) {\n            nth += a;\n          }\n        }\n        if (nth >= 0 && nth < l) {\n          refNode = traverseNode(parentNode, walker);\n          if (reverse) {\n            refNode = walker.lastChild();\n          } else {\n            refNode = walker.firstChild();\n          }\n          let j = a > 0 ? 0 : b - 1;\n          while (refNode) {\n            const {\n              localName: itemLocalName, namespaceURI: itemNamespaceURI,\n              prefix: itemPrefix\n            } = refNode;\n            if (itemLocalName === localName && itemPrefix === prefix &&\n                itemNamespaceURI === namespaceURI) {\n              if (j === nth) {\n                matched.add(refNode);\n                nth += a;\n              }\n              if (nth < 0 || nth >= l) {\n                break;\n              } else if (a > 0) {\n                j++;\n              } else {\n                j--;\n              }\n            }\n            if (reverse) {\n              refNode = walker.previousSibling();\n            } else {\n              refNode = walker.nextSibling();\n            }\n          }\n        }\n      }\n      if (reverse && matched.size > 1) {\n        const m = [...matched];\n        return new Set(m.reverse());\n      }\n    } else if (node === this.#root && (a + b) === 1) {\n      matched.add(node);\n    }\n    return matched;\n  }\n\n  /**\n   * match An+B\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {string} nthName - nth pseudo-class name\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchAnPlusB(ast, node, nthName, opt) {\n    const {\n      nth: {\n        a,\n        b,\n        name: nthIdentName\n      },\n      selector\n    } = ast;\n    const anbMap = new Map();\n    if (nthIdentName) {\n      if (nthIdentName === 'even') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 0);\n      } else if (nthIdentName === 'odd') {\n        anbMap.set('a', 2);\n        anbMap.set('b', 1);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    } else {\n      if (typeof a === 'string' && /-?\\d+/.test(a)) {\n        anbMap.set('a', a * 1);\n      } else {\n        anbMap.set('a', 0);\n      }\n      if (typeof b === 'string' && /-?\\d+/.test(b)) {\n        anbMap.set('b', b * 1);\n      } else {\n        anbMap.set('b', 0);\n      }\n      if (nthName.indexOf('last') > -1) {\n        anbMap.set('reverse', true);\n      }\n    }\n    if (nthName === 'nth-child' || nthName === 'nth-last-child') {\n      if (selector) {\n        anbMap.set('selector', selector);\n      }\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthChild(anb, node, opt);\n      return nodes;\n    } else if (nthName === 'nth-of-type' || nthName === 'nth-last-of-type') {\n      const anb = Object.fromEntries(anbMap);\n      const nodes = this._collectNthOfType(anb, node);\n      return nodes;\n    }\n    return new Set();\n  }\n\n  /**\n   * match :has() pseudo-class function\n   * @private\n   * @param {Array.<object>} astLeaves - AST leaves\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchHasPseudoFunc(astLeaves, node, opt) {\n    if (Array.isArray(astLeaves) && astLeaves.length) {\n      const leaves = [...astLeaves];\n      const [leaf] = leaves;\n      const { type: leafType } = leaf;\n      let combo;\n      if (leafType === COMBINATOR) {\n        combo = leaves.shift();\n      } else {\n        combo = {\n          name: ' ',\n          type: COMBINATOR\n        };\n      }\n      const twigLeaves = [];\n      while (leaves.length) {\n        const [item] = leaves;\n        const { type: itemType } = item;\n        if (itemType === COMBINATOR) {\n          break;\n        } else {\n          twigLeaves.push(leaves.shift());\n        }\n      }\n      const twig = {\n        combo,\n        leaves: twigLeaves\n      };\n      opt.dir = DIR_NEXT;\n      const nodes = this._matchCombinator(twig, node, opt);\n      if (nodes.size) {\n        if (leaves.length) {\n          let bool = false;\n          for (const nextNode of nodes) {\n            bool = this._matchHasPseudoFunc(leaves, nextNode, opt);\n            if (bool) {\n              break;\n            }\n          }\n          return bool;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * match logical pseudo-class functions - :has(), :is(), :not(), :where()\n   * @private\n   * @param {object} astData - AST data\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {?object} - matched node\n   */\n  _matchLogicalPseudoFunc(astData, node, opt) {\n    const { astName, branches, twigBranches } = astData;\n    const isShadowRoot = (opt.isShadowRoot || this.#shadow) &&\n      node.nodeType === DOCUMENT_FRAGMENT_NODE;\n    if (astName === 'has') {\n      let bool;\n      for (const leaves of branches) {\n        bool = this._matchHasPseudoFunc(leaves, node, opt);\n        if (bool) {\n          break;\n        }\n      }\n      if (bool) {\n        if (isShadowRoot) {\n          if (this.#verifyShadowHost) {\n            return node;\n          }\n        } else {\n          return node;\n        }\n      }\n    } else {\n      // check for invalid shadow root\n      if (isShadowRoot) {\n        let invalid;\n        for (const branch of branches) {\n          if (branch.length > 1) {\n            invalid = true;\n            break;\n          } else if (astName === 'not') {\n            const [{ type: childAstType }] = branch;\n            if (childAstType !== PS_CLASS_SELECTOR) {\n              invalid = true;\n              break;\n            }\n          }\n        }\n        if (invalid) {\n          return null;\n        }\n      }\n      opt.forgive = astName === 'is' || astName === 'where';\n      const l = twigBranches.length;\n      let bool;\n      for (let i = 0; i < l; i++) {\n        const branch = twigBranches[i];\n        const lastIndex = branch.length - 1;\n        const { leaves } = branch[lastIndex];\n        bool = this._matchLeaves(leaves, node, opt);\n        if (bool && lastIndex > 0) {\n          let nextNodes = new Set([node]);\n          for (let j = lastIndex - 1; j >= 0; j--) {\n            const twig = branch[j];\n            const arr = [];\n            opt.dir = DIR_PREV;\n            for (const nextNode of nextNodes) {\n              const m = this._matchCombinator(twig, nextNode, opt);\n              if (m.size) {\n                arr.push(...m);\n              }\n            }\n            if (arr.length) {\n              if (j === 0) {\n                bool = true;\n              } else {\n                nextNodes = new Set(arr);\n              }\n            } else {\n              bool = false;\n              break;\n            }\n          }\n        }\n        if (bool) {\n          break;\n        }\n      }\n      if (astName === 'not') {\n        if (bool) {\n          return null;\n        }\n        return node;\n      } else if (bool) {\n        return node;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * match pseudo-class selector\n   * @private\n   * @see https://html.spec.whatwg.org/#pseudo-classes\n   * @param {object} ast - AST\n   * @param {object} node - Element node\n   * @param {object} opt - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchPseudoClassSelector(ast, node, opt) {\n    const { children: astChildren, name: astName } = ast;\n    const { localName, parentNode } = node;\n    const {\n      forgive,\n      warn = this.#warn\n    } = opt;\n    const matched = new Set();\n    // :has(), :is(), :not(), :where()\n    if (Array.isArray(astChildren) && KEY_LOGICAL.includes(astName)) {\n      if (!astChildren.length && astName !== 'is' && astName !== 'where') {\n        const css = generateCSS(ast);\n        throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n      }\n      let astData;\n      if (this.#astCache.has(ast)) {\n        astData = this.#astCache.get(ast);\n      } else {\n        const { branches } = walkAST(ast);\n        if (astName === 'has') {\n          // check for nested :has()\n          let forgiven;\n          for (const child of astChildren) {\n            const item = findAST(child, leaf => {\n              if (KEY_LOGICAL.includes(leaf.name) &&\n                  findAST(leaf, nestedLeaf => nestedLeaf.name === 'has')) {\n                return leaf;\n              }\n              return null;\n            });\n            if (item) {\n              const itemName = item.name;\n              if (itemName === 'is' || itemName === 'where') {\n                forgiven = true;\n                break;\n              } else {\n                const css = generateCSS(ast);\n                throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n              }\n            }\n          }\n          if (forgiven) {\n            return matched;\n          }\n          astData = {\n            astName,\n            branches\n          };\n        } else {\n          const twigBranches = [];\n          for (const [...leaves] of branches) {\n            const branch = [];\n            const leavesSet = new Set();\n            let item = leaves.shift();\n            while (item) {\n              if (item.type === COMBINATOR) {\n                branch.push({\n                  combo: item,\n                  leaves: [...leavesSet]\n                });\n                leavesSet.clear();\n              } else if (item) {\n                leavesSet.add(item);\n              }\n              if (leaves.length) {\n                item = leaves.shift();\n              } else {\n                branch.push({\n                  combo: null,\n                  leaves: [...leavesSet]\n                });\n                leavesSet.clear();\n                break;\n              }\n            }\n            twigBranches.push(branch);\n          }\n          astData = {\n            astName,\n            branches,\n            twigBranches\n          };\n          if (!this.#invalidate) {\n            this.#astCache.set(ast, astData);\n          }\n        }\n      }\n      const res = this._matchLogicalPseudoFunc(astData, node, opt);\n      if (res) {\n        matched.add(res);\n      }\n    } else if (Array.isArray(astChildren)) {\n      // :nth-child(), :nth-last-child(), nth-of-type(), :nth-last-of-type()\n      if (/^nth-(?:last-)?(?:child|of-type)$/.test(astName)) {\n        if (astChildren.length !== 1) {\n          const css = generateCSS(ast);\n          throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n        }\n        const [branch] = astChildren;\n        const nodes = this._matchAnPlusB(branch, node, astName, opt);\n        return nodes;\n      } else {\n        switch (astName) {\n          // :dir()\n          case 'dir': {\n            if (astChildren.length !== 1) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            const [astChild] = astChildren;\n            const res = matchDirectionPseudoClass(astChild, node);\n            if (res) {\n              matched.add(node);\n            }\n            break;\n          }\n          // :lang()\n          case 'lang': {\n            if (!astChildren.length) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            let bool;\n            for (const astChild of astChildren) {\n              bool = matchLanguagePseudoClass(astChild, node);\n              if (bool) {\n                break;\n              }\n            }\n            if (bool) {\n              matched.add(node);\n            }\n            break;\n          }\n          // :state()\n          case 'state': {\n            if (isCustomElement(node)) {\n              const [{ value: stateValue }] = astChildren;\n              if (stateValue) {\n                if (node[stateValue]) {\n                  matched.add(node);\n                } else {\n                  for (const i in node) {\n                    const prop = node[i];\n                    if (prop instanceof this.#window.ElementInternals) {\n                      if (prop?.states?.has(stateValue)) {\n                        matched.add(node);\n                      }\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n            break;\n          }\n          case 'current':\n          case 'nth-col':\n          case 'nth-last-col': {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          case 'host':\n          case 'host-context': {\n            // ignore\n            break;\n          }\n          // dropped from CSS Selectors 3\n          case 'contains': {\n            if (warn) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                NOT_SUPPORTED_ERR);\n            }\n            break;\n          }\n          default: {\n            if (!forgive) {\n              throw new DOMException(`Unknown pseudo-class :${astName}()`,\n                SYNTAX_ERR);\n            }\n          }\n        }\n      }\n    } else {\n      switch (astName) {\n        case 'any-link':\n        case 'link': {\n          if ((localName === 'a' || localName === 'area') &&\n              node.hasAttribute('href')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'local-link': {\n          if ((localName === 'a' || localName === 'area') &&\n              node.hasAttribute('href')) {\n            const { href, origin, pathname } = new URL(this.#document.URL);\n            const attrURL = new URL(node.getAttribute('href'), href);\n            if (attrURL.origin === origin && attrURL.pathname === pathname) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'visited': {\n          // prevent fingerprinting\n          break;\n        }\n        case 'hover': {\n          const { target, type } = this.#event ?? {};\n          if (/^(?:click|mouse(?:down|over|up))$/.test(type) &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'active': {\n          const { buttons, target, type } = this.#event ?? {};\n          if (type === 'mousedown' && buttons & BIT_01 &&\n              node.contains(target)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target': {\n          const { hash } = new URL(this.#document.URL);\n          if (node.id && hash === `#${node.id}` &&\n              this.#document.contains(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'target-within': {\n          const { hash } = new URL(this.#document.URL);\n          if (hash) {\n            const id = hash.replace(/^#/, '');\n            let current = this.#document.getElementById(id);\n            while (current) {\n              if (current === node) {\n                matched.add(node);\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          break;\n        }\n        case 'scope': {\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (!this.#shadow && node === this.#node) {\n              matched.add(node);\n            }\n          } else if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus': {\n          if (node === this.#document.activeElement && isFocusableArea(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'focus-visible': {\n          if (node === this.#document.activeElement && isFocusableArea(node)) {\n            let bool;\n            if (isFocusVisible(node)) {\n              bool = true;\n            } else if (this.#focus) {\n              const { relatedTarget, target: focusTarget } = this.#focus;\n              if (focusTarget === node) {\n                if (isFocusVisible(relatedTarget)) {\n                  bool = true;\n                } else if (this.#event) {\n                  const {\n                    key: eventKey, target: eventTarget, type: eventType\n                  } = this.#event;\n                  // this.#event is irrelevant if eventTarget === relatedTarget\n                  if (eventTarget === relatedTarget) {\n                    if (this.#lastFocusVisible === null) {\n                      bool = true;\n                    } else if (focusTarget === this.#lastFocusVisible) {\n                      bool = true;\n                    }\n                  } else if (eventKey === 'Tab') {\n                    if ((eventType === 'keydown' && eventTarget !== node) ||\n                        (eventType === 'keyup' && eventTarget === node)) {\n                      if (eventTarget === focusTarget) {\n                        if (this.#lastFocusVisible === null) {\n                          bool = true;\n                        } else if (eventTarget === this.#lastFocusVisible &&\n                                   relatedTarget === null) {\n                          bool = true;\n                        }\n                      } else {\n                        bool = true;\n                      }\n                    }\n                  } else if (eventKey) {\n                    if ((eventType === 'keydown' || eventType === 'keyup') &&\n                        eventTarget === node) {\n                      bool = true;\n                    }\n                  }\n                } else if (relatedTarget === null ||\n                           relatedTarget === this.#lastFocusVisible) {\n                  bool = true;\n                }\n              }\n            }\n            if (bool) {\n              this.#lastFocusVisible = node;\n              matched.add(node);\n            } else if (this.#lastFocusVisible === node) {\n              this.#lastFocusVisible = null;\n            }\n          }\n          break;\n        }\n        case 'focus-within': {\n          let bool;\n          let current = this.#document.activeElement;\n          if (isFocusableArea(current)) {\n            while (current) {\n              if (current === node) {\n                bool = true;\n                break;\n              }\n              current = current.parentNode;\n            }\n          }\n          if (bool) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'open':\n        case 'closed': {\n          if (localName === 'details' || localName === 'dialog') {\n            if (node.hasAttribute('open')) {\n              if (astName === 'open') {\n                matched.add(node);\n              }\n            } else if (astName === 'closed') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'disabled':\n        case 'enabled': {\n          const keys = [...KEY_FORM_FOCUS, 'fieldset', 'optgroup', 'option'];\n          if (keys.includes(localName) ||\n              isCustomElement(node, { formAssociated: true })) {\n            let disabled;\n            if (node.disabled || node.hasAttribute('disabled')) {\n              disabled = true;\n            } else if (node.localName === 'option') {\n              if (parentNode.localName === 'optgroup' &&\n                  (parentNode.disabled ||\n                   parentNode.hasAttribute('disabled'))) {\n                disabled = true;\n              }\n            } else if (node.localName !== 'optgroup') {\n              let parent = parentNode;\n              while (parent) {\n                if (parent.localName === 'fieldset' &&\n                    (parent.disabled || parent.hasAttribute('disabled'))) {\n                  let refNode = parent.firstElementChild;\n                  while (refNode) {\n                    if (refNode.localName === 'legend') {\n                      break;\n                    }\n                    refNode = refNode.nextElementSibling;\n                  }\n                  if (refNode) {\n                    if (!refNode.contains(node)) {\n                      disabled = true;\n                    }\n                  } else {\n                    disabled = true;\n                  }\n                  break;\n                } else if (parent.localName === 'form') {\n                  break;\n                } else if (parent.parentNode?.nodeType === ELEMENT_NODE) {\n                  if (parent.parentNode.localName === 'form') {\n                    break;\n                  } else {\n                    parent = parent.parentNode;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n            if (disabled) {\n              if (astName === 'disabled') {\n                matched.add(node);\n              }\n            } else if (astName === 'enabled') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'read-only':\n        case 'read-write': {\n          let readonly;\n          let writable;\n          switch (localName) {\n            case 'textarea': {\n              if (node.readonly || node.hasAttribute('readonly') ||\n                  node.disabled || node.hasAttribute('disabled')) {\n                readonly = true;\n              } else {\n                writable = true;\n              }\n              break;\n            }\n            case 'input': {\n              if (!node.type || KEY_INPUT_EDIT.includes(node.type)) {\n                if (node.readonly || node.hasAttribute('readonly') ||\n                    node.disabled || node.hasAttribute('disabled')) {\n                  readonly = true;\n                } else {\n                  writable = true;\n                }\n              }\n              break;\n            }\n            default: {\n              if (isContentEditable(node)) {\n                writable = true;\n              } else {\n                readonly = true;\n              }\n            }\n          }\n          if (readonly) {\n            if (astName === 'read-only') {\n              matched.add(node);\n            }\n          } else if (astName === 'read-write' && writable) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'placeholder-shown': {\n          let placeholder;\n          if (node.placeholder) {\n            placeholder = node.placeholder;\n          } else if (node.hasAttribute('placeholder')) {\n            placeholder = node.getAttribute('placeholder');\n          }\n          if (typeof placeholder === 'string' && !/[\\r\\n]/.test(placeholder)) {\n            let targetNode;\n            if (localName === 'textarea') {\n              targetNode = node;\n            } else if (localName === 'input') {\n              if (node.hasAttribute('type')) {\n                const keys = [...KEY_INPUT_TEXT, 'number'];\n                if (keys.includes(node.getAttribute('type'))) {\n                  targetNode = node;\n                }\n              } else {\n                targetNode = node;\n              }\n            }\n            if (targetNode && node.value === '') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'checked': {\n          const attrType = node.getAttribute('type');\n          if ((node.checked && localName === 'input' &&\n               (attrType === 'checkbox' || attrType === 'radio')) ||\n              (node.selected && localName === 'option')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'indeterminate': {\n          if ((node.indeterminate && localName === 'input' &&\n               node.type === 'checkbox') ||\n              (localName === 'progress' && !node.hasAttribute('value'))) {\n            matched.add(node);\n          } else if (localName === 'input' && node.type === 'radio' &&\n                     !node.hasAttribute('checked')) {\n            const nodeName = node.name;\n            let parent = node.parentNode;\n            while (parent) {\n              if (parent.localName === 'form') {\n                break;\n              }\n              parent = parent.parentNode;\n            }\n            if (!parent) {\n              parent = this.#document.documentElement;\n            }\n            const walker = this._createTreeWalker(parent);\n            let refNode = traverseNode(parent, walker);\n            refNode = walker.firstChild();\n            let checked;\n            while (refNode) {\n              if (refNode.localName === 'input' &&\n                  refNode.getAttribute('type') === 'radio') {\n                if (refNode.hasAttribute('name')) {\n                  if (refNode.getAttribute('name') === nodeName) {\n                    checked = !!refNode.checked;\n                  }\n                } else {\n                  checked = !!refNode.checked;\n                }\n                if (checked) {\n                  break;\n                }\n              }\n              refNode = walker.nextNode();\n            }\n            if (!checked) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'default': {\n          // button[type=\"submit\"], input[type=\"submit\"], input[type=\"image\"]\n          const chekcKeys = ['checkbox', 'radio'];\n          const resetKeys = ['button', 'reset'];\n          const submitKeys = ['image', 'submit'];\n          const attrType = node.getAttribute('type');\n          if ((localName === 'button' &&\n               !(node.hasAttribute('type') && resetKeys.includes(attrType))) ||\n              (localName === 'input' && node.hasAttribute('type') &&\n               submitKeys.includes(attrType))) {\n            let form = node.parentNode;\n            while (form) {\n              if (form.localName === 'form') {\n                break;\n              }\n              form = form.parentNode;\n            }\n            if (form) {\n              const walker = this._createTreeWalker(form);\n              let refNode = traverseNode(form, walker);\n              refNode = walker.firstChild();\n              while (refNode) {\n                const nodeName = refNode.localName;\n                const nodeAttrType = refNode.getAttribute('type');\n                let m;\n                if (nodeName === 'button') {\n                  m = !(refNode.hasAttribute('type') &&\n                    resetKeys.includes(nodeAttrType));\n                } else if (nodeName === 'input') {\n                  m = refNode.hasAttribute('type') &&\n                    submitKeys.includes(nodeAttrType);\n                }\n                if (m) {\n                  if (refNode === node) {\n                    matched.add(node);\n                  }\n                  break;\n                }\n                refNode = walker.nextNode();\n              }\n            }\n          // input[type=\"checkbox\"], input[type=\"radio\"]\n          } else if (localName === 'input' && node.hasAttribute('type') &&\n                     chekcKeys.includes(attrType) &&\n                     node.hasAttribute('checked')) {\n            matched.add(node);\n          // option\n          } else if (localName === 'option' && node.hasAttribute('selected')) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'valid':\n        case 'invalid': {\n          const keys = [...KEY_FORM_FOCUS, 'form'];\n          if (keys.includes(localName)) {\n            let valid;\n            if (node.checkValidity()) {\n              if (node.maxLength >= 0) {\n                if (node.maxLength >= node.value.length) {\n                  valid = true;\n                }\n              } else {\n                valid = true;\n              }\n            }\n            if (valid) {\n              if (astName === 'valid') {\n                matched.add(node);\n              }\n            } else if (astName === 'invalid') {\n              matched.add(node);\n            }\n          } else if (localName === 'fieldset') {\n            const walker = this._createTreeWalker(node);\n            let refNode = traverseNode(node, walker);\n            refNode = walker.firstChild();\n            let valid;\n            if (!refNode) {\n              valid = true;\n            } else {\n              while (refNode) {\n                if (keys.includes(refNode.localName)) {\n                  if (refNode.checkValidity()) {\n                    if (refNode.maxLength >= 0) {\n                      valid = refNode.maxLength >= refNode.value.length;\n                    } else {\n                      valid = true;\n                    }\n                  } else {\n                    valid = false;\n                  }\n                  if (!valid) {\n                    break;\n                  }\n                }\n                refNode = walker.nextNode();\n              }\n            }\n            if (valid) {\n              if (astName === 'valid') {\n                matched.add(node);\n              }\n            } else if (astName === 'invalid') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'in-range':\n        case 'out-of-range': {\n          const keys = [...KEY_INPUT_DATE, 'number', 'range'];\n          const attrType = node.getAttribute('type');\n          if (localName === 'input' &&\n              !(node.readonly || node.hasAttribute('readonly')) &&\n              !(node.disabled || node.hasAttribute('disabled')) &&\n              keys.includes(attrType)) {\n            const flowed =\n              node.validity.rangeUnderflow || node.validity.rangeOverflow;\n            if (astName === 'out-of-range' && flowed) {\n              matched.add(node);\n            } else if (astName === 'in-range' && !flowed &&\n                       (node.hasAttribute('min') || node.hasAttribute('max') ||\n                       attrType === 'range')) {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'required':\n        case 'optional': {\n          let targetNode;\n          if (localName === 'select' || localName === 'textarea') {\n            targetNode = node;\n          } else if (localName === 'input') {\n            if (node.hasAttribute('type')) {\n              const keys = [...KEY_INPUT_EDIT, 'checkbox', 'file', 'radio'];\n              const attrType = node.getAttribute('type');\n              if (keys.includes(attrType)) {\n                targetNode = node;\n              }\n            } else {\n              targetNode = node;\n            }\n          }\n          if (targetNode) {\n            if (node.required || node.hasAttribute('required')) {\n              if (astName === 'required') {\n                matched.add(node);\n              }\n            } else if (astName === 'optional') {\n              matched.add(node);\n            }\n          }\n          break;\n        }\n        case 'root': {\n          if (node === this.#document.documentElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'empty': {\n          if (node.hasChildNodes()) {\n            const walker = this._createTreeWalker(node, {\n              force: true,\n              whatToShow: SHOW_ALL\n            });\n            let refNode = walker.firstChild();\n            let bool;\n            while (refNode) {\n              bool = refNode.nodeType !== ELEMENT_NODE &&\n                refNode.nodeType !== TEXT_NODE;\n              if (!bool) {\n                break;\n              }\n              refNode = walker.nextSibling();\n            }\n            if (bool) {\n              matched.add(node);\n            }\n          } else {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-child': {\n          if ((parentNode && node === parentNode.firstElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-child': {\n          if ((parentNode && node === parentNode.lastElementChild) ||\n              node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-child': {\n          if ((parentNode && node === parentNode.firstElementChild &&\n               node === parentNode.lastElementChild) || node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'first-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'last-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1,\n              reverse: true\n            }, node);\n            if (node1) {\n              matched.add(node1);\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'only-of-type': {\n          if (parentNode) {\n            const [node1] = this._collectNthOfType({\n              a: 0,\n              b: 1\n            }, node);\n            if (node1 === node) {\n              const [node2] = this._collectNthOfType({\n                a: 0,\n                b: 1,\n                reverse: true\n              }, node);\n              if (node2 === node) {\n                matched.add(node);\n              }\n            }\n          } else if (node === this.#root) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'defined': {\n          if (node.hasAttribute('is') || localName.includes('-')) {\n            if (isCustomElement(node)) {\n              matched.add(node);\n            }\n          // NOTE: MathMLElement not implemented in jsdom\n          } else if (node instanceof this.#window.HTMLElement ||\n                     node instanceof this.#window.SVGElement) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'popover-open': {\n          if (node.popover && isVisible(node)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case 'host':\n        case 'host-context': {\n          // ignore\n          break;\n        }\n        // legacy pseudo-elements\n        case 'after':\n        case 'before':\n        case 'first-letter':\n        case 'first-line': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-element ::${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        // not supported\n        case 'autofill':\n        case 'blank':\n        case 'buffering':\n        case 'current':\n        case 'fullscreen':\n        case 'future':\n        case 'modal':\n        case 'muted':\n        case 'past':\n        case 'paused':\n        case 'picture-in-picture':\n        case 'playing':\n        case 'seeking':\n        case 'stalled':\n        case 'user-invalid':\n        case 'user-valid':\n        case 'volume-locked':\n        case '-webkit-autofill': {\n          if (warn) {\n            throw new DOMException(`Unsupported pseudo-class :${astName}`,\n              NOT_SUPPORTED_ERR);\n          }\n          break;\n        }\n        default: {\n          if (astName.startsWith('-webkit-')) {\n            if (warn) {\n              throw new DOMException(`Unsupported pseudo-class :${astName}`,\n                NOT_SUPPORTED_ERR);\n            }\n          } else if (!forgive) {\n            throw new DOMException(`Unknown pseudo-class :${astName}`,\n              SYNTAX_ERR);\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match shadow host pseudo class\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - DocumentFragment node\n   * @returns {?object} - matched node\n   */\n  _matchShadowHostPseudoClass(ast, node) {\n    const { children: astChildren, name: astName } = ast;\n    if (Array.isArray(astChildren)) {\n      if (astChildren.length !== 1) {\n        const css = generateCSS(ast);\n        throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n      }\n      const { branches } = walkAST(astChildren[0]);\n      const [branch] = branches;\n      const [...leaves] = branch;\n      const { host } = node;\n      if (astName === 'host') {\n        let bool;\n        for (const leaf of leaves) {\n          const { type: leafType } = leaf;\n          if (leafType === COMBINATOR) {\n            const css = generateCSS(ast);\n            throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n          }\n          bool = this._matchSelector(leaf, host).has(host);\n          if (!bool) {\n            break;\n          }\n        }\n        if (bool) {\n          return node;\n        }\n        return null;\n      } else if (astName === 'host-context') {\n        let parent = host;\n        let bool;\n        while (parent) {\n          for (const leaf of leaves) {\n            const { type: leafType } = leaf;\n            if (leafType === COMBINATOR) {\n              const css = generateCSS(ast);\n              throw new DOMException(`Invalid selector ${css}`, SYNTAX_ERR);\n            }\n            bool = this._matchSelector(leaf, parent).has(parent);\n            if (!bool) {\n              break;\n            }\n          }\n          if (bool) {\n            break;\n          } else {\n            parent = parent.parentNode;\n          }\n        }\n        if (bool) {\n          return node;\n        }\n        return null;\n      }\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    } else if (astName === 'host') {\n      return node;\n    } else {\n      throw new DOMException(`Invalid selector :${astName}`, SYNTAX_ERR);\n    }\n  }\n\n  /**\n   * match selector\n   * @private\n   * @param {object} ast - AST\n   * @param {object} node - Document, DocumentFragment, Element node\n   * @param {object} [opt] - options\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchSelector(ast, node, opt = {}) {\n    const { type: astType } = ast;\n    const astName = unescapeSelector(ast.name);\n    const matched = new Set();\n    if (node.nodeType === ELEMENT_NODE) {\n      switch (astType) {\n        case ATTR_SELECTOR: {\n          const res = matchAttributeSelector(ast, node);\n          if (res) {\n            matched.add(node);\n          }\n          break;\n        }\n        case ID_SELECTOR: {\n          if (node.id === astName) {\n            matched.add(node);\n          }\n          break;\n        }\n        case CLASS_SELECTOR: {\n          if (node.classList.contains(astName)) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_CLASS_SELECTOR: {\n          const nodes = this._matchPseudoClassSelector(ast, node, opt);\n          return nodes;\n        }\n        case TYPE_SELECTOR: {\n          const res = matchTypeSelector(ast, node, opt);\n          if (res) {\n            matched.add(node);\n          }\n          break;\n        }\n        case PS_ELEMENT_SELECTOR:\n        default: {\n          matchPseudoElementSelector(astName, astType, opt);\n        }\n      }\n    } else if (this.#shadow && astType === PS_CLASS_SELECTOR &&\n               node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      if (KEY_LOGICAL.includes(astName)) {\n        opt.isShadowRoot = true;\n        const nodes = this._matchPseudoClassSelector(ast, node, opt);\n        return nodes;\n      } else if (astName === 'host' || astName === 'host-context') {\n        const res = this._matchShadowHostPseudoClass(ast, node, opt);\n        if (res) {\n          this.#verifyShadowHost = true;\n          matched.add(res);\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * match leaves\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node\n   * @param {object} opt - options\n   * @returns {boolean} - result\n   */\n  _matchLeaves(leaves, node, opt) {\n    let result;\n    if (this.#invalidate) {\n      result = this.#invalidateResults.get(leaves);\n    } else {\n      result = this.#results.get(leaves);\n    }\n    if (result && result.has(node)) {\n      const { matched } = result.get(node);\n      return matched;\n    } else {\n      let cacheable = true;\n      const formKeys = [...KEY_FORM_FOCUS, 'fieldset', 'form'];\n      const pseudoKeys = ['any-link', 'defined', 'dir', 'link'];\n      if (node.nodeType === ELEMENT_NODE && formKeys.includes(node.localName)) {\n        cacheable = false;\n      }\n      let bool;\n      for (const leaf of leaves) {\n        switch (leaf.type) {\n          case ATTR_SELECTOR:\n          case ID_SELECTOR: {\n            cacheable = false;\n            break;\n          }\n          case PS_CLASS_SELECTOR: {\n            if (pseudoKeys.includes(leaf.name)) {\n              cacheable = false;\n            }\n            break;\n          }\n          default:\n        }\n        bool = this._matchSelector(leaf, node, opt).has(node);\n        if (!bool) {\n          break;\n        }\n      }\n      if (cacheable) {\n        if (!result) {\n          result = new WeakMap();\n        }\n        result.set(node, {\n          matched: bool\n        });\n        if (this.#invalidate) {\n          this.#invalidateResults.set(leaves, result);\n        } else {\n          this.#results.set(leaves, result);\n        }\n      }\n      return bool;\n    }\n  }\n\n  /**\n   * find descendant nodes\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} baseNode - base Element node or Element.shadowRoot\n   * @param {object} opt - options\n   * @returns {object} - collection of nodes and pending state\n   */\n  _findDescendantNodes(leaves, baseNode, opt) {\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { type: leafType } = leaf;\n    const leafName = unescapeSelector(leaf.name);\n    const nodes = new Set();\n    let pending = false;\n    if (this.#shadow || baseNode.nodeType !== ELEMENT_NODE) {\n      pending = true;\n    } else {\n      switch (leafType) {\n        case PS_ELEMENT_SELECTOR: {\n          matchPseudoElementSelector(leafName, leafType, opt);\n          break;\n        }\n        case ID_SELECTOR: {\n          if (this.#root.nodeType === ELEMENT_NODE) {\n            pending = true;\n          } else {\n            const node = this.#root.getElementById(leafName);\n            if (node && node !== baseNode && baseNode.contains(node)) {\n              if (compound) {\n                const bool = this._matchLeaves(filterLeaves, node, opt);\n                if (bool) {\n                  nodes.add(node);\n                }\n              } else {\n                nodes.add(node);\n              }\n            }\n          }\n          break;\n        }\n        default: {\n          pending = true;\n        }\n      }\n    }\n    if (pending) {\n      const walker = this._createTreeWalker(baseNode);\n      let refNode = traverseNode(baseNode, walker);\n      refNode = walker.firstChild();\n      while (refNode) {\n        const bool = this._matchLeaves(leaves, refNode, opt);\n        if (bool) {\n          nodes.add(refNode);\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * match combinator\n   * @private\n   * @param {object} twig - twig\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  _matchCombinator(twig, node, opt) {\n    const { combo, leaves } = twig;\n    const { name: comboName } = combo;\n    const { parentNode } = node;\n    const { dir } = opt;\n    const matched = new Set();\n    if (dir === DIR_NEXT) {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.nextElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            let refNode = node.nextElementSibling;\n            while (refNode) {\n              const bool = this._matchLeaves(leaves, refNode, opt);\n              if (bool) {\n                matched.add(refNode);\n              }\n              refNode = refNode.nextElementSibling;\n            }\n          }\n          break;\n        }\n        case '>': {\n          let refNode = node.firstElementChild;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n            refNode = refNode.nextElementSibling;\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const nodes = this._findDescendantNodes(leaves, node, opt);\n          if (nodes.size) {\n            return nodes;\n          }\n        }\n      }\n    } else {\n      switch (comboName) {\n        case '+': {\n          const refNode = node.previousElementSibling;\n          if (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              matched.add(refNode);\n            }\n          }\n          break;\n        }\n        case '~': {\n          if (parentNode) {\n            let refNode = parentNode.firstElementChild;\n            while (refNode) {\n              if (refNode === node) {\n                break;\n              } else {\n                const bool = this._matchLeaves(leaves, refNode, opt);\n                if (bool) {\n                  matched.add(refNode);\n                }\n              }\n              refNode = refNode.nextElementSibling;\n            }\n          }\n          break;\n        }\n        case '>': {\n          if (parentNode) {\n            const bool = this._matchLeaves(leaves, parentNode, opt);\n            if (bool) {\n              matched.add(parentNode);\n            }\n          }\n          break;\n        }\n        case ' ':\n        default: {\n          const arr = [];\n          let refNode = parentNode;\n          while (refNode) {\n            const bool = this._matchLeaves(leaves, refNode, opt);\n            if (bool) {\n              arr.push(refNode);\n            }\n            refNode = refNode.parentNode;\n          }\n          if (arr.length) {\n            return new Set(arr.reverse());\n          }\n        }\n      }\n    }\n    return matched;\n  }\n\n  /**\n   * find matched node(s) from #qswalker\n   * @private\n   * @param {Array.<object>} leaves - AST leaves\n   * @param {object} node - node to start from\n   * @param {object} opt - options\n   * @param {boolean} [opt.force] - traverse only to next node\n   * @param {string} [opt.targetType] - target type\n   * @returns {?object|Array.<object>} - matched node / collection of nodes\n   */\n  _findWalker(leaves, node, opt = {}) {\n    const { force, targetType } = opt;\n    const walker = this.#qswalker;\n    const nodes = [];\n    let refNode = traverseNode(node, walker, !!force);\n    if (refNode) {\n      if (refNode.nodeType !== ELEMENT_NODE) {\n        refNode = walker.nextNode();\n      } else if (refNode === node) {\n        if (refNode !== this.#root) {\n          refNode = walker.nextNode();\n        }\n      }\n      while (refNode) {\n        const matched = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (matched) {\n          nodes.push(refNode);\n          if (targetType !== TARGET_ALL) {\n            break;\n          }\n        }\n        refNode = walker.nextNode();\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * match self\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @returns {Array} - [nodes, filtered]\n   */\n  _matchSelf(leaves) {\n    const nodes = [];\n    let filtered = false;\n    const bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find lineal\n   * @private\n   * @param {Array} leaves - AST leaves\n   * @param {object} opt - options\n   * @returns {Array} - [nodes, filtered]\n   */\n  _findLineal(leaves, opt) {\n    const { complex } = opt;\n    const nodes = [];\n    let filtered = false;\n    let bool = this._matchLeaves(leaves, this.#node, {\n      warn: this.#warn\n    });\n    if (bool) {\n      nodes.push(this.#node);\n      filtered = true;\n    }\n    if (!bool || complex) {\n      let refNode = this.#node.parentNode;\n      while (refNode) {\n        bool = this._matchLeaves(leaves, refNode, {\n          warn: this.#warn\n        });\n        if (bool) {\n          nodes.push(refNode);\n          filtered = true;\n        }\n        if (refNode.parentNode) {\n          refNode = refNode.parentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    return [nodes, filtered];\n  }\n\n  /**\n   * find entry nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {string} targetType - target type\n   * @param {boolean} complex - complex selector\n   * @returns {object} - collection of nodes etc.\n   */\n  _findEntryNodes(twig, targetType, complex) {\n    const { leaves } = twig;\n    const [leaf, ...filterLeaves] = leaves;\n    const compound = filterLeaves.length > 0;\n    const { name: leafName, type: leafType } = leaf;\n    let nodes = [];\n    let filtered = false;\n    let pending = false;\n    switch (leafType) {\n      case PS_ELEMENT_SELECTOR: {\n        matchPseudoElementSelector(leafName, leafType, {\n          warn: this.#warn\n        });\n        break;\n      }\n      case ID_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST &&\n                   this.#root.nodeType !== ELEMENT_NODE) {\n          const node = this.#root.getElementById(leafName);\n          if (node) {\n            if (compound) {\n              const bool = this._matchLeaves(filterLeaves, node, {\n                warn: this.#warn\n              });\n              if (bool) {\n                nodes.push(node);\n                filtered = true;\n              }\n            } else {\n              nodes.push(node);\n              filtered = true;\n            }\n          }\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType,\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case CLASS_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      case TYPE_SELECTOR: {\n        if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        }\n        break;\n      }\n      default: {\n        if (targetType !== TARGET_LINEAL &&\n            (leafName === 'host' || leafName === 'host-context')) {\n          let shadowRoot;\n          if (this.#shadow &&\n              this.#node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            shadowRoot = this._matchShadowHostPseudoClass(leaf, this.#node);\n          } else if (compound && this.#node.nodeType === ELEMENT_NODE) {\n            shadowRoot =\n              this._matchShadowHostPseudoClass(leaf, this.#node.shadowRoot);\n          }\n          if (shadowRoot) {\n            let bool;\n            if (compound) {\n              for (const item of filterLeaves) {\n                if (/^host(?:-context)?$/.test(item.name)) {\n                  const node =\n                    this._matchShadowHostPseudoClass(item, shadowRoot);\n                  bool = node === shadowRoot;\n                } else if (item.name === 'has') {\n                  bool = this._matchPseudoClassSelector(item, shadowRoot, {})\n                    .has(shadowRoot);\n                } else {\n                  bool = false;\n                }\n                if (!bool) {\n                  break;\n                }\n              }\n            } else {\n              bool = true;\n            }\n            if (bool) {\n              nodes.push(shadowRoot);\n              filtered = true;\n            }\n          }\n        } else if (targetType === TARGET_SELF) {\n          [nodes, filtered] = this._matchSelf(leaves);\n        } else if (targetType === TARGET_LINEAL) {\n          [nodes, filtered] = this._findLineal(leaves, {\n            complex\n          });\n        } else if (targetType === TARGET_FIRST) {\n          nodes = this._findWalker(leaves, this.#node, {\n            targetType\n          });\n          if (nodes.length) {\n            filtered = true;\n          }\n        } else {\n          pending = true;\n        }\n      }\n    }\n    return {\n      compound,\n      filtered,\n      nodes,\n      pending\n    };\n  }\n\n  /**\n   * collect nodes\n   * @private\n   * @param {string} targetType - target type\n   * @returns {Array.<Array.<object|undefined>>} - #ast and #nodes\n   */\n  _collectNodes(targetType) {\n    const ast = this.#ast.values();\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      const pendingItems = new Set();\n      let i = 0;\n      for (const { branch } of ast) {\n        const branchLen = branch.length;\n        const complex = branchLen > 1;\n        const firstTwig = branch[0];\n        let dir;\n        let twig;\n        if (complex) {\n          const {\n            combo: firstCombo,\n            leaves: [{\n              name: firstName,\n              type: firstType\n            }]\n          } = firstTwig;\n          const lastTwig = branch[branchLen - 1];\n          const {\n            leaves: [{\n              name: lastName,\n              type: lastType\n            }]\n          } = lastTwig;\n          dir = DIR_NEXT;\n          twig = firstTwig;\n          if (this.#selector.includes(':scope') ||\n              lastType === PS_ELEMENT_SELECTOR || lastType === ID_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (firstName === '*' && firstType === TYPE_SELECTOR) {\n            dir = DIR_PREV;\n            twig = lastTwig;\n          } else if (lastName === '*' && lastType === TYPE_SELECTOR) {\n            dir = DIR_NEXT;\n            twig = firstTwig;\n          } else if (branchLen === 2) {\n            const { name: comboName } = firstCombo;\n            if (comboName === '+' || comboName === '~') {\n              dir = DIR_PREV;\n              twig = lastTwig;\n            }\n          }\n        } else {\n          dir = DIR_PREV;\n          twig = firstTwig;\n        }\n        const {\n          compound, filtered, nodes, pending\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        } else if (pending) {\n          pendingItems.add(new Map([\n            ['index', i],\n            ['twig', twig]\n          ]));\n        }\n        this.#ast[i].dir = dir;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n      if (pendingItems.size) {\n        let node;\n        let walker;\n        if (this.#node !== this.#root && this.#node.nodeType === ELEMENT_NODE) {\n          node = this.#node;\n          walker = this.#qswalker;\n        } else {\n          node = this.#root;\n          walker = this._createTreeWalker(node);\n        }\n        let nextNode = traverseNode(node, walker);\n        while (nextNode) {\n          let bool = false;\n          if (this.#node.nodeType === ELEMENT_NODE) {\n            if (nextNode === this.#node) {\n              bool = true;\n            } else {\n              bool = this.#node.contains(nextNode);\n            }\n          } else {\n            bool = true;\n          }\n          if (bool) {\n            for (const pendingItem of pendingItems) {\n              const { leaves } = pendingItem.get('twig');\n              const matched = this._matchLeaves(leaves, nextNode, {\n                warn: this.#warn\n              });\n              if (matched) {\n                const index = pendingItem.get('index');\n                this.#ast[index].filtered = true;\n                this.#ast[index].find = true;\n                this.#nodes[index].push(nextNode);\n              }\n            }\n          }\n          if (nextNode !== walker.currentNode) {\n            nextNode = traverseNode(nextNode, walker);\n          }\n          nextNode = walker.nextNode();\n        }\n      }\n    } else {\n      let i = 0;\n      for (const { branch } of ast) {\n        const twig = branch[branch.length - 1];\n        const complex = branch.length > 1;\n        const {\n          compound, filtered, nodes\n        } = this._findEntryNodes(twig, targetType, complex);\n        if (nodes.length) {\n          this.#ast[i].find = true;\n          this.#nodes[i] = nodes;\n        }\n        this.#ast[i].dir = DIR_PREV;\n        this.#ast[i].filtered = filtered || !compound;\n        i++;\n      }\n    }\n    return [\n      this.#ast,\n      this.#nodes\n    ];\n  }\n\n  /**\n   * get combined nodes\n   * @private\n   * @param {object} twig - twig\n   * @param {object} nodes - collection of nodes\n   * @param {string} dir - direction\n   * @returns {Array.<object>} - collection of matched nodes\n   */\n  _getCombinedNodes(twig, nodes, dir) {\n    const arr = [];\n    for (const node of nodes) {\n      const matched = this._matchCombinator(twig, node, {\n        dir,\n        warn: this.#warn\n      });\n      if (matched.size) {\n        arr.push(...matched);\n      }\n    }\n    if (arr.length) {\n      return new Set(arr);\n    }\n    return new Set();\n  }\n\n  /**\n   * match node to next direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {Set.<object>} nodes - collection of Element node\n   * @param {object} opt - option\n   * @param {object} opt.combo - combo\n   * @returns {?object} - matched node\n   */\n  _matchNodeNext(branch, nodes, opt) {\n    const { combo, index } = opt;\n    const { combo: nextCombo, leaves } = branch[index];\n    const twig = {\n      combo,\n      leaves\n    };\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_NEXT);\n    if (nextNodes.size) {\n      if (index === branch.length - 1) {\n        const [nextNode] = sortNodes(nextNodes);\n        return nextNode;\n      } else {\n        return this._matchNodeNext(branch, nextNodes, {\n          combo: nextCombo,\n          index: index + 1\n        });\n      }\n    }\n    return null;\n  }\n\n  /**\n   * match node to previous direction\n   * @private\n   * @param {Array} branch - branch\n   * @param {object} node - Element node\n   * @param {object} opt - option\n   * @param {number} opt.index - index\n   * @returns {?object} - node\n   */\n  _matchNodePrev(branch, node, opt) {\n    const { index } = opt;\n    const twig = branch[index];\n    const nodes = new Set([node]);\n    const nextNodes = this._getCombinedNodes(twig, nodes, DIR_PREV);\n    if (nextNodes.size) {\n      if (index === 0) {\n        return node;\n      } else {\n        let matched;\n        for (const nextNode of nextNodes) {\n          matched = this._matchNodePrev(branch, nextNode, {\n            index: index - 1\n          });\n          if (matched) {\n            break;\n          }\n        }\n        if (matched) {\n          return node;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * find matched nodes\n   * @param {string} targetType - target type\n   * @returns {Set.<object>} - collection of matched nodes\n   */\n  find(targetType) {\n    if (targetType === TARGET_ALL || targetType === TARGET_FIRST) {\n      this._prepareQuerySelectorWalker();\n    }\n    const [[...branches], collectedNodes] = this._collectNodes(targetType);\n    const l = branches.length;\n    let sort;\n    let nodes = new Set();\n    for (let i = 0; i < l; i++) {\n      const { branch, dir, find } = branches[i];\n      const branchLen = branch.length;\n      if (branchLen && find) {\n        const entryNodes = collectedNodes[i];\n        const entryNodesLen = entryNodes.length;\n        const lastIndex = branchLen - 1;\n        if (lastIndex === 0) {\n          if ((targetType === TARGET_ALL || targetType === TARGET_FIRST) &&\n              this.#node.nodeType === ELEMENT_NODE) {\n            for (let j = 0; j < entryNodesLen; j++) {\n              const node = entryNodes[j];\n              if (node !== this.#node && this.#node.contains(node)) {\n                nodes.add(node);\n                if (targetType === TARGET_FIRST) {\n                  break;\n                }\n              }\n            }\n          } else if (targetType === TARGET_ALL) {\n            if (nodes.size) {\n              const n = [...nodes];\n              nodes = new Set([...n, ...entryNodes]);\n              sort = true;\n            } else {\n              nodes = new Set(entryNodes);\n            }\n          } else {\n            const [node] = entryNodes;\n            nodes.add(node);\n          }\n        } else if (targetType === TARGET_ALL) {\n          if (dir === DIR_NEXT) {\n            const { combo: firstCombo } = branch[0];\n            let combo = firstCombo;\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = 1; j < branchLen; j++) {\n                const { combo: nextCombo, leaves } = branch[j];\n                const twig = {\n                  combo,\n                  leaves\n                };\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === lastIndex) {\n                    if (nodes.size) {\n                      const n = [...nodes];\n                      nodes = new Set([...n, ...nextNodes]);\n                      sort = true;\n                      combo = firstCombo;\n                    } else {\n                      nodes = nextNodes;\n                      combo = firstCombo;\n                    }\n                  } else {\n                    combo = nextCombo;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          } else {\n            for (const node of entryNodes) {\n              let nextNodes = new Set([node]);\n              for (let j = lastIndex - 1; j >= 0; j--) {\n                const twig = branch[j];\n                nextNodes = this._getCombinedNodes(twig, nextNodes, dir);\n                if (nextNodes.size) {\n                  if (j === 0) {\n                    nodes.add(node);\n                    if (branchLen > 1 && nodes.size > 1) {\n                      sort = true;\n                    }\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        } else if (targetType === TARGET_FIRST && dir === DIR_NEXT) {\n          const { combo: entryCombo } = branch[0];\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodeNext(branch, new Set([node]), {\n              combo: entryCombo,\n              index: 1\n            });\n            if (matched) {\n              nodes.add(matched);\n              break;\n            }\n          }\n          if (!matched) {\n            const { leaves: entryLeaves } = branch[0];\n            const [entryNode] = entryNodes;\n            let [refNode] =\n              this._findWalker(entryLeaves, entryNode, {\n                targetType\n              });\n            while (refNode) {\n              matched = this._matchNodeNext(branch, new Set([refNode]), {\n                combo: entryCombo,\n                index: 1\n              });\n              if (matched) {\n                nodes.add(matched);\n                break;\n              }\n              [refNode] = this._findWalker(entryLeaves, refNode, {\n                targetType,\n                force: true\n              });\n            }\n          }\n        } else {\n          let matched;\n          for (const node of entryNodes) {\n            matched = this._matchNodePrev(branch, node, {\n              index: lastIndex - 1\n            });\n            if (matched) {\n              nodes.add(node);\n              break;\n            }\n          }\n          if (!matched && targetType === TARGET_FIRST) {\n            const { leaves: entryLeaves } = branch[lastIndex];\n            const [entryNode] = entryNodes;\n            let [refNode] = this._findWalker(entryLeaves, entryNode, {\n              targetType\n            });\n            while (refNode) {\n              matched = this._matchNodePrev(branch, refNode, {\n                index: lastIndex - 1\n              });\n              if (matched) {\n                nodes.add(refNode);\n                break;\n              }\n              [refNode] = this._findWalker(entryLeaves, refNode, {\n                targetType,\n                force: true\n              });\n            }\n          }\n        }\n      }\n    }\n    if (targetType === TARGET_FIRST) {\n      nodes.delete(this.#node);\n      if (nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    } else if (targetType === TARGET_ALL) {\n      nodes.delete(this.#node);\n      if (sort && nodes.size > 1) {\n        nodes = new Set(sortNodes(nodes));\n      }\n    }\n    return nodes;\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_base64", "__commonJSMin", "exports", "intToCharMap", "number", "charCode", "bigA", "bigZ", "littleA", "littleZ", "zero", "nine", "plus", "slash", "littleOffset", "numberOffset", "require_base64_vlq", "__commonJSMin", "exports", "base64", "VLQ_BASE_SHIFT", "VLQ_BASE", "VLQ_BASE_MASK", "VLQ_CONTINUATION_BIT", "toVLQSigned", "aValue", "fromVLQSigned", "isNegative", "shifted", "encoded", "digit", "vlq", "aStr", "aIndex", "aOutParam", "strLen", "result", "shift", "continuation", "require_util", "__commonJSMin", "exports", "getArg", "aArgs", "aName", "aDefaultValue", "urlRegexp", "dataUrlRegexp", "urlParse", "aUrl", "match", "urlGenerate", "aParsedUrl", "url", "MAX_CACHED_INPUTS", "lruMemoize", "f", "cache", "input", "i", "temp", "result", "normalize", "aPath", "path", "isAbsolute", "parts", "start", "part", "up", "join", "aRoot", "aPathUrl", "aRootUrl", "joined", "relative", "level", "index", "supportsNullProto", "obj", "identity", "s", "toSetString", "aStr", "isProtoString", "fromSetString", "length", "compareByOriginalPositions", "mappingA", "mappingB", "onlyCompareOriginal", "cmp", "strcmp", "compareByOriginalPositionsNoSource", "compareByGeneratedPositionsDeflated", "onlyCompareGenerated", "compareByGeneratedPositionsDeflatedNoLine", "aStr1", "aStr2", "compareByGeneratedPositionsInflated", "parseSourceMapInput", "str", "computeSourceURL", "sourceRoot", "sourceURL", "sourceMapURL", "parsed", "require_array_set", "__commonJSMin", "exports", "util", "has", "hasNativeMap", "ArraySet", "aArray", "aAllowDuplicates", "set", "len", "aStr", "sStr", "isDuplicate", "idx", "aIdx", "require_mapping_list", "__commonJSMin", "exports", "util", "generatedPositionAfter", "mappingA", "mappingB", "lineA", "lineB", "columnA", "columnB", "MappingList", "aCallback", "aThisArg", "aMapping", "require_source_map_generator", "__commonJSMin", "exports", "base64VLQ", "util", "ArraySet", "MappingList", "SourceMapGenerator", "aArgs", "aSourceMapConsumer", "generatorOps", "sourceRoot", "generator", "mapping", "newMapping", "sourceFile", "sourceRelative", "content", "generated", "original", "source", "name", "aSourceFile", "aSourceContent", "aSourceMapPath", "newSources", "newNames", "aGenerated", "aOriginal", "aSource", "aName", "message", "previousGeneratedColumn", "previousGeneratedLine", "previousOriginalColumn", "previousOriginalLine", "previousName", "previousSource", "result", "next", "nameIdx", "sourceIdx", "mappings", "i", "len", "aSources", "aSourceRoot", "key", "map", "require_nwsapi", "__commonJSMin", "exports", "module", "global", "factory", "Export", "version", "doc", "root", "slice", "createMatchingParensRegex", "depth", "out", "CFG", "NOT", "REX", "STD", "GROUPS", "Patterns", "qsNotArgs", "qsInvalid", "reNthElem", "reNthType", "reOptimizer", "reValidator", "Config", "NAMESPACE", "QUIRKS_MODE", "HTML_DOCUMENT", "ATTR_STD_OPS", "HTML_TABLE", "Combinators", "Selectors", "Operators", "concatCall", "nodes", "callback", "i", "l", "list", "concatList", "hasDupes", "documentOrder", "a", "b", "unique", "j", "hasMixedCaseTagNames", "context", "api", "ns", "isHTML", "node", "codePointToUTF16", "codePoint", "lowHex", "stringFromCodePoint", "convertEscapes", "str", "substring", "p1", "p2", "unescapeIdentifier", "none", "matchLambdas", "selectLambdas", "matchResolvers", "selectResolvers", "method", "byIdRaw", "id", "next", "byId", "e", "byTag", "tag", "byClass", "cls", "reCls", "compat", "c", "n", "f", "hasAttributeNS", "name", "attr", "nthElement", "idx", "len", "set", "parent", "parents", "element", "dir", "k", "nthOfType", "nsURI", "isTarget", "hash", "isIndeterminate", "nodeName", "items", "checked", "item", "isContentEditable", "attrValue", "setIdentifierSyntax", "nonascii", "esctoken", "identifier", "pseudonames", "pseudoparms", "attrparser", "attrvalues", "attributes", "attrmatcher", "pseudoclass", "standardValidator", "configure", "option", "clear", "emit", "message", "proto", "err", "Snapshot", "lastContext", "switchContext", "force", "oldDoc", "lastMatched", "lastSelected", "F_INIT", "S_HEAD", "M_HEAD", "S_LOOP", "N_LOOP", "M_LOOP", "S_BODY", "N_BODY", "M_BODY", "S_TAIL", "M_TAIL", "S_TEST", "N_TEST", "M_TEST", "S_VARS", "M_VARS", "compileSelector", "expression", "source", "mode", "NS", "N", "D", "expr", "match", "result", "status", "symbol", "test", "type", "selector", "vars", "selectorString", "selectorRecursion", "compile", "head", "loop", "macro", "optimize", "token", "index", "length", "collect", "selectors", "seen", "optimized", "htmlset", "nodeset", "results", "makeref", "matchAssert", "r", "matchCollect", "expressions", "parsed", "ancestor", "select", "resolver", "h", "first", "require_bidi", "__commonJSMin", "exports", "module", "global", "factory", "bidiFactory", "bidi", "DATA", "TYPES", "TYPES_TO_NAMES", "type", "i", "ISOLATE_INIT_TYPES", "STRONG_TYPES", "NEUTRAL_ISOLATE_TYPES", "BN_LIKE_TYPES", "TRAILING_TYPES", "map", "parseData", "loop", "lastCode", "range", "ref", "skip", "step", "getBidiCharType", "char", "getBidiCharTypeName", "data$1", "parseCharacterMap", "encodedString", "includeReverse", "radix", "reverseMap", "prevPair", "visit", "entry", "a", "b", "openToClose", "closeToOpen", "canonical", "parse$1", "openingToClosingBracket", "closingToOpeningBracket", "getCanonicalBracket", "TYPE_L", "TYPE_R", "TYPE_EN", "TYPE_ES", "TYPE_ET", "TYPE_AN", "TYPE_CS", "TYPE_B", "TYPE_S", "TYPE_ON", "TYPE_BN", "TYPE_NSM", "TYPE_AL", "TYPE_LRO", "TYPE_RLO", "TYPE_LRE", "TYPE_RLE", "TYPE_PDF", "TYPE_LRI", "TYPE_RLI", "TYPE_FSI", "TYPE_PDI", "getEmbeddingLevels", "string", "baseDirection", "MAX_DEPTH", "charTypes", "charTypeCounts", "changeCharType", "oldType", "embedLevels", "isolationPairs", "paragraphs", "paragraph", "i$1", "determineAutoEmbedLevel", "FORMATTING_TYPES", "nextEven", "n", "nextOdd", "paraIdx", "statusStack", "stackTop", "overflowIsolateCount", "overflowEmbeddingCount", "validIsolateCount", "i$2", "charType", "level", "level$1", "level$2", "isolInitIndex", "levelRuns", "currentRun", "i$3", "charType$1", "lvl", "isIsolInit", "isPDI", "isolatingRunSeqs", "runIdx", "run", "seqRuns", "pdiIndex", "i$4", "seqIndices", "i$5", "run$1", "j", "firstLevel", "prevLevel", "i$6", "lastIndex", "lastLevel", "nextLevel", "i$7", "seqIdx", "seqIndices$1", "sosType", "eosType", "embedDirection", "si", "i$8", "prevType", "sj", "si$1", "i$9", "sj$1", "prevCharType", "si$2", "i$10", "si$3", "i$11", "prevType$1", "nextType", "sj$2", "sj$3", "si$4", "i$12", "sj$4", "si$5", "i$13", "sj$5", "sj$6", "si$6", "prevStrongType", "i$14", "R_TYPES_FOR_N_STEPS", "STRONG_TYPES_FOR_N_STEPS", "bracketPairs", "openerStack", "si$7", "oppositeBracket", "stackIdx", "stackChar", "pairIdx", "ref$1", "openSeqIdx", "closeSeqIdx", "foundStrongType", "useStrongType", "si$8", "i$15", "lr", "si$9", "i$16", "lr$1", "si$10", "si$11", "si$12", "niRunStart", "niRunEnd", "prevType$2", "si2", "nextType$1", "si2$1", "sj$7", "i$17", "level$3", "type$1", "j$1", "start", "isFSI", "pdi", "indexOfMatchingPDI", "isolateStart", "isolationLevel", "data", "mirrorMap", "parse", "value", "key", "getMirroredCharacter", "getMirroredCharactersMap", "embeddingLevels", "end", "strLen", "mirror", "getReorderSegments", "embeddingLevelsResult", "segments", "lineStart", "lineEnd", "lineLevels", "maxLevel", "minOddLevel", "segStart", "getReorderedString", "embedLevelsResult", "indices", "getReorderedIndices", "chars", "charIndex", "slice", "require_is_potential_custom_element_name", "__commonJSMin", "exports", "module", "regex", "isPotentialCustomElementName", "string", "src_exports", "__export", "DOMSelector", "__toCommonJS", "isDigit", "code", "isHexDigit", "isUppercaseLetter", "isLowercaseLetter", "isLetter", "isNonAscii", "isNameStart", "isName", "isNonPrintable", "isNewline", "isWhiteSpace", "isValidEscape", "first", "second", "isIdentifierStart", "third", "isNumberStart", "isBOM", "CATEGORY", "EofCategory", "WhiteSpaceCategory", "DigitCategory", "NameStartCategory", "NonPrintableCategory", "i", "charCodeCategory", "getCharCode", "source", "offset", "getNewlineLength", "code", "cmpChar", "testStr", "referenceCode", "isUppercaseLetter", "cmpStr", "start", "end", "referenceStr", "testCode", "findWhiteSpaceStart", "isWhiteSpace", "findWhiteSpaceEnd", "findDecimalNumberEnd", "isDigit", "consumeEscaped", "isHexDigit", "maxOffset", "consumeName", "isName", "isValidEscape", "consumeNumber", "sign", "consumeBadUrlRemnants", "decodeEscaped", "escaped", "names_default", "adoptBuffer", "buffer", "size", "N", "F", "R", "computeLinesAndColumns", "host", "source", "sourceLength", "startOffset", "isBOM", "lines", "adoptBuffer", "columns", "line", "column", "i", "code", "OffsetToLocation", "startLine", "startColumn", "offset", "filename", "start", "end", "OFFSET_MASK", "TYPE_SHIFT", "balancePair", "isBlockOpenerToken", "tokenType", "TokenStream", "source", "tokenize", "sourceLength", "offsetAndType", "adoptBuffer", "balance", "tokenCount", "firstCharOffset", "balanceCloseType", "balanceStart", "type", "start", "end", "index", "prevBalanceStart", "i", "balanceEnd", "offset", "idx", "referenceStr", "cmpStr", "tokenIndex", "pos", "code", "next", "startToken", "stopConsume", "cursor", "loop", "fn", "item", "tokens", "names_default", "tokenize", "source", "onToken", "getCharCode", "offset", "sourceLength", "consumeNumericToken", "consumeNumber", "isIdentifierStart", "type", "consumeName", "consumeIdentLikeToken", "nameStartOffset", "cmpStr", "findWhiteSpaceEnd", "consumeUrlToken", "consumeStringToken", "endingCodePoint", "code", "charCodeCategory", "WhiteSpaceCategory", "isNewline", "getNewlineLength", "nextCode", "isValidEscape", "consumeEscaped", "consumeBadUrlRemnants", "NonPrintableCategory", "start", "isBOM", "isName", "isNumberStart", "DigitCategory", "NameStartCategory", "releasedCursors", "List", "_List", "data", "prev", "next", "cursor", "prevOld", "prevNew", "nextOld", "nextNew", "size", "array", "item", "fn", "thisArg", "initialValue", "acc", "result", "start", "before", "list", "oldItem", "newItemOrList", "createCustomError", "name", "message", "error", "errorStack", "MAX_LINE_LENGTH", "OFFSET_CORRECTION", "TAB_REPLACEMENT", "sourceFragment", "source", "line", "column", "baseLine", "baseColumn", "extraLines", "processLines", "start", "end", "lines", "idx", "maxNumLength", "prelines", "precolumns", "startLine", "endLine", "cutLeft", "i", "SyntaxError", "message", "offset", "createCustomError", "readSequence", "recognizer", "children", "space", "context", "child", "NOOP", "EXCLAMATIONMARK", "NUMBERSIGN", "SEMICOLON", "LEFTCURLYBRACKET", "NULL", "createParseContext", "name", "fetchParseValues", "dict", "result", "item", "fn", "processConfig", "config", "parseConfig", "context", "createParser", "source", "filename", "needPositions", "onParseError", "onParseErrorThrow", "locationMap", "OffsetToLocation", "parser", "TokenStream", "readSequence", "code", "List", "node", "list", "consumer", "fallback", "startIndex", "e", "fallbackNode", "offset", "type", "offsetStart", "offsetEnd", "start", "charCode", "cmpChar", "str", "cmpStr", "tokenType", "number", "consumeNumber", "tokenName", "names_default", "message", "end", "head", "tail", "location", "findWhiteSpaceStart", "SyntaxError", "source_", "options", "tokenize", "onComment", "loc", "value", "ast", "import_source_map_generator", "trackNodes", "generateSourceMap", "handlers", "map", "generated", "original", "activatedGenerated", "activatedMapping", "line", "column", "sourceMappingActive", "origHandlersNode", "node", "nodeLine", "nodeColumn", "origHandlersEmit", "value", "type", "auto", "i", "origHandlersResult", "token_before_exports", "__export", "safe", "spec", "PLUSSIGN", "HYPHENMINUS", "code", "type", "value", "charCode", "specPairs", "safePairs", "createMap", "pairs", "isWhiteSpaceRequired", "prev", "next", "prevCode", "nextCode", "nextCharCode", "spec", "safe", "REVERSESOLIDUS", "processChildren", "node", "delimeter", "prev", "processChunk", "chunk", "tokenize", "type", "start", "end", "createGenerator", "config", "types", "name", "item", "options", "buffer", "prevCode", "handlers", "publicApi", "safe", "value", "generateSourceMap", "token_before_exports", "createConvertor", "walk", "ast", "node", "List", "hasOwnProperty", "noop", "ensureFunction", "value", "invokeForType", "fn", "type", "node", "item", "list", "getWalkersFromStructure", "name", "nodeType", "structure", "walkers", "key", "fieldTypes", "walker", "fieldType", "getTypesFromConfig", "config", "types", "createTypeIterator", "reverse", "fields", "contextName", "useContext", "context", "walk", "walkReducer", "prevContextValue", "field", "ref", "createFastTraveralMap", "StyleSheet", "Atrule", "Rule", "Block", "DeclarationList", "createWalker", "iteratorsNatural", "iteratorsReverse", "breakWalk", "skipNode", "fastTraversalIteratorsNatural", "fastTraversalIteratorsReverse", "root", "options", "walkNode", "enterRet", "enter", "iterators", "leave", "ret", "data", "ast", "found", "noop", "value", "generateMultiplier", "multiplier", "min", "max", "comma", "generateTypeOpts", "node", "generateSequence", "decorate", "forceBraces", "compact", "combinator", "result", "term", "internalGenerate", "generate", "options", "defaultLoc", "locateMismatch", "matchResult", "node", "tokens", "longestMatch", "mismatchNode", "badNode", "mismatchOffset", "mismatchLength", "entries", "css", "start", "end", "i", "token", "fromLoc", "buildLoc", "point", "value", "offset", "line", "column", "extra", "loc", "lines", "SyntaxReferenceError", "type", "referenceName", "error", "createCustomError", "SyntaxMatchError", "message", "syntax", "generate", "keywords", "properties", "HYPHENMINUS", "keyword", "getKeywordDescriptor", "property", "getPropertyDescriptor", "isCustomProperty", "str", "offset", "HYPHENMINUS", "getVendorPrefix", "secondDashIndex", "getKeywordDescriptor", "keyword", "keywords", "name", "descriptor", "custom", "vendor", "getPropertyDescriptor", "property", "properties", "hack", "prefix", "cssWideKeywords", "PLUSSIGN", "HYPHENMINUS", "N", "DISALLOW_SIGN", "ALLOW_SIGN", "isDelim", "token", "code", "skipSC", "offset", "getNextToken", "checkInteger", "valueOffset", "disallowSign", "isDigit", "consumeB", "offset_", "sign", "anPlusB", "cmpChar", "i", "PLUSSIGN", "HYPHENMINUS", "QUESTIONMARK", "U", "isDelim", "token", "code", "startsWith", "hexSequence", "offset", "allowDash", "hexlen", "pos", "isHexDigit", "withQuestionMarkSequence", "consumed", "length", "getNextToken", "urange", "cmpChar", "consumedHexLength", "calcFunctionNames", "balancePair", "charCodeAt", "str", "index", "eqStr", "actual", "expected", "cmpStr", "eqStrAny", "i", "isPostfixIeHack", "offset", "isDigit", "outOfRange", "opts", "value", "numEnd", "num", "consumeFunction", "token", "getNextToken", "balanceCloseType", "balanceStash", "length", "scan", "calc", "next", "tokenType", "expectedTokenType", "customIdent", "name", "cssWideKeywords", "dashedIdent", "customPropertyName", "hexColor", "isHexDigit", "idSelector", "isIdentifierStart", "declarationValue", "anyValue", "dimension", "type", "numberEnd", "consumeNumber", "reverseSolidusOffset", "unit", "percentage", "zero", "number", "integer", "tokenTypes", "productionTypes", "anPlusB", "urange", "createDemensionTypes", "units", "angle", "decibel", "frequency", "flex", "length", "resolution", "semitones", "time", "calc", "dimension", "zero", "createGenericTypes", "tokenTypes", "productionTypes", "units_exports", "__export", "angle", "decibel", "flex", "frequency", "length", "resolution", "semitones", "time", "SyntaxError", "message", "input", "offset", "createCustomError", "TAB", "N", "F", "R", "SPACE", "NAME_CHAR", "_", "idx", "Scanner", "str", "pos", "code", "end", "message", "SyntaxError", "TAB", "N", "F", "R", "SPACE", "EXCLAMATIONMARK", "NUMBERSIGN", "AMPERSAND", "APOSTROPHE", "LEFTPARENTHESIS", "RIGHTPARENTHESIS", "ASTERISK", "PLUSSIGN", "COMMA", "HYPERMINUS", "LESSTHANSIGN", "GREATERTHANSIGN", "QUESTIONMARK", "COMMERCIALAT", "LEFTSQUAREBRACKET", "RIGHTSQUAREBRACKET", "LEFTCURLYBRACKET", "VERTICALLINE", "RIGHTCURLYBRACKET", "INFINITY", "COMBINATOR_PRECEDENCE", "readMultiplierRange", "scanner", "min", "max", "readMultiplier", "range", "comma", "maybeMultiplied", "node", "multiplier", "maybeToken", "ch", "readProperty", "name", "readTypeRange", "sign", "readType", "opts", "implicitGroup", "readImplicitGroup", "readKeywordOrFunction", "regroupTerms", "terms", "combinators", "createGroup", "combinator", "a", "b", "subgroupStart", "term", "stopCharCode", "token", "prevToken", "prevTokenPos", "peek", "readGroup", "result", "code", "parse", "source", "Scanner", "noop", "ensureFunction", "value", "walk", "node", "options", "context", "enter", "leave", "astToTokens", "handlers", "tokens", "curNode", "node", "tmp", "value", "type", "auto", "stringToTokens", "str", "tokenize", "start", "end", "prepare_tokens_default", "syntax", "MATCH", "MISMATCH", "DISALLOW_EMPTY", "LEFTPARENTHESIS", "RIGHTPARENTHESIS", "createCondition", "match", "thenBranch", "elseBranch", "isFunctionType", "name", "isEnumCapatible", "term", "groupNode", "terms", "combinator", "explicit", "replaceTypeInGraph", "node", "replacements", "visited", "buildGroupMatchGraph", "atLeastOneTermMatched", "result", "map", "i", "key", "thenClause", "newGroupTerm", "buildMultiplierMatchGraph", "matchTerm", "buildMatchGraphInternal", "matchNode", "booleanGroup", "buildMatchGraph", "syntaxTree", "ref", "parse", "hasOwnProperty", "STUB", "TOKEN", "OPEN_SYNTAX", "CLOSE_SYNTAX", "EXIT_REASON_MATCH", "EXIT_REASON_MISMATCH", "EXIT_REASON_ITERATION_LIMIT", "ITERATION_LIMIT", "totalIterationCount", "reverseList", "list", "prev", "next", "item", "areStringsEqualCaseInsensitive", "testStr", "referenceStr", "i", "referenceCode", "testCode", "isContextEdgeDelim", "token", "isCommaContextStart", "isCommaContextEnd", "internalMatch", "tokens", "state", "syntaxes", "moveToNextToken", "tokenIndex", "getNextToken", "offset", "nextIndex", "stateSnapshotFromSyntax", "nextState", "matchStack", "syntaxStack", "thenStack", "pushThenStack", "pushElseStack", "elseStack", "addTokenToMatch", "syntaxStash", "longestMatch", "openSyntax", "closeSyntax", "iterationCount", "exitReason", "MISMATCH", "DISALLOW_EMPTY", "MATCH", "terms", "matchFlag", "name", "opts", "lastTokenIndex", "syntaxDict", "dictSyntax", "keywordName", "string", "matchAsTree", "tokens", "matchGraph", "syntaxes", "matchResult", "internalMatch", "item", "host", "hostStack", "reverseList", "OPEN_SYNTAX", "CLOSE_SYNTAX", "trace_exports", "__export", "getTrace", "isKeyword", "isProperty", "isType", "node", "shouldPutToTrace", "syntax", "hasMatch", "matchNode", "i", "result", "type", "testNode", "match", "property", "fn", "trace", "getFirstMatchNode", "matchNode", "getLastMatchNode", "matchFragments", "lexer", "ast", "match", "type", "name", "findFragments", "start", "end", "node", "item", "list", "nodes", "List", "fragments", "hasOwnProperty", "isValidNumber", "value", "isValidLocation", "loc", "createNodeStructureChecker", "type", "fields", "node", "warn", "key", "valid", "i", "fieldType", "List", "genTypesList", "fieldTypes", "path", "docsTypes", "processStructure", "name", "nodeType", "structure", "docs", "getStructureFromConfig", "config", "dumpMapSyntax", "map", "compact", "syntaxAsAst", "result", "name", "generate", "dumpAtruleMapSyntax", "atrule", "valueHasVar", "tokens", "i", "syntaxHasTopLevelCommaMultiplier", "syntax", "singleTerm", "buildMatchResult", "matched", "error", "iterations", "trace_exports", "matchSyntax", "lexer", "value", "useCssWideKeywords", "prepare_tokens_default", "matchAsTree", "SyntaxMatchError", "Lexer", "config", "structure", "cssWideKeywords", "units_exports", "getStructureFromConfig", "group", "type", "createGenericTypes", "property", "buildMatchGraph", "ast", "collectWarning", "node", "message", "warns", "parent", "ref", "descriptor", "parse", "descName", "atruleName", "SyntaxReferenceError", "prelude", "descriptorName", "keyword", "propertyName", "typeName", "typeSyntax", "matchFragments", "declaration", "fallbackBasename", "syntaxRef", "isType", "validate", "broken", "walk", "brokenMap", "brokenTypes", "brokenProperties", "errors", "key", "brokenTypesArray", "brokenPropertiesArray", "pretty", "appendOrSet", "a", "b", "sliceProps", "obj", "props", "result", "key", "value", "prop", "mix", "dest", "src", "name", "patch", "atrule", "exists", "current", "descriptorName", "descriptorValue", "syntax", "createSyntax", "config", "parse", "createParser", "walk", "createWalker", "generate", "createGenerator", "fromPlainObject", "toPlainObject", "createConvertor", "syntax", "Lexer", "tokenize", "extension", "base", "mix", "create_default", "import_module", "import_module", "import_meta", "require", "patch", "data_patch_default", "import_meta", "require", "mdnAtrules", "mdnProperties", "mdnSyntaxes", "hasOwn", "object", "property", "extendSyntax", "preprocessAtrules", "dict", "result", "atruleName", "atrule", "descriptors", "name", "descriptor", "patchDictionary", "patchDict", "key", "value", "preprocessPatchAtrulesDescritors", "declarations", "patchAtrules", "atrulePatch", "data_default", "data_patch_default", "node_exports", "__export", "AnPlusB_exports", "Atrule_exports", "AtrulePrelude_exports", "AttributeSelector_exports", "Block_exports", "Brackets_exports", "CDC_exports", "CDO_exports", "ClassSelector_exports", "Combinator_exports", "Comment_exports", "Condition_exports", "Declaration_exports", "DeclarationList_exports", "Dimension_exports", "Feature_exports", "FeatureFunction_exports", "FeatureRange_exports", "Function_exports", "GeneralEnclosed_exports", "Hash_exports", "IdSelector_exports", "Identifier_exports", "Layer_exports", "LayerList_exports", "MediaQuery_exports", "MediaQueryList_exports", "NestingSelector_exports", "Nth_exports", "Number_exports", "Operator_exports", "Parentheses_exports", "Percentage_exports", "PseudoClassSelector_exports", "PseudoElementSelector_exports", "Ratio_exports", "Raw_exports", "Rule_exports", "Scope_exports", "Selector_exports", "SelectorList_exports", "String_exports", "StyleSheet_exports", "SupportsDeclaration_exports", "TypeSelector_exports", "UnicodeRange_exports", "Url_exports", "Value_exports", "WhiteSpace_exports", "AnPlusB_exports", "__export", "generate", "name", "parse", "structure", "PLUSSIGN", "HYPHENMINUS", "N", "DISALLOW_SIGN", "ALLOW_SIGN", "checkInteger", "offset", "disallowSign", "pos", "code", "isDigit", "checkTokenIsInteger", "expectCharCode", "msg", "consumeB", "sign", "type", "name", "structure", "parse", "start", "a", "b", "i", "generate", "node", "Atrule_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "consumeRaw", "isDeclarationBlockAtrule", "offset", "type", "name", "walkContext", "structure", "parse", "isDeclaration", "start", "nameLowerCase", "prelude", "block", "generate", "node", "AtrulePrelude_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "name", "walkContext", "structure", "parse", "children", "generate", "node", "AttributeSelector_exports", "__export", "generate", "name", "parse", "structure", "DOLLARSIGN", "ASTERISK", "EQUALSSIGN", "CIRCUMFLEXACCENT", "VERTICALLINE", "TILDE", "getAttributeName", "start", "expectIdent", "getOperator", "code", "name", "structure", "parse", "matcher", "value", "flags", "generate", "node", "Block_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "AMPERSAND", "consumeRaw", "consumeRule", "consumeRawDeclaration", "consumeDeclaration", "node", "name", "walkContext", "structure", "parse", "isStyleBlock", "consumer", "start", "children", "scan", "generate", "prev", "Brackets_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "readSequence", "recognizer", "start", "children", "generate", "node", "CDC_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "generate", "CDO_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "generate", "ClassSelector_exports", "__export", "generate", "name", "parse", "structure", "FULLSTOP", "name", "structure", "parse", "generate", "node", "Combinator_exports", "__export", "generate", "name", "parse", "structure", "PLUSSIGN", "SOLIDUS", "GREATERTHANSIGN", "TILDE", "name", "structure", "parse", "start", "generate", "node", "Comment_exports", "__export", "generate", "name", "parse", "structure", "ASTERISK", "SOLIDUS", "name", "structure", "parse", "start", "end", "generate", "node", "Condition_exports", "__export", "generate", "name", "parse", "structure", "likelyFeatureToken", "name", "structure", "featureOrRange", "kind", "parentheses", "parse", "children", "scan", "term", "res", "generate", "node", "child", "Declaration_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "EXCLAMATIONMARK", "NUMBERSIGN", "DOLLARSIGN", "AMPERSAND", "ASTERISK", "PLUSSIGN", "SOLIDUS", "consumeValueRaw", "consumeCustomPropertyRaw", "consumeValue", "startValueToken", "value", "name", "walkContext", "structure", "parse", "start", "startToken", "property", "readProperty", "customProperty", "isCustomProperty", "parseValue", "consumeRaw", "important", "valueStart", "offset", "getImportant", "generate", "node", "DeclarationList_exports", "__export", "generate", "name", "parse", "structure", "AMPERSAND", "consumeRaw", "name", "structure", "parse", "children", "generate", "node", "prev", "Dimension_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "value", "generate", "node", "Feature_exports", "__export", "generate", "name", "parse", "structure", "SOLIDUS", "name", "structure", "parse", "kind", "start", "value", "res", "generate", "node", "FeatureFunction_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "getFeatureParser", "kind", "parser", "parse", "start", "functionName", "valueParser", "value", "startValueToken", "generate", "node", "FeatureRange_exports", "__export", "generate", "name", "parse", "structure", "SOLIDUS", "LESSTHANSIGN", "EQUALSSIGN", "GREATERTHANSIGN", "name", "structure", "readTerm", "res", "readComparison", "expectColon", "value", "parse", "kind", "start", "left", "leftComparison", "middle", "rightComparison", "right", "generate", "node", "Function_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "name", "walkContext", "structure", "parse", "readSequence", "recognizer", "start", "nameLowerCase", "children", "generate", "node", "GeneralEnclosed_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "kind", "start", "functionName", "children", "startValueToken", "generate", "node", "Hash_exports", "__export", "generate", "name", "parse", "structure", "xxx", "xxx", "name", "structure", "parse", "start", "generate", "node", "Identifier_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "generate", "node", "IdSelector_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "generate", "node", "Layer_exports", "__export", "generate", "name", "parse", "structure", "FULLSTOP", "name", "structure", "parse", "tokenStart", "generate", "node", "LayerList_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "children", "generate", "node", "MediaQuery_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "modifier", "mediaType", "condition", "ident", "identLowerCase", "generate", "node", "MediaQueryList_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "children", "generate", "node", "NestingSelector_exports", "__export", "generate", "name", "parse", "structure", "AMPERSAND", "name", "structure", "parse", "start", "generate", "Nth_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "end", "selector", "nth", "generate", "node", "Number_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "generate", "node", "Operator_exports", "__export", "generate", "name", "parse", "structure", "start", "node", "Parentheses_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "readSequence", "recognizer", "start", "children", "generate", "node", "Percentage_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "generate", "node", "PseudoClassSelector_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "name", "walkContext", "structure", "parse", "start", "children", "nameLowerCase", "generate", "node", "PseudoElementSelector_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "name", "walkContext", "structure", "parse", "start", "children", "nameLowerCase", "generate", "node", "Ratio_exports", "__export", "generate", "name", "parse", "structure", "SOLIDUS", "consumeTerm", "name", "structure", "parse", "start", "left", "right", "generate", "node", "Raw_exports", "__export", "generate", "name", "parse", "structure", "getOffsetExcludeWS", "name", "structure", "parse", "consumeUntil", "excludeWhiteSpace", "startOffset", "endOffset", "generate", "node", "Rule_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "consumeRaw", "consumePrelude", "prelude", "name", "walkContext", "structure", "parse", "startToken", "startOffset", "block", "generate", "node", "Scope_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "root", "limit", "startOffset", "generate", "node", "Selector_exports", "__export", "generate", "name", "parse", "structure", "children", "node", "SelectorList_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "name", "walkContext", "structure", "parse", "children", "generate", "node", "String_exports", "__export", "generate", "name", "parse", "structure", "REVERSE_SOLIDUS", "QUOTATION_MARK", "APOSTROPHE", "decode", "str", "len", "firstChar", "start", "end", "decoded", "i", "code", "isValidEscape", "escapeStart", "escapeEnd", "consumeEscaped", "decodeEscaped", "encode", "apostrophe", "quote", "quoteCode", "encoded", "wsBeforeHexIsNeeded", "isHexDigit", "isWhiteSpace", "name", "structure", "parse", "decode", "generate", "node", "encode", "StyleSheet_exports", "__export", "generate", "name", "parse", "structure", "walkContext", "EXCLAMATIONMARK", "consumeRaw", "name", "walkContext", "structure", "parse", "start", "children", "child", "generate", "node", "SupportsDeclaration_exports", "__export", "generate", "name", "parse", "structure", "name", "structure", "parse", "start", "declaration", "generate", "node", "TypeSelector_exports", "__export", "generate", "name", "parse", "structure", "ASTERISK", "VERTICALLINE", "eatIdentifierOrAsterisk", "name", "structure", "parse", "start", "generate", "node", "UnicodeRange_exports", "__export", "generate", "name", "parse", "structure", "PLUSSIGN", "HYPHENMINUS", "QUESTIONMARK", "eatHexSequence", "offset", "allowDash", "len", "pos", "code", "isHexDigit", "eatQuestionMarkSequence", "max", "count", "startsWith", "scanUnicodeRange", "hexLength", "name", "structure", "parse", "start", "generate", "node", "Url_exports", "__export", "generate", "name", "parse", "structure", "SPACE", "REVERSE_SOLIDUS", "QUOTATION_MARK", "APOSTROPHE", "LEFTPARENTHESIS", "RIGHTPARENTHESIS", "decode", "str", "len", "start", "end", "decoded", "isWhiteSpace", "i", "code", "isValidEscape", "escapeStart", "escapeEnd", "consumeEscaped", "decodeEscaped", "encode", "encoded", "wsBeforeHexIsNeeded", "isHexDigit", "name", "structure", "parse", "start", "value", "decode", "generate", "node", "encode", "Value_exports", "__export", "generate", "name", "parse", "structure", "start", "children", "node", "WhiteSpace_exports", "__export", "generate", "name", "parse", "structure", "SPACE", "name", "structure", "parse", "generate", "node", "lexer_default", "cssWideKeywords", "data_default", "node_exports", "scope_exports", "__export", "atrulePrelude_default", "selector_default", "value_default", "NUMBERSIGN", "ASTERISK", "PLUSSIGN", "HYPHENMINUS", "SOLIDUS", "U", "defaultRecognizer", "context", "code", "atrulePrelude_default", "defaultRecognizer", "NUMBERSIGN", "AMPERSAND", "ASTERISK", "PLUSSIGN", "SOLIDUS", "FULLSTOP", "GREATERTHANSIGN", "VERTICALLINE", "TILDE", "onWhiteSpace", "next", "children", "getNode", "selector_default", "expression_default", "var_default", "children", "startIndex", "value", "offset", "isPlusMinusOperator", "node", "value_default", "defaultRecognizer", "next", "children", "expression_default", "var_default", "nonContainerNameKeywords", "container_default", "children", "name", "nested", "font_face_default", "parseWithFallback", "parse", "fallback", "parseFunctions", "children", "node", "import_default", "layer_default", "media_default", "nested", "nest_default", "page_default", "scope_default", "nested", "starting_style_default", "nested", "supports_default", "nested", "atrule_default", "container_default", "font_face_default", "import_default", "layer_default", "media_default", "nest_default", "page_default", "scope_default", "starting_style_default", "supports_default", "parseLanguageRangeList", "children", "loop", "selectorList", "selector", "identList", "langList", "parseLanguageRangeList", "nth", "pseudo_default", "index_parse_exports", "__export", "parse", "parser_default", "options", "scope_exports", "atrule_default", "pseudo_default", "index_parse_exports", "walker_default", "node_exports", "syntax_default", "create_default", "lexer_default", "parser_default", "walker_default", "import_module", "import_meta", "require", "version", "tokenize", "parse", "generate", "lexer", "createLexer", "walk", "find", "findLast", "findAll", "toPlainObject", "fromPlainObject", "fork", "syntax_default", "import_nwsapi", "import_bidi_js", "import_is_potential_custom_element_name", "ATTR_SELECTOR", "CLASS_SELECTOR", "COMBINATOR", "IDENT", "ID_SELECTOR", "NOT_SUPPORTED_ERR", "NTH", "PS_CLASS_SELECTOR", "PS_ELEMENT_SELECTOR", "SELECTOR", "STRING", "SYNTAX_ERR", "TARGET_ALL", "TARGET_FIRST", "TARGET_LINEAL", "TARGET_SELF", "TYPE_SELECTOR", "ALPHA_NUM", "CHILD_IDX", "DIGIT", "LANG_PART", "PSEUDO_CLASS", "ANB", "N_TH", "SUB_TYPE", "SUB_TYPE_WO_PSEUDO", "TAG_ID_CLASS", "TAG_TYPE", "TAG_TYPE_I", "COMPOUND", "COMPOUND_WO_PSEUDO", "COMBO", "COMPLEX", "DESCEND", "NESTED_LOGIC_A", "NESTED_LOGIC_B", "COMPOUND_A", "COMPOUND_B", "COMPOUND_I", "COMPLEX_L", "LOGIC_COMPLEX", "LOGIC_COMPOUND", "HAS_COMPOUND", "KEY_FORM_FOCUS", "KEY_INPUT_BUTTON", "KEY_INPUT_DATE", "KEY_INPUT_TEXT", "KEY_INPUT_EDIT", "KEY_INPUT_LTR", "KEY_LOGICAL", "KEY_MODIFIER", "KEY_PS_STATE", "KEY_SHADOW_HOST", "REG_LOGIC_COMPLEX", "PSEUDO_CLASS", "N_TH", "LOGIC_COMPLEX", "REG_LOGIC_COMPOUND", "LOGIC_COMPOUND", "REG_LOGIC_HAS_COMPOUND", "HAS_COMPOUND", "REG_WO_LOGICAL", "getType", "o", "resolveContent", "node", "document", "root", "shadow", "host", "mode", "ownerDocument", "refNode", "nodeType", "parentNode", "traverseNode", "walker", "force", "bool", "isCustomElement", "opt", "localName", "formAssociated", "window", "elmConstructor", "attr", "isCustomElementName", "getSlottedTextContent", "nodes", "text", "item", "getDirectionality", "dirAttr", "getEmbeddingLevels", "bidiFactory", "valueKeys", "KEY_INPUT_BUTTON", "KEY_INPUT_TEXT", "items", "itemDir", "itemLocalName", "itemNodeType", "itemTextContent", "level", "parentNodeType", "isContentEditable", "isVisible", "display", "visibility", "isFocusVisible", "type", "KEY_INPUT_EDIT", "isFocusableArea", "child", "keys", "ns", "getNamespaceURI", "ns", "node", "getType", "attributes", "res", "attr", "name", "namespaceURI", "prefix", "value", "isNamespaceDeclared", "root", "parent", "isPreceding", "nodeA", "nodeB", "posBit", "sortNodes", "nodes", "arr", "a", "b", "initNwsapi", "window", "document", "nw", "nwsapi", "filterSelector", "selector", "opt", "complex", "compound", "descend", "simple", "target", "index", "TARGET_SELF", "TARGET_LINEAL", "REG_LOGIC_HAS_COMPOUND", "REG_LOGIC_COMPLEX", "REG_LOGIC_COMPOUND", "REG_WO_LOGICAL", "REG_EMPTY_PS_FUNC", "REG_SHADOW_PS_ELEMENT", "U_FFFD", "unescapeSelector", "selector", "arr", "l", "i", "item", "hexExists", "hex", "str", "low", "high", "deci", "postStr", "preprocess", "args", "index", "preHash", "postHash", "SYNTAX_ERR", "codePoint", "getType", "parseSelector", "res", "ast", "parse", "toPlainObject", "e", "message", "sel", "walkAST", "branches", "info", "walk", "node", "SELECTOR", "PS_CLASS_SELECTOR", "KEY_LOGICAL", "KEY_PS_STATE", "KEY_SHADOW_HOST", "PS_ELEMENT_SELECTOR", "NTH", "findAll", "list", "itemList", "name", "type", "children", "grandChildren", "greatGrandChildren", "sortAST", "asts", "order", "ID_SELECTOR", "CLASS_SELECTOR", "TYPE_SELECTOR", "ATTR_SELECTOR", "a", "b", "typeA", "typeB", "bitA", "bitB", "parseAstName", "prefix", "localName", "matchPseudoElementSelector", "astName", "astType", "opt", "forgive", "warn", "PS_ELEMENT_SELECTOR", "NOT_SUPPORTED_ERR", "SYNTAX_ERR", "getType", "matchDirectionPseudoClass", "ast", "node", "name", "type", "dir", "getDirectionality", "matchLanguagePseudoClass", "value", "STRING", "IDENT", "unescapeSelector", "parent", "res", "ALPHA_NUM", "LANG_PART", "regExtendedLang", "langMain", "langSub", "langRest", "extendedMain", "extendedSub", "len", "extendedRest", "i", "matchAttributeSelector", "astFlags", "astMatcher", "astValue", "css", "generate", "attributes", "contentType", "caseInsensitive", "astAttrName", "attrValues", "astPrefix", "astLocalName", "parseAstName", "item", "itemName", "itemValue", "itemPrefix", "itemLocalName", "isNamespaceDeclared", "astIdentValue", "astStringValue", "attrValue", "matchTypeSelector", "localName", "namespaceURI", "prefix", "nodePrefix", "nodeLocalName", "astNS", "nodeNS", "DIR_NEXT", "DIR_PREV", "Finder", "#ast", "#astCache", "#descendant", "#document", "#documentCache", "#event", "#focus", "#invalidate", "#invalidateResults", "#lastFocusVisible", "#node", "#nodes", "#noexcept", "#qswalker", "#results", "#root", "#selector", "#shadow", "#verifyShadowHost", "#walkers", "#warn", "#window", "window", "e", "opt", "NOT_SUPPORTED_ERR", "selector", "node", "noexcept", "warn", "resolveContent", "func", "focusKeys", "key", "evt", "keyboardKeys", "KEY_MODIFIER", "mouseKeys", "nodes", "ast", "cachedItem", "item", "l", "i", "cssAst", "parseSelector", "branches", "info", "walkAST", "hasHasPseudoFunc", "hasLogicalPseudoFunc", "hasNthChildOfSelector", "hasStatePseudoClass", "invalidate", "descendant", "items", "branch", "COMBINATOR", "leaves", "itemName", "nextItem", "SYNTAX_ERR", "sortAST", "unescapeSelector", "force", "whatToShow", "walker", "anb", "a", "b", "reverse", "parentNode", "matched", "selectorBranches", "refNode", "selectorNodes", "isVisible", "bool", "traverseNode", "nth", "j", "m", "localName", "namespaceURI", "prefix", "itemLocalName", "itemNamespaceURI", "itemPrefix", "nthName", "nthIdentName", "anbMap", "astLeaves", "leaf", "leafType", "combo", "twigLeaves", "itemType", "twig", "nextNode", "astData", "astName", "twigBranches", "isShadowRoot", "invalid", "childAstType", "PS_CLASS_SELECTOR", "lastIndex", "nextNodes", "arr", "astChildren", "forgive", "KEY_LOGICAL", "css", "generate", "forgiven", "child", "find", "nestedLeaf", "leavesSet", "res", "astChild", "matchDirectionPseudoClass", "matchLanguagePseudoClass", "isCustomElement", "stateValue", "prop", "href", "origin", "pathname", "attrURL", "target", "type", "buttons", "hash", "id", "current", "isFocusableArea", "isFocusVisible", "relatedTarget", "focusTarget", "eventKey", "eventTarget", "eventType", "KEY_FORM_FOCUS", "disabled", "parent", "readonly", "writable", "KEY_INPUT_EDIT", "isContentEditable", "placeholder", "targetNode", "KEY_INPUT_TEXT", "attrType", "nodeName", "checked", "chekcKeys", "resetKeys", "submitKeys", "form", "nodeAttrType", "keys", "valid", "KEY_INPUT_DATE", "flowed", "node1", "node2", "host", "astType", "ATTR_SELECTOR", "matchAttributeSelector", "ID_SELECTOR", "CLASS_SELECTOR", "TYPE_SELECTOR", "matchTypeSelector", "PS_ELEMENT_SELECTOR", "matchPseudoElementSelector", "result", "cacheable", "formKeys", "pseudoKeys", "baseNode", "filterLeaves", "compound", "leafName", "pending", "comboName", "dir", "targetType", "TARGET_ALL", "filtered", "complex", "TARGET_SELF", "TARGET_LINEAL", "TARGET_FIRST", "shadowRoot", "pendingItems", "branchLen", "firstTwig", "firstCombo", "firstName", "firstType", "lastTwig", "lastName", "lastType", "pendingItem", "index", "nextCombo", "sortNodes", "collectedNodes", "sort", "entryNodes", "entryNodesLen", "n", "entryCombo", "entryLeaves", "entryNode", "REG_COMPLEX", "COMPOUND_I", "COMBO", "REG_DESCEND", "DESCEND", "REG_SIMPLE", "TAG_ID_CLASS", "DOMSelector", "#window", "#document", "#finder", "#nwsapi", "window", "document", "Finder", "initNwsapi", "selector", "node", "opt", "e", "getType", "filterOpt", "TARGET_SELF", "filterSelector", "res", "TARGET_LINEAL", "nodes", "refNode", "TARGET_FIRST", "TARGET_ALL"]
}
